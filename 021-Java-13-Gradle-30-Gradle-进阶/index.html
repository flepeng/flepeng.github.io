

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="3、Gradle 进阶为了让大家快速的入门 gradle，本章将从整体构建脚本的角度介绍:  什么是 setting 文件，它有什么作用; 说明什么是 build 文件，它又有什么作用 我们可以创建多少个 build project 和 task，他们有什么作用;又是什么关系，如何配置 项目的生命周期 项目发布 使用 Gradle 创建 SpringBoot 项目等  3.1、项目的生命周期Gra">
<meta property="og:type" content="article">
<meta property="og:title" content="30-Gradle 进阶">
<meta property="og:url" content="https://flepeng.github.io/021-Java-13-Gradle-30-Gradle-%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="3、Gradle 进阶为了让大家快速的入门 gradle，本章将从整体构建脚本的角度介绍:  什么是 setting 文件，它有什么作用; 说明什么是 build 文件，它又有什么作用 我们可以创建多少个 build project 和 task，他们有什么作用;又是什么关系，如何配置 项目的生命周期 项目发布 使用 Gradle 创建 SpringBoot 项目等  3.1、项目的生命周期Gra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659346597112.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659346867657.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659346886061.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659346983857.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659347324775.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659347765778.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659354479810.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659354492384.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659355808277.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659356395117.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659356590497.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659356796906.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659357070582.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659357409831.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659361557185.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362177075.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362189626.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362323478.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362372750.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362437655.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659362471356.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659394617189.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659394748459.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659394814037.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659395588766.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659395736601.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659395759654.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659395802614.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396129145.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396151826.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396557742.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396629778.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396643990.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659396785539.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659401087573.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659401299586.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659401526234.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659401846479.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659402304907.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659402835865.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659402862160.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/gradle/1659403079254.png">
<meta property="article:published_time" content="2024-04-06T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.295Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Gradle">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flepeng.github.io/img/java/gradle/1659346597112.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>30-Gradle 进阶 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="30-Gradle 进阶"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-07 00:00" pubdate>
          2024年4月7日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          128 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">30-Gradle 进阶</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="3、Gradle-进阶"><a href="#3、Gradle-进阶" class="headerlink" title="3、Gradle 进阶"></a>3、Gradle 进阶</h1><p>为了让大家快速的入门 gradle，本章将从整体构建脚本的角度介绍:</p>
<ul>
<li>什么是 setting 文件，它有什么作用;</li>
<li>说明什么是 build 文件，它又有什么作用</li>
<li>我们可以创建多少个 build</li>
<li>project 和 task，他们有什么作用;又是什么关系，如何配置</li>
<li>项目的生命周期</li>
<li>项目发布</li>
<li>使用 Gradle 创建 SpringBoot 项目等</li>
</ul>
<h2 id="3-1、项目的生命周期"><a href="#3-1、项目的生命周期" class="headerlink" title="3.1、项目的生命周期"></a>3.1、项目的生命周期</h2><p>Gradle 项目的生命周期分为三大阶段: <code>Initialization -&gt; Configuration -&gt; Execution</code> 每个阶段都有自己的职责，具体如下图所示:</p>
<p><img src="/img/java/gradle/1659346597112.png" srcset="/img/loading.gif" lazyload alt="1659346597112"></p>
<ul>
<li><p><strong>Initialization 阶段</strong>：主要目的是初始化构建，它又分为两个子过程，一个是执行 Init Script，另一个是执行 Setting Script。</p>
<ul>
<li><p>init.gradle 文件会在每个项目 build 之前被调用，用于做一些初始化的操作，它主要有如下作用：</p>
<ul>
<li>配置内部的仓库信息（如公司的 maven 仓库信息）；</li>
<li>配置一些全局属性；</li>
<li>配置用户名及密码信息（如公司仓库的用户名和密码信息）。</li>
</ul>
</li>
<li><p>Setting Script 则更重要，它初始化了一次构建所参与的所有模块。</p>
</li>
</ul>
</li>
<li><p><strong>Configuration 阶段</strong>：这个阶段开始加载项目中所有模块的 Build Script。所谓 “加载” 就是执行 build.gradle 中的语句，根据脚本代码创建对应的 task，最终根据所有 task 生成由 Task 组成的有向无环图(Directed Acyclic Graphs)，如下:<br><img src="/img/java/gradle/1659346867657.png" srcset="/img/loading.gif" lazyload alt="1659346867657"></p>
<p>从而构成如下有向无环树：<br><img src="/img/java/gradle/1659346886061.png" srcset="/img/loading.gif" lazyload alt="1659346886061"></p>
</li>
<li><p><strong>Execution 阶段</strong>：这个阶段会根据上个阶段构建好的有向无环图，按着顺序执行 Task【Action 动作】。</p>
</li>
</ul>
<h2 id="3-2、settings-文件"><a href="#3-2、settings-文件" class="headerlink" title="3.2、settings 文件"></a>3.2、settings 文件</h2><p>首先对 settings 文件的几点说明：</p>
<ol>
<li>作用：主要是在项目初始化阶段确定一下引入哪些工程需要加入到项目构建中，为构建项目工程树做准备。</li>
<li>工程树：gradle 中有工程树的概念，类似于 maven 中的 project 与 module。<br><img src="/img/java/gradle/1659346983857.png" srcset="/img/loading.gif" lazyload alt="1659346983857"></li>
<li>内容：里面主要定义了当前 gradle 项目及子 project 的项目名称</li>
<li>位置：必须放在根工程目录下。</li>
<li>名字：<code>settings.gradle</code>，不能发生变化</li>
<li>对应实例：与 <code>org.gradle.api.initialization.Settings</code> 实例是一一对应的关系。每个项目只有一个 settings 文件。</li>
<li>关注：作为开发者我们只需要关注该文件中的 include 方法即可。使用相对路径【 <code>:</code> 】引入子工程。</li>
<li>一个子工程只有在 setting 文件中配置了才会被 gradle 识别,这样在构建的时候才会被包含进去。</li>
</ol>
<p>案例如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//根工程项目名</span><br>rootProject.name = <span class="hljs-string">'root'</span><br><span class="hljs-comment">//包含的子工程名称</span><br>include <span class="hljs-string">'subject01'</span><br>include <span class="hljs-string">'subject02'</span><br>include <span class="hljs-string">'subject03'</span><br><span class="hljs-comment">//包含的子工程下的子工程名称</span><br>include <span class="hljs-string">'subject01:subproject011'</span><br>include <span class="hljs-string">'subject01:subproject012'</span><br></code></pre></td></tr></table></figure>

<p>项目名称中 <code>:</code> 代表项目的分隔符，类似路径中的 <code>/</code> 如果以 <code>:</code> 开头则表示相对于 root project 。然后 Gradle 会为每个带有 <code>build.gradle</code> 脚本文件的工程构建一个与之对应的 Project 对象。</p>
<h2 id="3-3、Task"><a href="#3-3、Task" class="headerlink" title="3.3、Task"></a>3.3、Task</h2><p>项目实质上是 Task 对象的集合。一个 Task 表示一个逻辑上较为独立的执行过程，比如编译 Java 源代码，拷贝文件，打包 Jar 文件，甚至可以是执行一个系统命令。另外，一个 Task 可以读取和设置 Project 的 Property 以完成特定的操作。</p>
<h3 id="3-3-1、任务入门"><a href="#3-3-1、任务入门" class="headerlink" title="3.3.1、任务入门"></a>3.3.1、任务入门</h3><p><a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html" target="_blank" rel="noopener">参考</a></p>
<p>让我们来先看一个例子:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task A &#123;<br>    println <span class="hljs-string">"root taskA"</span><br>    doFirst()&#123;<br>        println <span class="hljs-string">"root taskA doFirst"</span><br>    &#125;<br>    doLast()&#123;<br>        println <span class="hljs-string">"root taskA doLast"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在文件所在的目录执行命令: gradle A。</p>
<ul>
<li>提示 1 :task 的配置段是在配置阶段完成</li>
<li>提示 2 :task 的 doFirst、doLast 方法是执行阶段完成，并且 doFirst 在 doLast 执行之前执行。</li>
<li>提示 3 :区分任务的配置段和任务的行为，任务的配置段在配置阶段执行，任务的行为在执行阶段执行。</li>
</ul>
<h3 id="3-3-2、任务的行为"><a href="#3-3-2、任务的行为" class="headerlink" title="3.3.2、任务的行为"></a>3.3.2、任务的行为</h3><p>案例如下：doFirst、doLast 两个方法可以在任务内部定义，也可以在任务外部定义</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map=<span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br><span class="hljs-comment">//action属性可以设置为闭包，设置task自身的行为</span><br>map.put(<span class="hljs-string">"action"</span>,&#123;println <span class="hljs-string">"taskD.."</span>&#125;)<br>task(map,<span class="hljs-string">"a"</span>)&#123;<br>    description <span class="hljs-string">'taskA description....'</span><br>    group <span class="hljs-string">"atguigu"</span><br>    <span class="hljs-comment">//在task内部定义doFirst、doLast行为</span><br>    doFirst &#123;<br>        <span class="hljs-keyword">def</span> name = <span class="hljs-string">'doFirst..'</span><br>        println name<br>    &#125;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> name = <span class="hljs-string">'doLast..'</span><br>        println name<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在task外部定义doFirst、doLast行为</span><br>a.doFirst &#123;<br>    println it.description<br>&#125;<br>a.doLast &#123;<br>    println it.group<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：<code>gradle a</code>，输出如下所示：</p>
<p><img src="/img/java/gradle/1659347324775.png" srcset="/img/loading.gif" lazyload alt="1659347324775"></p>
<p>底层原理分析：无论是定义任务自身的 action，还是添加的 doLast、doFirst 方法，其实底层都被放入到一个 Action 的 List 中了，最初这个 action List 是空的，当我们设置了 action【任务自身的行为】，它先将 action 添加到列表中，此时列表中只有一个 action，后续执行 doFirst 的时候 doFirst 在 action 前面添加，执行 doLast 的时候 doLast 在 action 后面添加。doFirst 永远添加在 actions List 的第一位，保证添加的 Action 在现有的 action List 元素的最前面；doLast 永远都是在 action List 末尾添加，保证其添加的 Action 在现有的 action List 元素的最后面。一个往前面添加，一个往后面添加，最后这个 action List 就按顺序形成了 doFirst、doSelf、doLast 三部分的 Actions，就达到 doFirst、doSelf、doLast 三部分的 Actions 顺序执行的目的。</p>
<blockquote>
<p>其中&lt;&lt;代表 doLast，在 gradle5.x 版本之后就废弃，不能使用了，如下所示:</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task hello &lt;&lt; &#123;<br>    println <span class="hljs-string">"Hello world!"</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-3、任务的依赖方式"><a href="#3-3-3、任务的依赖方式" class="headerlink" title="3.3.3、任务的依赖方式"></a>3.3.3、任务的依赖方式</h3><p>Task 之间的依赖关系可以在以下几部分设置：</p>
<p><strong>方式一：参数依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task A &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"TaskA.."</span><br>    &#125;<br>&#125;<br>task <span class="hljs-string">'B'</span>&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"TaskB.."</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//参数方式依赖: dependsOn后面用冒号</span><br>task <span class="hljs-string">'C'</span>(<span class="hljs-string">dependsOn:</span> [<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"TaskC.."</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方式二：内部依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//参数方式依赖</span><br>task <span class="hljs-string">'C'</span> &#123;<br>    <span class="hljs-comment">//内部依赖：dependsOn后面用 = 号</span><br>    dependsOn = [A,B]<br>    doLast &#123;<br>        println <span class="hljs-string">"TaskC.."</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方式三：外部依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//外部依赖:可变参数,引号可加可不加</span><br>C.dependsOn(B,<span class="hljs-string">'A'</span>)<br></code></pre></td></tr></table></figure>

<p>当然：task 也支持跨项目依赖</p>
<p>在 subproject01 工程的 build.gradle 文件中定义:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task A &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"TaskA.."</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 subproject02 工程的 build.gradle 文件中定义:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task B&#123;<br>    dependsOn(<span class="hljs-string">":subproject01:A"</span>) <span class="hljs-comment">//依赖根工程下的subject01中的任务A ：跨项目依赖。</span><br>    doLast &#123;<br>        println <span class="hljs-string">"TaskB.."</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：gradle B，控制台显示如下</p>
<p><img src="/img/java/gradle/1659347765778.png" srcset="/img/loading.gif" lazyload alt="1659347765778"></p>
<p>拓展 1：当一个 Task 依赖多个 Task 的时候，被依赖的 Task 之间如果没有依赖关系，那么它们的执行顺序是随机的，并无影响。</p>
<p>拓展 2：重复依赖的任务只会执行一次，比如：</p>
<ul>
<li>A -&gt; B、C</li>
<li>B -&gt; C<br>任务 A 依赖任务 B 和任务 C、任务 B 依赖 C 任务。执行任务 A 的时候，显然任务 C 被重复依赖了，C 只会执行一次。</li>
</ul>
<h3 id="3-3-4、任务执行"><a href="#3-3-4、任务执行" class="headerlink" title="3.3.4、任务执行"></a>3.3.4、任务执行</h3><p>任务执行语法：<code>gradle [taskName...] [--option-name...]</code>。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>常见的任务(*)</td>
<td>gradle build: 构建项目:编译、测试、打包等操作<br />gradle run: 运行一个服务，需要 application 插件支持，并且指定了主启动类才能运行<br />gradle clean: 请求当前项目的 build 目录<br />gradle init: 初始化 gradle 项目使用<br />gradle wrapper: 生成 wrapper 文件夹的。<br />gradle wrapper 升级 wrapper 版本号: gradle wrapper –gradle-version&#x3D;4.4<br />gradle wrapper –gradle-version 5.2.1 –distribution-type all: 关联源码用</td>
</tr>
<tr>
<td>项目报告相关任务</td>
<td>gradle projects: 列出所选项目及子项目列表，以层次结构的形式显示<br />gradle tasks: 列出所选项目【当前 project，不包含父、子】的已分配给任务组的那些任务。<br />gradle tasks –all:列出所选项目的所有任务。<br />gradle tasks –group&#x3D;”build setup”: 列出所选项目中指定分组中的任务。<br />gradle help –task someTask: 显示某个任务的详细信息<br />gradle dependencies: 查看整个项目的依赖信息，以依赖树的方式显示<br />gradle properties 列出所选项目的属性列表</td>
</tr>
<tr>
<td>调试相关选项</td>
<td>-h, –help: 查看帮助信息<br />-v, –version: 打印 Gradle、 Groovy、 Ant、 JVM 和操作系统版本信息。<br />-S, –full-stacktrace: 打印出所有异常的完整(非常详细)堆栈跟踪信息。<br />-s, –stacktrace: 打印出用户异常的堆栈跟踪(例如编译错误)。<br />-Dorg.gradle.daemon.debug&#x3D;true: 调试 Gradle 守护进程。<br />-Dorg.gradle.debug&#x3D;true: 调试 Gradle 客户端(非 daemon)进程。<br />-Dorg.gradle.debug.port&#x3D;(port number): 指定启用调试时要侦听的端口号。默认值为 5005。</td>
</tr>
<tr>
<td>性能选项:【备注:在 gradle.properties 中指定这些选项中的许多选项，因此不需要命令行标志】</td>
<td>–build-cache, –no-build-cache: 尝试重用先前版本的输出。默认关闭(off)。<br />–max-workers: 设置 Gradle 可以使用的 woker 数。默认值是处理器数。<br />-parallel, –no-parallel: 并行执行项目。有关此选项的限制，请参阅并行项目执行。默认设置为关闭(off)</td>
</tr>
<tr>
<td>守护进程选项</td>
<td>–daemon, –no-daemon: 使用 Gradle 守护进程运行构建。默认是 on<br />–foreground: 在前台进程中启动 Gradle 守护进程。<br />-Dorg.gradle.daemon.idletimeout&#x3D;(number of milliseconds):Gradle Daemon 将在这个空闲时间的毫秒数之后停止自己。默认值为 10800000(3 小时)。</td>
</tr>
<tr>
<td>日志选项</td>
<td>-Dorg.gradle.logging.level&#x3D;(quiet,warn,lifecycle,info,debug): 通过 Gradle 属性设置日志记录级别。<br />-q, –quiet: 只能记录错误信息<br />-w, –warn: 设置日志级别为 warn<br />-i, –info: 将日志级别设置为 info<br />-d, –debug:登录调试模式(包括正常的堆栈跟踪)</td>
</tr>
<tr>
<td>其它(*)</td>
<td>-x: -x 等价于: –exclude-task : 常见 gradle -x test clean build<br />–rerun-tasks: 强制执行任务，忽略 up-to-date，常见 gradle build –rerun-tasks<br />–continue: 忽略前面失败的任务，继续执行，而不是在遇到第一个失败时立即停止执行。每个遇到的故障都将在构建结束时报告，常见：gradle build –continue。<br />gradle init –type pom: 将 maven 项目转换为 gradle 项目(根目录执行)<br /><code>gradle [taskName]</code>: 执行自定义任务</td>
</tr>
</tbody></table>
<p><a href="https://docs.gradle.org/current/userguide/command_line_interface.html" target="_blank" rel="noopener">参考</a></p>
<ul>
<li>拓展：gradle 任务名是缩写: 任务名支持驼峰式命名风格的任务名缩写，如：connectTask 简写为：cT，执行任务 gradle cT。</li>
<li>拓展 1：前面提到的 Gradle 指令本质:一个个的 <code>task[任务]</code>，Gradle 中所有操作都是基于任务完成的。</li>
<li>拓展 2：gradle 默认各指令之间相互的依赖关系：</li>
</ul>
<p><img src="/img/java/gradle/1659354479810.png" srcset="/img/loading.gif" lazyload alt="1659354479810"><br>相关解释：<br><img src="/img/java/gradle/1659354492384.png" srcset="/img/loading.gif" lazyload alt="1659354492384"></p>
<h3 id="3-3-5、任务定义方式"><a href="#3-3-5、任务定义方式" class="headerlink" title="3.3.5、任务定义方式"></a>3.3.5、任务定义方式</h3><p>任务定义方式，总体分为两大类:一种是通过 Project 中的 <code>task()</code>方法，另一种是通过 tasks 对象的 create 或者 register 方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task(<span class="hljs-string">'A'</span>,&#123;<span class="hljs-comment">//任务名称,闭包都作为参数</span><br>    println <span class="hljs-string">"taskA..."</span><br>&#125;)<br>task(<span class="hljs-string">'B'</span>)&#123;<span class="hljs-comment">//闭包作为最后一个参数可以直接从括号中拿出来</span><br>    println <span class="hljs-string">"taskB..."</span><br>&#125;<br>task C&#123;<span class="hljs-comment">//groovy语法支持省略方法括号:上面三种本质是一种</span><br>    println <span class="hljs-string">"taskC..."</span><br>&#125;<br><br><span class="hljs-keyword">def</span> map=<span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>map.put(<span class="hljs-string">"action"</span>,&#123;println <span class="hljs-string">"taskD.."</span>&#125;) <span class="hljs-comment">//action属性可以设置为闭包</span><br>task(map,<span class="hljs-string">"D"</span>);<br>tasks.create(<span class="hljs-string">'E'</span>)&#123;<span class="hljs-comment">//使用tasks的create方法</span><br>    println <span class="hljs-string">"taskE.."</span><br>&#125;<br>tasks.register(<span class="hljs-string">'f'</span>)&#123; <span class="hljs-comment">//注：register执行的是延迟创建。也即只有当task被需要使用的时候才会被创建。</span><br>    println <span class="hljs-string">"taskF...."</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然：我们也可以在定义任务的同时指定任务的属性，具体属性有：</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>基于一个存在的Task来创建，和我们类继承差不多</td>
<td>DefaultTask</td>
</tr>
<tr>
<td>overwrite</td>
<td>是否替换存在的Task，这个和type配合起来用</td>
<td>false</td>
</tr>
<tr>
<td>dependsOn</td>
<td>用于配置任务的依赖</td>
<td><code>[]</code></td>
</tr>
<tr>
<td>action</td>
<td>添加到任务中的一个Action或者一个闭包</td>
<td>null</td>
</tr>
<tr>
<td>description</td>
<td>用于配置任务的描述</td>
<td>null</td>
</tr>
<tr>
<td>group</td>
<td>用于配置任务的分组</td>
<td>null</td>
</tr>
</tbody></table>
<p>在定义任务时也可以给任务分配属性：定义任务的时候可以直接指定任务属性，也可以给已有的任务动态分配属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息</span><br>task(<span class="hljs-string">group:</span> <span class="hljs-string">"atguigu"</span>,<span class="hljs-string">description:</span> <span class="hljs-string">"this is task B"</span>,<span class="hljs-string">"F"</span>)<br><br><span class="hljs-comment">//②.H是任务名，定义任务的同时，在内部直接指定属性信息</span><br>task(<span class="hljs-string">"H"</span>) &#123;<br>    group(<span class="hljs-string">"atguigu"</span>)<br>    description(<span class="hljs-string">"this is the task H"</span>)<br>&#125;<br><br><span class="hljs-comment">//③.Y是任务名，给已有的任务 在外部直接指定属性信息</span><br>task <span class="hljs-string">"y"</span>&#123;&#125;<br>y.group=<span class="hljs-string">"atguigu"</span><br>clean.group(<span class="hljs-string">"atguigu"</span>) <span class="hljs-comment">//案例：给已有的clean任务重新指定组信息</span><br></code></pre></td></tr></table></figure>

<p>可以在 idea 中看到: 上面自定义的那几个任务和 gradle 自带的 clean 任务已经跑到：atguigu 组了。</p>
<p><img src="/img/java/gradle/1659355808277.png" srcset="/img/loading.gif" lazyload alt="1659355808277"></p>
<h3 id="3-3-6、任务类型"><a href="#3-3-6、任务类型" class="headerlink" title="3.3.6、任务类型"></a>3.3.6、任务类型</h3><p>前面我们定义的 task 都是 DefaultTask 类型的，如果要完成某些具体的操作完全需要我们自己去编写 gradle 脚本，势必有些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和 API 方法了。</p>
<table>
<thead>
<tr>
<th>常见任务类型</th>
<th>该类型任务的作用</th>
</tr>
</thead>
<tbody><tr>
<td>Delete</td>
<td>删除文件或目录</td>
</tr>
<tr>
<td>Copy</td>
<td>将文件复制到目标目录中。此任务还可以在复制时重命名和筛选文件。</td>
</tr>
<tr>
<td>CreateStartScripts</td>
<td>创建启动脚本</td>
</tr>
<tr>
<td>Exec</td>
<td>执行命令行进程</td>
</tr>
<tr>
<td>GenerateMavenPom</td>
<td>生成 Maven 模块描述符(POM)文件。</td>
</tr>
<tr>
<td>GradleBuild</td>
<td>执行 Gradle 构建</td>
</tr>
<tr>
<td>Jar</td>
<td>组装 JAR 归档文件</td>
</tr>
<tr>
<td>JavaCompile</td>
<td>编译 Java 源文件</td>
</tr>
<tr>
<td>Javadoc</td>
<td>为 Java 类生成 HTML API 文档</td>
</tr>
<tr>
<td>PublishToMavenRepository</td>
<td>将 MavenPublication 发布到 mavenartifactrepostal。</td>
</tr>
<tr>
<td>Tar</td>
<td>组装 TAR 存档文件</td>
</tr>
<tr>
<td>Test</td>
<td>执行 JUnit (3.8.x、4.x 或 5.x)或 TestNG 测试。</td>
</tr>
<tr>
<td>Upload</td>
<td>将 Configuration 的构件上传到一组存储库。</td>
</tr>
<tr>
<td>War</td>
<td>组装 WAR 档案。</td>
</tr>
<tr>
<td>Zip</td>
<td>组装 ZIP 归档文件。默认是压缩 ZIP 的内容。</td>
</tr>
</tbody></table>
<ul>
<li>提示 1：详细的 gradle 自带 Task 类型，<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">参考</a></li>
<li>提示 2: 官方文档在给出这些任务类型的时候，同时给出了案例代码，可以点进去上述官网地址中的某个类型中观看<br><img src="/img/java/gradle/1659356395117.png" srcset="/img/loading.gif" lazyload alt="1659356395117"></li>
</ul>
<p>具体使用例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task.register(<span class="hljs-string">'myClean'</span>,Delete)&#123;<br>    delete buildDir<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在命令行执行 gradle myClean 发现就可以将当前 project 的 build 目录删除</p>
<p>当然除了 gradle 自带的 task 类型，我们也可以自定义 task 类型，如下所示：</p>
<p>拓展 4: 自定义 Task 类型</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> myTask=task MyDefinitionTask (<span class="hljs-string">type:</span> CustomTask)<br>myTask.doFirst()&#123;<br>    println <span class="hljs-string">"task 执行之前 执行的 doFirst方法"</span><br>&#125;<br>myTask.doLast()&#123;<br>    println <span class="hljs-string">"task 执行之后 执行的 doLast方法"</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultTask</span> &#123;</span><br>    <span class="hljs-comment">//@TaskAction表示Task本身要执行的方法</span><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-keyword">def</span> doSelf()&#123;<br>        println <span class="hljs-string">"Task 自身 在执行的in doSelf"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：gradle MyDefinitionTask</p>
<p>控制台输出：<img src="/img/java/gradle/1659356590497.png" srcset="/img/loading.gif" lazyload alt="1659356590497"></p>
<h3 id="3-3-7、任务的执行顺序"><a href="#3-3-7、任务的执行顺序" class="headerlink" title="3.3.7、任务的执行顺序"></a>3.3.7、任务的执行顺序</h3><p>在 Gradle 中，有三种方式可以指定 Task 执行顺序：</p>
<ol>
<li>dependsOn 强依赖方式</li>
<li>通过 Task 输入输出</li>
<li>通过 API 指定执行顺序</li>
</ol>
<p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="3-3-8、动态分配任务"><a href="#3-3-8、动态分配任务" class="headerlink" title="3.3.8、动态分配任务"></a>3.3.8、动态分配任务</h3><p>gradle 的强大功能不仅仅用于定义任务的功能。例如，可以使用它在循环中注册同一类型的多个任务</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-number">4.</span>times &#123; counter -&gt;<br>    tasks.register(<span class="hljs-string">"task$counter"</span>) &#123;<br>        doLast &#123;<br>            println <span class="hljs-string">"I'm task number $counter"</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一旦注册了任务，就可以通过 API 访问它们。例如，您可以使用它在运行时动态地向任务添加依赖项。Ant 不允许这样的事情发生。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-number">4.</span>times &#123; counter -&gt;<br>    tasks.register(<span class="hljs-string">"task$counter"</span>) &#123;<br>        doLast &#123;<br>            println <span class="hljs-string">"I'm task number $counter"</span><br>        &#125;<br>    &#125;<br>&#125;<br>tasks.named(<span class="hljs-string">'task0'</span>) &#123; dependsOn(<span class="hljs-string">'task2'</span>, <span class="hljs-string">'task3'</span>) &#125;<br></code></pre></td></tr></table></figure>

<p>构建 4 个任务，但是任务 0 必须依赖于任务 2 和 3，那么代表任务 2 和 3 需要在任务 0 之前优先加载。具体测试如下:<br><img src="/img/java/gradle/1659356796906.png" srcset="/img/loading.gif" lazyload alt="1659356796906"></p>
<h3 id="3-3-9、任务的关闭与开启"><a href="#3-3-9、任务的关闭与开启" class="headerlink" title="3.3.9、任务的关闭与开启"></a>3.3.9、任务的关闭与开启</h3><p>每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task disableMe &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">'This task is Executing...'</span><br>    &#125;<br>    enabled(<span class="hljs-literal">true</span>)<span class="hljs-comment">//直接设置任务开启，默认值为true</span><br>&#125;<br><span class="hljs-comment">//disableMe.enabled = false //设置关闭任务</span><br></code></pre></td></tr></table></figure>


<h3 id="3-3-10、任务的超时"><a href="#3-3-10、任务的超时" class="headerlink" title="3.3.10、任务的超时"></a>3.3.10、任务的超时</h3><p>每个任务都有一个 timeout 可用于限制其执行时间的属性。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果 –continue 使用，其他任务可以在此之后继续运行。不响应中断的任务无法超时。Gradle 的所有内置任务均会及时响应超时</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task a &#123;<br>    doLast &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        println <span class="hljs-string">"当前任务a执行了"</span><br>    &#125;<br>    timeout = Duration.ofMillis(<span class="hljs-number">500</span>)<br>&#125;<br>task b &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"当前任务b执行了"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在控制台使用: gradle a b 测试会发现执行 a 的时候，由于 a 执行超时，抛出异常，所以没有继续往下执行【b 也没执行】。</p>
<p>然后在控制台使用: <code>gradle a b -continue</code>，测试会发现 a 虽然执行失败，但是 b 还是执行了。</p>
<h3 id="3-3-11、任务的查找"><a href="#3-3-11、任务的查找" class="headerlink" title="3.3.11、任务的查找"></a>3.3.11、任务的查找</h3><p>常用的任务查找方法有：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task atguigu &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"让天下没有难学的技术：尚硅谷"</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//根据任务名查找</span><br>tasks.findByName(<span class="hljs-string">"atguigu"</span>).doFirst(&#123;println <span class="hljs-string">"尚硅谷校区1：北京...."</span>&#125;)<br>tasks.getByName(<span class="hljs-string">"atguigu"</span>).doFirst(&#123;println <span class="hljs-string">"尚硅谷校区2：深圳...."</span>&#125;)<br><span class="hljs-comment">//根据任务路径查找【相对路径】</span><br>tasks.findByPath(<span class="hljs-string">":atguigu"</span>).doFirst(&#123;println <span class="hljs-string">"尚硅谷校区3：上海...."</span>&#125;)<br>tasks.getByPath(<span class="hljs-string">":atguigu"</span>).doFirst(&#123;println <span class="hljs-string">"尚硅谷校区4：武汉...."</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>执行 <code>task:gradle atguigu</code>，输出结果如下所示：<br><img src="/img/java/gradle/1659357070582.png" srcset="/img/loading.gif" lazyload alt="1659357070582"></p>
<h3 id="3-3-12、任务的规则"><a href="#3-3-12、任务的规则" class="headerlink" title="3.3.12、任务的规则"></a>3.3.12、任务的规则</h3><p>当我们执行、依赖一个不存在的任务时，Gradle 会执行失败，报错误信息。那我们能否对其进行改进，当执行一个不存在的任务时，不是报错而是打印提示信息呢？</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task hello &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">'hello 尚硅谷的粉丝们'</span><br>    &#125;<br>&#125;<br>tasks.addRule(<span class="hljs-string">"对该规则的一个描述，便于调试、查看等"</span>) &#123;<br>    String taskName -&gt; task(taskName) &#123;<br>        doLast &#123;<br>            println <span class="hljs-string">"该$&#123;taskName&#125;任务不存在，请查证后再执行"</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试: 使用 <code>gradle abc hello</code> 进行测试，此时当 abc 任务不存在时，也不会报异常【不中断执行】而是提示自定义的规则信息，继续执行 hello 任务。此外，它还可以根据不同的规则动态创建需要的任务等情况。</p>
<h3 id="3-3-13、任务的-onlyIf-断言"><a href="#3-3-13、任务的-onlyIf-断言" class="headerlink" title="3.3.13、任务的 onlyIf 断言"></a>3.3.13、任务的 onlyIf 断言</h3><p>断言就是一个条件表达式。Task 有一个 onlyIf 方法。它接受一个闭包作为参数，如果该闭包返回 true 则该任务执行，否则跳过。这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时候不执行网络测试等。具体案例如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task hello &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">'hello 尚硅谷的粉丝们'</span><br>    &#125;<br>&#125;<br>hello.onlyIf&#123;!project.hasProPerty(<span class="hljs-string">'fensi'</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>测试：通过 <code>-P</code> 为 Project 添加 fensi 属性: <code>gradle hello -Pfensi</code></p>
<h3 id="3-3-14、默认任务"><a href="#3-3-14、默认任务" class="headerlink" title="3.3.14、默认任务"></a>3.3.14、默认任务</h3><p>Gradle 允许您定义一个或多个在没有指定其他任务时执行的默认任务。</p>
<p>代码如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">defaultTasks <span class="hljs-string">'myClean'</span>, <span class="hljs-string">'myRun'</span><br>tasks.register(<span class="hljs-string">'myClean'</span>)&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">'Default Cleaning!'</span><br>    &#125;<br>&#125;<br>tasks.register(<span class="hljs-string">'myRun'</span>) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">'Default Running!'</span><br>    &#125;<br>&#125;<br>tasks.register(<span class="hljs-string">'other'</span>) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">"I'm not a default task!"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试及结果如下：<br><img src="/img/java/gradle/1659357409831.png" srcset="/img/loading.gif" lazyload alt="1659357409831"></p>
<h2 id="3-4、Gradle中的文件操作"><a href="#3-4、Gradle中的文件操作" class="headerlink" title="3.4、Gradle中的文件操作"></a>3.4、Gradle中的文件操作</h2><p>几种常见的文件操作方式：</p>
<ul>
<li>本地文件</li>
<li>文件集合</li>
<li>文件树</li>
<li>文件拷贝</li>
<li>归档文件</li>
</ul>
<h3 id="3-4-1、本地文件"><a href="#3-4-1、本地文件" class="headerlink" title="3.4.1、本地文件"></a>3.4.1、本地文件</h3><p>使用 <code>Project.file(java.lang.Object)</code> 方法，通过指定文件的相对路径或绝对路径来对文件的操作，其中相对路径为相对当前 <code>project[根 project 或者子 project]</code> 的目录。其实使用 <code>Project.file(java.lang.Object)</code> 方法创建的 File 对象就是 Java 中的 File 对象，我们可以使用它就像在 Java 中使用一样。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//使用相对路径</span><br>File configFile = file(<span class="hljs-string">'src/conf.xml'</span>)<br>configFile.createNewFile();<br><span class="hljs-comment">// 使用绝对路径</span><br>configFile = file(<span class="hljs-string">'D:\\conf.xml'</span>)<br>println(configFile.createNewFile())<br><span class="hljs-comment">// 使用一个文件对象</span><br>configFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">'src/config.xml'</span>)<br>println(configFile.exists())<br></code></pre></td></tr></table></figure>

<h3 id="3-4-2、文件集合"><a href="#3-4-2、文件集合" class="headerlink" title="3.4.2、文件集合"></a>3.4.2、文件集合</h3><p>文件集合就是一组文件的列表，在 Gradle 中，文件集合用 FileCollection 接口表示。我们可以使用 <code>Project.files(java.lang.Object[])</code> 方法来获得一个文件集合对象，如下代码创建一个 FileCollection 实例：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> collection = files(<span class="hljs-string">'src/test1.txt'</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">'src/test2.txt'</span>),[<span class="hljs-string">'src/test3.txt'</span>, <span class="hljs-string">'src/test4.txt'</span>])<br>collection.forEach()&#123;File it -&gt;<br>    it.createNewFile() <span class="hljs-comment">//创建该文件</span><br>    println it.name <span class="hljs-comment">//输出文件名</span><br>&#125;<br>Set set1 = collection.files <span class="hljs-comment">// 把文件集合转换为java中的Set类型</span><br>Set set2 = collection <span class="hljs-keyword">as</span> Set<br>List list = collection <span class="hljs-keyword">as</span> List<span class="hljs-comment">// 把文件集合转换为java中的List类型</span><br><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> list) &#123;<br>    println item.name<br>&#125;<br><span class="hljs-keyword">def</span> union = collection + files(<span class="hljs-string">'src/test5.txt'</span>) <span class="hljs-comment">// 添加或者删除一个集合</span><br><span class="hljs-keyword">def</span> minus = collection *   files(<span class="hljs-string">'src/test3.txt'</span>)<br>union.forEach()&#123;File it -&gt;<br>    println it.name<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于文件集合我们可以遍历它；也可以把它转换成 java 类型；同时还能使用+来添加一个集合，或使用-来删除集合。</p>
<h3 id="3-4-3、文件树"><a href="#3-4-3、文件树" class="headerlink" title="3.4.3、文件树"></a>3.4.3、文件树</h3><p>文件树是有层级结构的文件集合，一个文件树它可以代表一个目录结构或一 ZIP 压缩包中的内容结构。文件树是从文件集合继承过来的，所以文件树具有文件集合所有的功能。我们可以使用 <code>Project.fileTree(java.util.Map)</code> 方法来创建文件树对象，还可以使用过虑条件来包含或排除相关文件。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 第一种方式:使用路径创建文件树对象，同时指定包含的文件</span><br>tree = fileTree(<span class="hljs-string">'src/main'</span>).include(<span class="hljs-string">'**/*.java'</span>)<br><br><span class="hljs-comment">//第二种方式:通过闭包创建文件树:</span><br>tree = fileTree(<span class="hljs-string">'src/main'</span>) &#123;<br>    include <span class="hljs-string">'**/*.java'</span><br>&#125;<br><br><span class="hljs-comment">//第三种方式:通过路径和闭包创建文件树：具名参数给map传值</span><br>tree = fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'src/main'</span>, <span class="hljs-string">include:</span> <span class="hljs-string">'**/*.java'</span>) <br>tree = fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'src/main'</span>, <span class="hljs-string">includes:</span> [<span class="hljs-string">'**/*.java'</span>, <span class="hljs-string">'**/*.xml'</span>, <span class="hljs-string">'**/*.txt'</span>], <span class="hljs-string">exclude:</span> <span class="hljs-string">'**/*test*/**'</span>)<br>tree.each &#123;File file -&gt; <span class="hljs-comment">// 遍历文件树的所有文件</span><br>    println file<br>    println file.name<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-4-4、文件拷贝"><a href="#3-4-4、文件拷贝" class="headerlink" title="3.4.4、文件拷贝"></a>3.4.4、文件拷贝</h3><p>我们可以使用 Copy 任务来拷贝文件，通过它可以过虑指定拷贝内容，还能对文件进行重命名操作等。Copy 任务必须指定一组需要拷贝的文件和拷贝到的目录，这里使用 <code>CopySpec.from(java.lang.Object[])</code> 方法指定原文件；使用 <code>CopySpec.into(java.lang.Object)</code> 方法指定目标目录。示例代码如下</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task copyTask(<span class="hljs-string">type:</span> Copy) &#123;<br>    from <span class="hljs-string">'src/main/resources'</span><br>    into <span class="hljs-string">'build/config'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>from()</code> 方法接受的参数和文件集合时 <code>files()</code> 一样。当参数为一个目录时，该目录下所有的文件都会被拷贝到指定目录下（目录自身不会被拷贝）；当参数为一个文件时，该文件会被拷贝到指定目录；如果参数指定的文件不存在，就会被忽略；</p>
<p>当参数为一个 Zip 压缩文件，该压缩文件的内容会被拷贝到指定目录。</p>
<p><code>into()</code> 方法接受的参数与本地文件时 <code>file()</code>一样。示例代码如下</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task copyTask(<span class="hljs-string">type:</span> Copy) &#123;<br>    <span class="hljs-comment">// 拷贝src/main/webapp目录下所有的文件</span><br>    from <span class="hljs-string">'src/main/webapp'</span><br>    <span class="hljs-comment">// 拷贝单独的一个文件</span><br>    from <span class="hljs-string">'src/staging/index.html'</span><br>    <span class="hljs-comment">// 从Zip压缩文件中拷贝内容</span><br>    from zipTree(<span class="hljs-string">'src/main/assets.zip'</span>)<br>    <span class="hljs-comment">// 拷贝到的目标目录</span><br>    into <span class="hljs-string">'build/explodedWar'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在拷贝文件的时候还可以添加过虑条件来指定包含或排除的文件，示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task copyTaskWithPatterns(<span class="hljs-string">type:</span> Copy) &#123;<br>    from <span class="hljs-string">'src/main/webapp'</span><br>    into <span class="hljs-string">'build/explodedWar'</span><br>    include <span class="hljs-string">'**/*.html'</span><br>    include <span class="hljs-string">'**/*.jsp'</span><br>    exclude &#123; details -&gt; details.file.name.endsWith(<span class="hljs-string">'.html'</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在拷贝文件的时候还可以对文件进行重命名操作，示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task rename(<span class="hljs-string">type:</span> Copy) &#123;<br>    from <span class="hljs-string">'src/main/webapp'</span><br>    into <span class="hljs-string">'build/explodedWar'</span><br>    <span class="hljs-comment">// 使用一个闭包方式重命名文件</span><br>    rename &#123; String fileName -&gt;<br>        fileName.replace(<span class="hljs-string">'-staging-'</span>, <span class="hljs-string">''</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中我们都是使用 Copy 任务来完成拷贝功能的，那么有没有另外一种方式呢？答案是肯定的，那就是 <code>Project.copy(org.gradle.api.Action)</code> 方法。下面示例展示了 <code>copy()</code> 方法的使用方式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task copyMethod &#123;<br>    doLast &#123;<br>        copy &#123;<br>            from <span class="hljs-string">'src/main/webapp'</span><br>            into <span class="hljs-string">'build/explodedWar'</span><br>            include <span class="hljs-string">'**/*.html'</span><br>            include <span class="hljs-string">'**/*.jsp'</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>或者使用 project 对象的 copy 方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">copy &#123;<br>    <span class="hljs-comment">// 相对路径或者绝对路径</span><br>    from file(<span class="hljs-string">'src/main/resources/ddd.txt'</span>) <span class="hljs-comment">//file也可以换成new File()</span><br>    into <span class="hljs-keyword">this</span>.buildDir.absolutePath<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行 gradle build 指令即可。去 build 目录的本地磁盘查看，就能看到。</p>
<h3 id="3-4-5、归档文件"><a href="#3-4-5、归档文件" class="headerlink" title="3.4.5、归档文件"></a>3.4.5、归档文件</h3><p>通常一个项目会有很多的 Jar 包，我们希望把项目打包成一个 WAR，ZIP 或 TAR 包进行发布，这时我们就可以使用Zip，Tar，Jar，War 和 Ear 任务来实现，不过它们的用法都一样，所以在这里我只介绍 Zip 任务的示例。</p>
<p>首先，创建一个 Zip 压缩文件,并指定压缩文件名称，如下代码所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span><br>version=<span class="hljs-number">1.0</span><br>task myZip(<span class="hljs-string">type:</span> Zip) &#123;<br>    from <span class="hljs-string">'src/main'</span><br>    into <span class="hljs-string">'build'</span> <span class="hljs-comment">//保存到build目录中</span><br>    baseName = <span class="hljs-string">'myGame'</span><br>&#125;<br>println myZip.archiveName<br></code></pre></td></tr></table></figure>

<p>执行命令 gradle -q myZip，输出结果为：</p>
<p><img src="/img/java/gradle/1659361557185.png" srcset="/img/loading.gif" lazyload alt="1659361557185"></p>
<p>最后，我们可以使用 <code>Project.zipTree(java.lang.Object)</code> 和 <code>Project.tarTree(java.lang.Object)</code> 方法来创建访问 Zip 压缩包的文件树对象，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 使用zipTree</span><br>FileTree zip = zipTree(<span class="hljs-string">'someFile.zip'</span>)<br><span class="hljs-comment">// 使用tarTree</span><br>FileTree tar = tarTree(<span class="hljs-string">'someFile.tar'</span>)<br></code></pre></td></tr></table></figure>

<p>在这里，我们介绍了 Gradle 对本地文件、文件集合、文件树、文件拷贝和归档文件的操作方式。</p>
<p><a href="https://docs.gradle.org/current/userguide/working_with_files.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="3-5、Dependencies"><a href="#3-5、Dependencies" class="headerlink" title="3.5、Dependencies"></a>3.5、Dependencies</h2><h3 id="3-5-1、依赖的方式"><a href="#3-5-1、依赖的方式" class="headerlink" title="3.5.1、依赖的方式"></a>3.5.1、依赖的方式</h3><p>Gradle 中的依赖分别为直接依赖，项目依赖，本地 jar 依赖。</p>
<p>案例如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-comment">//①.依赖当前项目下的某个模块[子工程]</span><br>    implementation project(<span class="hljs-string">':subject01'</span>)<br>    <br>    <span class="hljs-comment">//②.直接依赖本地的某个jar文件</span><br>    implementation files(<span class="hljs-string">'libs/foo.jar'</span>, <span class="hljs-string">'libs/bar.jar'</span>)<br>    <span class="hljs-comment">//②.配置某文件夹作为依赖项</span><br>    implementation fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])<br>    <br>    <span class="hljs-comment">//③.直接依赖</span><br>    implementation <span class="hljs-string">'org.apache.logging.log4j:log4j:2.17.2'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>直接依赖</strong>：在项目中直接导入的依赖，就是直接依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">'org.apache.logging.log4j:log4j:2.17.2'</span><br></code></pre></td></tr></table></figure>

<p>上面是简写法，完整版写法如下:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.logging.log4j'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'log4j'</span>, <span class="hljs-string">version:</span> <span class="hljs-string">'2.17.2'</span><br></code></pre></td></tr></table></figure>

<p>group&#x2F;name&#x2F;version 共同定位一个远程仓库，version 最好写一个固定的版本号，以防构建出问题，implementation 类似 maven 中的依赖的 scope，对比 maven 中的依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>项目依赖</strong>：从项目的某个模块依赖另一个模块</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation project(<span class="hljs-string">':subject01'</span>)<br></code></pre></td></tr></table></figure>

<p>这种依赖方式是直接依赖本工程中的 libary module，这个 libary module 需要在 setting.gradle 中配置。</p>
<p><strong>本地 jar 依赖</strong>：本地 jar 文件依赖，一般包含以下两种方式</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//直接依赖某文件</span><br>implementation files(<span class="hljs-string">'libs/foo.jar'</span>, <span class="hljs-string">'libs/bar.jar'</span>)<br><span class="hljs-comment">//配置某文件夹作为依赖项</span><br>implementation fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])<br></code></pre></td></tr></table></figure>

<h3 id="3-5-2、依赖的下载"><a href="#3-5-2、依赖的下载" class="headerlink" title="3.5.2、依赖的下载"></a>3.5.2、依赖的下载</h3><p>当执行 build 命令时，gradle 就会去配置的依赖仓库中下载对应的 Jar，并应用到项目中。</p>
<h3 id="3-5-3、依赖的类型"><a href="#3-5-3、依赖的类型" class="headerlink" title="3.5.3、依赖的类型"></a>3.5.3、依赖的类型</h3><p>类似于 Maven 的 scope 标签，gradle 也提供了依赖的类型，具体如下所示:</p>
<table>
<thead>
<tr>
<th>依赖类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>compileOnly</td>
<td>由 java 插件提供,曾短暂的叫 provided,后续版本已经改成了 compileOnly,适用于编译期需要而不需要打包的情况</td>
</tr>
<tr>
<td>runtimeOnly</td>
<td>由 java 插件提供,只在运行期有效,编译时不需要,比如 mysql 驱动包。,取代老版本中被移除的 runtime</td>
</tr>
<tr>
<td><strong>implementation</strong></td>
<td>由 java 插件提供,针对源码<code>[src/main 目录]</code> ,在编译、运行时都有效,取代老版本中被移除的 compile</td>
</tr>
<tr>
<td>testCompileOnly</td>
<td>由 java 插件提供,用于编译测试的依赖项，运行时不需要</td>
</tr>
<tr>
<td>testRuntimeOnly</td>
<td>由 java 插件提供,只在测试运行时需要，而不是在测试编译时需要,取代老版本中被移除的 testRuntime</td>
</tr>
<tr>
<td>testImplementation</td>
<td>由 java 插件提供,针对测试代码<code>[src/test 目录]</code> 取代老版本中被移除的 testCompile</td>
</tr>
<tr>
<td>providedCompile</td>
<td>war 插件提供支持，编译、测试阶段代码需要依赖此类 jar 包，而运行阶段容器已经提供了相应的支持，所以无需将这些文件打入到 war 包中了;例如 servlet-api.jar、jsp-api.jar</td>
</tr>
<tr>
<td>compile</td>
<td>编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。在 gradle 7.0 已经移除</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime 依赖在运行和测试系统的时候需要,在编译的时候不需要,比如 mysql 驱动包。在 gradle 7.0 已经移除</td>
</tr>
<tr>
<td><strong>api</strong></td>
<td>java-library 插件提供支持,这些依赖项可以传递性地导出给使用者，用于编译时和运行时。取代老版本中被移除的 compile</td>
</tr>
<tr>
<td>compileOnlyApi</td>
<td>java-library 插件提供支持,在声明模块和使用者在编译时需要的依赖项，但在运行时不需要。</td>
</tr>
</tbody></table>
<p>官方文档参考：</p>
<ul>
<li><a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin" target="_blank" rel="noopener">各个依赖范围的关系和说明</a></li>
<li><a href="https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal" target="_blank" rel="noopener">依赖范围升级和移除</a></li>
<li><a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin" target="_blank" rel="noopener">API 和 implemention 区别</a></li>
<li><a href="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin" target="_blank" rel="noopener">执行 java 命令时都使用了哪些依赖范围的依赖</a></li>
</ul>
<p>提示 1：java 插件提供的功能，java-library 插件都提供。</p>
<h3 id="3-5-4、api-与-implementation-区别"><a href="#3-5-4、api-与-implementation-区别" class="headerlink" title="3.5.4、api 与 implementation 区别"></a>3.5.4、api 与 implementation 区别</h3><p><img src="/img/java/gradle/1659362177075.png" srcset="/img/loading.gif" lazyload alt="1659362177075"></p>
<p>如下所示：</p>
<p><img src="/img/java/gradle/1659362189626.png" srcset="/img/loading.gif" lazyload alt="1659362189626"></p>
<ul>
<li><p>编译时: 如果 libC 的内容发生变化，由于使用的是 api 依赖，依赖会传递，所以 libC、libA、projectX 都要发生变化，都需要重新编译，速度慢</p>
</li>
<li><p>运行时：libC、libA、projectX 中的 class 都要被加载。</p>
</li>
<li><p>编译时: 如果 libD 的内容发生变化，由于使用的是 implemetation 依赖，依赖不会传递，只有 libD、libB 要变化并重新编译，速度快</p>
</li>
<li><p>运行时：libC、libA、projectX 中的 class 都要被加载。</p>
</li>
</ul>
<p>拓展 3: api 和 implementation 案例分析</p>
<p>api 的适用场景是多 module 依赖，moduleA 工程依赖了 module B，同时 module B 又需要依赖了 module C，modelA 工程也需要去依赖 module C，这个时候避免重复依赖 module，可以使用 module B api 依赖的方式去依赖 module C，modelA 工程只需要依赖 moduleB 即可。<br><img src="/img/java/gradle/1659362323478.png" srcset="/img/loading.gif" lazyload alt="1659362323478"></p>
<p>总之，除非涉及到多模块依赖，为了避免重复依赖，咱们会使用 api，其它情况我们优先选择 implementation，拥有大量的 api 依赖项会显著增加构建时间。</p>
<h3 id="3-5-5、依赖冲突及解决方案"><a href="#3-5-5、依赖冲突及解决方案" class="headerlink" title="3.5.5、依赖冲突及解决方案"></a>3.5.5、依赖冲突及解决方案</h3><p>依赖冲突是指 “在编译过程中，如果存在某个依赖的多个版本，构建系统应该选择哪个进行构建的问题”，如下所示:</p>
<p><img src="/img/java/gradle/1659362372750.png" srcset="/img/loading.gif" lazyload alt="1659362372750"></p>
<p>A、B、C 都是本地子项目 module，log4j 是远程依赖。</p>
<ul>
<li>编译时：B 用 1.4.2 版本的 log4j，C 用 2.2.4 版本的 log4j，B 和 C 之间没有冲突</li>
<li>打包时：只能有一个版本的代码最终打包进最终的A对应的jar | war包，对于 Gradle 来说这里就有冲突了</li>
</ul>
<p>案例演示：我们在 build.gradle 引入依赖库</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span><br>    testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span><br>    implementation <span class="hljs-string">'org.hibernate:hibernate-core:3.6.3.Final'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/java/gradle/1659362437655.png" srcset="/img/loading.gif" lazyload alt="1659362437655"></p>
<p>修改 build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span><br>    testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span><br>    implementation <span class="hljs-string">'org.hibernate:hibernate-core:3.6.3.Final'</span><br>    implementation <span class="hljs-string">'org.slf4j:slf4j-api:1.4.0'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/java/gradle/1659362471356.png" srcset="/img/loading.gif" lazyload alt="1659362471356"></p>
<p>如上所示：默认下，Gradle 会使用最新版本的 jar 包【考虑到新版本的 jar 包一般都是向下兼容的】，实际开发中，还是建议使用官方自带的这种解决方案。当然除此之外，Gradle 也为我们提供了一系列的解决依赖冲突的方法: exclude 移除一个依赖，不允许依赖传递，强制使用某个版本。</p>
<p><strong>Exclude 排除某个依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span><br>    testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span><br>    implementation(<span class="hljs-string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)&#123;<br>        <span class="hljs-comment">//排除某一个库(slf4j)依赖:如下三种写法都行</span><br>        exclude <span class="hljs-string">group:</span> <span class="hljs-string">'org.slf4j'</span><br>        exclude <span class="hljs-string">module:</span> <span class="hljs-string">'slf4j-api'</span><br>        exclude <span class="hljs-string">group:</span> <span class="hljs-string">'org.slf4j'</span>,<span class="hljs-string">module:</span> <span class="hljs-string">'slf4j-api'</span><br>    &#125;<br>    <span class="hljs-comment">//排除之后,使用手动的引入即可。</span><br>    implementation <span class="hljs-string">'org.slf4j:slf4j-api:1.4.0'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>不允许依赖传递</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span><br>    testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span><br>    implementation(<span class="hljs-string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)&#123;<br>        <span class="hljs-comment">//不允许依赖传递，一般不用</span><br>        transitive(<span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-comment">//排除之后,使用手动的引入即可</span><br>    implementation <span class="hljs-string">'org.slf4j:slf4j-api:1.4.0'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在添加依赖项时，如果设置 transitive 为 false，表示关闭依赖传递。即内部的所有依赖将不会添加到编译和运行时的类路径。</p>
<p><strong>强制使用某个版本</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span><br>    testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span><br>    implementation(<span class="hljs-string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)<br>    <span class="hljs-comment">//强制使用某个版本!!【官方建议使用这种方式】</span><br>    implementation(<span class="hljs-string">'org.slf4j:slf4j-api:1.4.0!!'</span>)<br>    <span class="hljs-comment">//这种效果和上面那种一样,强制指定某个版本</span><br>    implementation(<span class="hljs-string">'org.slf4j:slf4j-api:1.4.0'</span>)&#123;<br>        version&#123;<br>            strictly(<span class="hljs-string">"1.4.0"</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>拓展：我们可以先查看当前项目中到底有哪些依赖冲突：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//下面我们配置，当 Gradle 构建遇到依赖冲突时，就立即构建失败</span><br>configurations.all() &#123;<br>    Configuration configuration -&gt;<br>        <span class="hljs-comment">//当遇到版本冲突时直接构建失败</span><br>        configuration.resolutionStrategy.failOnVersionConflict()<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="3-6、Gradle插件"><a href="#3-6、Gradle插件" class="headerlink" title="3.6、Gradle插件"></a>3.6、Gradle插件</h2><h3 id="3-6-1、使用插件的原因"><a href="#3-6-1、使用插件的原因" class="headerlink" title="3.6.1、使用插件的原因"></a>3.6.1、使用插件的原因</h3><p>简单的说，通过应用插件我们可以:</p>
<ol>
<li>促进代码重用、减少功能类似代码编写、提升工作效率</li>
<li>促进项目更高程度的模块化、自动化、便捷化</li>
<li>可插拔式的的扩展项目的功能</li>
</ol>
<h3 id="3-6-2、插件的作用"><a href="#3-6-2、插件的作用" class="headerlink" title="3.6.2、插件的作用"></a>3.6.2、插件的作用</h3><p>在项目构建过程中做很多事情，把插件应用到项目中，通常可以完成:</p>
<ol>
<li>可以添加任务【task】到项目中，从而帮助完成测试、编译、打包等。</li>
<li>可以添加依赖配置到项目中。</li>
<li>可以向项目中拓展新的扩展属性、方法等。</li>
<li>可以对项目进行一些约定，如应用 Java 插件后，约定 <code>src/main/java</code> 目录是我们的源代码存在位置，编译时编译这个目录下的 Java 源代码文件。</li>
</ol>
<h3 id="3-6-3、插件的分类和使用"><a href="#3-6-3、插件的分类和使用" class="headerlink" title="3.6.3、插件的分类和使用"></a>3.6.3、插件的分类和使用</h3><p><img src="/img/java/gradle/1659394617189.png" srcset="/img/loading.gif" lazyload alt="1659394617189"></p>
<p><strong>第一种：脚本插件</strong></p>
<p>脚本插件的本质就是一个脚本文件，使用脚本插件时通过 <code>apply from:</code> 将脚本加载进来就可以了，后面的脚本文件可以是本地的也可以是网络上的脚本文件，下面定义一段脚本，我们在 build.gradle 文件中使用它，具体如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//version.gradle文件</span><br>ext &#123;<br>    company= <span class="hljs-string">"尚硅谷"</span><br>    cfgs = [<br>        <span class="hljs-string">compileSdkVersion :</span> JavaVersion.VERSION_1_8<br>    ]<br>    spring = [<br>        <span class="hljs-string">version :</span> <span class="hljs-string">'5.0.0'</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面将将在构建文件中使用这个脚本文件，具体如下:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//build.gradle文件</span><br><span class="hljs-comment">//map作为参数</span><br>apply <span class="hljs-string">from:</span> <span class="hljs-string">'version.gradle'</span><br>task taskVersion&#123;<br>    doLast&#123;<br>        println <span class="hljs-string">"公司名称为：$&#123;company&#125;,JDK版本是$&#123;cfgs.compileSdkVersion&#125;,版本号是$&#123;spring.version&#125;"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的执行结果如下：</p>
<p><img src="/img/java/gradle/1659394748459.png" srcset="/img/loading.gif" lazyload alt="1659394748459"></p>
<p>意义：脚本文件模块化的基础，可按功能把我们的脚本进行拆分一个个公用、职责分明的文件，然后在主脚本文件引用，比如：将很多共有的库版本号一起管理、应用构建版本一起管理等。</p>
<p><strong>第二种1：对象插件之内部插件<code>[核心插件]</code></strong></p>
<p>二进制插件<code>[对象插件]</code>就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id。</p>
<p><img src="/img/java/gradle/1659394814037.png" srcset="/img/loading.gif" lazyload alt="1659394814037"></p>
<p>可通过如下方式使用一个 Java 插件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-string">plugin :</span> <span class="hljs-string">'java'</span> <span class="hljs-comment">// map具名参数方式</span><br><br><span class="hljs-comment">// 或者也可以使用闭包作为project.apply方法的一个参数</span><br>apply &#123;<br>    plugin <span class="hljs-string">'java'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上述代码就将 Java 插件应用到我们的项目中了，对于 Gradle 自带的核心插件都有唯一的 plugin id，其中 <code>java</code> 是 Java 插件的 plugin id，这个 plugin id 必须是唯一的，可使用应用包名来保证 plugin id 的唯一性。这里的 java 对应的具体类型是 <code>org.gradle.api.plugins.JavaPlugin</code>，所以可以使用如下方式使用 Java 插件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//使用方式1：Map具名参数,全类名</span><br>apply <span class="hljs-string">plugin:</span>org.gradle.api.plugins.JavaPlugin<br><br><span class="hljs-comment">//使用方式2：org.gradle.api.plugins默认导入</span><br>apply <span class="hljs-string">plugin:</span>JavaPlugin<br><br><span class="hljs-comment">//使用方式3：插件的id</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span> <span class="hljs-comment">//核心插件，无需事先引入，</span><br></code></pre></td></tr></table></figure>

<p>Gradle 中提供的二进制插件 <a href="https://docs.gradle.org/current/userguide/plugin_reference.html" target="_blank" rel="noopener">核心插件</a></p>
<p><strong>第二种2：对象插件之第三方插件</strong></p>
<p>如果是使用第三方发布的二进制插件，一般需要配置对应的仓库和类路径</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//使用传统的应用方式</span><br>buildscript &#123;<br>    ext &#123;<br>        springBootVersion = <span class="hljs-string">"2.3.3.RELEASE"</span><br>    &#125;<br>    repositories &#123;<br>        mavenLocal()<br>        maven &#123; url <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;<br>        jcenter()<br>    &#125;<br>    <span class="hljs-comment">// 此处先引入插件</span><br>    dependencies &#123;<br>        classpath(<span class="hljs-string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在应用插件</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'org.springframework.boot'</span> <span class="hljs-comment">//社区插件,需要事先引入，不必写版本号</span><br></code></pre></td></tr></table></figure>

<p>但是如果是第三方插件已经被托管在 <a href="https://plugins.gradle.org/" target="_blank" rel="noopener">https://plugins.gradle.org/</a> 网站上，就可以不用在 buildscript 里配置 classpath 依赖了，直接使用新出的 plugins DSL 的方式引用，案例如下：</p>
<p>使用 plugins DSL 方式</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">'org.springframework.boot'</span> version <span class="hljs-string">'2.4.1'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果使用老式插件方式 <code>buildscript{}</code> 要放在 <code>build.gradle</code> 文件的最前面，而新式 <code>plugins{}</code> 没有该限制。</li>
<li>托管在网站 gradle 插件官网的第三方插件有两种使用方式，一是传统的 buildscript 方式，一种是 plugins DSL 方式。</li>
</ol>
<p><strong>第二种3：对象插件之用户自定义插件</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingPluginExtension</span> &#123;</span><br>    Property&lt;String&gt; getMessage()<br>    Property&lt;String&gt; getGreeter()<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Plugin</span>&lt;<span class="hljs-title">Project</span>&gt; &#123;</span><br>    <span class="hljs-keyword">void</span> apply(Project project) &#123;<br>        <span class="hljs-keyword">def</span> extension = project.extensions.create(<span class="hljs-string">'greeting'</span>, GreetingPluginExtension)<br>        project.task(<span class="hljs-string">'hello'</span>) &#123;<br>            doLast &#123;<br>                println <span class="hljs-string">"$&#123;extension.message.get()&#125; from $&#123;extension.greeter.get()&#125;"</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>apply <span class="hljs-string">plugin:</span> GreetingPlugin<br><span class="hljs-comment">// Configure the extension using a DSL block</span><br>greeting &#123;<br>    message = <span class="hljs-string">'Hi'</span><br>    greeter = <span class="hljs-string">'Gradle'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">参考</a></p>
<p>我们直接执行 hello 任务 <code>./gradle hello</code> 即可，这种方式实现的插件我们一般不使用，因为这种方式局限性太强，只能本 Project，而其他的 Project 不能使用。</p>
<h3 id="3-6-4、buildSrc项目"><a href="#3-6-4、buildSrc项目" class="headerlink" title="3.6.4、buildSrc项目"></a>3.6.4、buildSrc项目</h3><p>buildSrc 是 Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，将其中的代码编译为插件。</p>
<ol>
<li>首先先建立一个名为 buildSrc 的 java Module，将 buildSrc 从 included modules 移除，重新构建，然后只保留 <code>build.gradle</code> 和 <code>src/main</code> 目录，其他全部删掉，注意名字一定是 buildSrc，不然会找不到插件。</li>
<li>然后修改 Gradle 中的内容<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'groovy'</span> <span class="hljs-comment">//必须</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'maven-publish'</span><br>dependencies &#123;<br>    implementation gradleApi() <span class="hljs-comment">//必须</span><br>    implementation localGroovy() <span class="hljs-comment">//必须</span><br>&#125;<br>repositories &#123;<br>    google()<br>    jcenter()<br>    mavenCentral() <span class="hljs-comment">//必须</span><br>&#125;<br><span class="hljs-comment">//把项目入口设置为src/main/groovy</span><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">'src/main/groovy'</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>创建入口目录，在 src&#x2F;main 下创建代码入口目录，如下：<br><img src="/img/java/gradle/1659395588766.png" srcset="/img/loading.gif" lazyload alt="1659395588766"></li>
<li>然后实现插件代码 Text.groovy，注意文件后缀为 groovy，文件要引入 package com.atguigu<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.atguigu<br><span class="hljs-keyword">import</span> org.gradle.api.Plugin<br><span class="hljs-keyword">import</span> org.gradle.api.Project<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Plugin</span>&lt;<span class="hljs-title">Project</span>&gt;&#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> apply(Project project) &#123;<br>        project.task(<span class="hljs-string">"atguigu"</span>)&#123;<br>            doLast&#123;<br>                println(<span class="hljs-string">"自定义atguigu插件"</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>接下来在 main 目录下创建 resources 目录，在 resources 目录下创建 META-INF 目录，在 META-INF 目录下创建 gradle-plugins 目录，在 gradle-plugins 目录下创建 properties 文件</li>
<li>properties 文件可以自己命名，但是要以.properties 结尾，比如 com.atguigu.plugin.properties，其 com.atguigu.plugin 就是定义的包名路径<br><img src="/img/java/gradle/1659395736601.png" srcset="/img/loading.gif" lazyload alt="1659395736601"></li>
<li>最后需要在 properties 文件中指明我们实现插件的全类名 <code>implementation-class=com.atguigu.Text</code><br><img src="/img/java/gradle/1659395759654.png" srcset="/img/loading.gif" lazyload alt="1659395759654"></li>
</ol>
<p>到目前为止我们的插件项目已经写完了，在 module 引入我们写的插件 <code>apply plugin:&#39;com.atguigu.plugin&#39;</code>，然后执行插件的Task，<code>./gradle atguigu</code></p>
<p>输出: <img src="/img/java/gradle/1659395802614.png" srcset="/img/loading.gif" lazyload alt="1659395802614"></p>
<p>这种形式的写法，在我们整个工程的 module 都可以使用，但也只是限制在本工程，其他工程不能使用。</p>
<p><strong>改进</strong>：第二种写插件的方式他只能在本工程中使用，而其他的项目工程不能使用，有时候我们需要一个插件在多个工程中使用，这时候我们就需要把插件上传 maven 中。</p>
<p>第一步: 首先将上述 buildSrc 目录复制一份，修改文件夹名，然后在 settings.gradle 文件中使用 include 引入</p>
<p>第二步：修改 build.gradle 文件，发布到 maven 仓库中</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'groovy'</span> <span class="hljs-comment">//必须</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'maven-publish'</span><br>dependencies &#123;<br>    implementation gradleApi() <span class="hljs-comment">//必须</span><br>    implementation localGroovy() <span class="hljs-comment">//必须</span><br>&#125;<br>repositories &#123;<br>    google()<br>    jcenter()<br>    mavenCentral() <span class="hljs-comment">//必须</span><br>&#125;<br>sourceSets &#123; <span class="hljs-comment">//把项目入口设置为src/main/groovy</span><br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">'src/main/groovy'</span><br>        &#125;<br>    &#125;<br>&#125;<br>publishing &#123;<br>    publications &#123;<br>        myLibrary(MavenPublication) &#123;<br>            groupId = <span class="hljs-string">'com.atguigu.plugin'</span> <span class="hljs-comment">//指定GAV坐标信息</span><br>            artifactId = <span class="hljs-string">'library'</span><br>            version = <span class="hljs-string">'1.1'</span><br>            from components.java<span class="hljs-comment">//发布jar包</span><br>            <span class="hljs-comment">//from components.web///引入war插件，发布war包</span><br>        &#125;<br>    &#125;<br>    repositories &#123;<br>        maven &#123; url <span class="hljs-string">"$rootDir/lib/release"</span> &#125;<br>        <span class="hljs-comment">//发布项目到私服中</span><br>        maven &#123;<br>            name = <span class="hljs-string">'myRepo'</span> <span class="hljs-comment">//name属性可选,表示仓库名称，url必填</span><br>            <span class="hljs-comment">//发布地址:可以是本地仓库或者maven私服</span><br>            <span class="hljs-comment">//url = layout.buildDirectory.dir("repo")</span><br>            <span class="hljs-comment">//url='http://my.org/repo'</span><br>            <span class="hljs-comment">// change URLs to point to your repos, e.g. http://my.org/repo</span><br>            <span class="hljs-comment">//认证信息:用户名和密码</span><br>            credentials &#123;<br>                username = <span class="hljs-string">'joe'</span><br>                password = <span class="hljs-string">'secret'</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第三步：执行 publish 指令，发布到根 project 或者 maven 私服仓库。</p>
<p>第四步：使用插件，在项目级 build.gradle 文件中将插件添加到 classpath：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        maven &#123; url <span class="hljs-string">"$rootDir/lib/release"</span> &#125;<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">"com.atguigu.plugin:library:1.1"</span><br>    &#125;<br>&#125;<br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span><br><span class="hljs-comment">//是在 atguiguplugin 中定义的插件 ID</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.atguigu.plugin'</span><br></code></pre></td></tr></table></figure>

<p>第五步：执行 gradle build 指令就会在控制台看到自定义插件的输出，说明自定义插件就已经生效了。</p>
<p>最后，至于如何写一个插件，能帮助项目更加自动化或者便捷化，是值得大家未来需要长期思考、关注、努力的点。</p>
<h3 id="3-6-5、插件的关注点"><a href="#3-6-5、插件的关注点" class="headerlink" title="3.6.5、插件的关注点"></a>3.6.5、插件的关注点</h3><p><strong>第一点: 插件的引用</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'插件名'</span><br></code></pre></td></tr></table></figure>

<p><strong>第二点: 主要的功能<code>[任务]</code></strong></p>
<p>当我们在工程中引入插件后，插件会自动的为我们的工程添加一些额外的任务来完成相应的功能。以 Java 插件为例，当我们加入 java 插件之后，就加入了如下功能：<br><img src="/img/java/gradle/1659396129145.png" srcset="/img/loading.gif" lazyload alt="1659396129145"></p>
<p>具体大家可通过 gradle tasks 查看加入某个插件前后的区别。</p>
<p>说明：Gradle 中的任务依赖关系是很重要的，它们之间的依赖关系就形成了构建的基本流程。</p>
<p><strong>第三点: 工程目录结构</strong></p>
<p>一些插件对工程目结构有约定，所以我们一般遵循它的约定结构来创建工程，这也是 Gradle 的“约定优于配置”原则。</p>
<p>例如 java 插件规定的项目源集目录结构如下所示：<br><img src="/img/java/gradle/1659396151826.png" srcset="/img/loading.gif" lazyload alt="1659396151826"></p>
<p>如果要使用某个插件就应该按照它约定的目录结构设置，这样能大大提高我们的效率，当然各目录结构也可以自己定义。</p>
<p><strong>第四点：依赖管理</strong></p>
<p>比如前面我们提到的 依赖的类型<code>[依赖管理]</code>部分，不同的插件提供了不同的依赖管理。</p>
<p><strong>第五点：常用的属性</strong></p>
<p>例如：Java 插件会为工程添加一些常用的属性，我们可以直接在编译脚本中直接使用。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reportsDirName</td>
<td>String</td>
<td>reports</td>
<td>生成报告的目录名称</td>
</tr>
<tr>
<td>reportsDir</td>
<td>File（只读）</td>
<td>buildDir&#x2F;reportsDirName</td>
<td>生成报告的目录</td>
</tr>
<tr>
<td>testResultsDirName</td>
<td>String</td>
<td>test-results</td>
<td>生成测试 <code>result.xml</code> 文件的目录名称</td>
</tr>
<tr>
<td>testResultsDir</td>
<td>File（只读）</td>
<td>reportsDir&#x2F;testReportDirName</td>
<td>生成测试报告的目录</td>
</tr>
<tr>
<td>libsDirName</td>
<td>String</td>
<td>libs</td>
<td>生成lib库的目录名称</td>
</tr>
<tr>
<td>libsDir</td>
<td>File（只读）</td>
<td>buildDir&#x2F;libsDirName</td>
<td>生成lib库的目录</td>
</tr>
<tr>
<td>distsDirName</td>
<td>String</td>
<td>distributions</td>
<td>生成发布文件的目录名称</td>
</tr>
<tr>
<td>distsDir</td>
<td>File（只读）</td>
<td>buildDir&#x2F;distsDirName</td>
<td>生成发布文件的目录</td>
</tr>
<tr>
<td>docsDirName</td>
<td>String</td>
<td>docs</td>
<td>生成帮助文档的目录名称</td>
</tr>
<tr>
<td>docsDir</td>
<td>File（只读）</td>
<td>buildDir&#x2F;docsDirName</td>
<td>生成帮助文档的目录</td>
</tr>
<tr>
<td>dependencyCacheDirName</td>
<td>String</td>
<td>dependency-cache</td>
<td>存储缓存资源依赖信息的目录名称</td>
</tr>
<tr>
<td>dependencyCacheDir</td>
<td>File（只读）</td>
<td>buildDir&#x2F;dependencyCacheDirName</td>
<td>存储缓存资源依赖信息的目录</td>
</tr>
</tbody></table>
<p>当然，这里还有一些其它属性</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sourceSets</td>
<td>SourceSetContainer (只读)</td>
<td>Not null</td>
<td>包含工程的资源集合（source sets.）</td>
</tr>
<tr>
<td>sourceCompatibility</td>
<td>JavaVersion，也可以使用字符串或数字，比如 ‘1.5’ 或者 1.5</td>
<td>根据使用的 JVM 定</td>
<td>编译 java 文件时指定使用的 java版本</td>
</tr>
<tr>
<td>targetCompatibility</td>
<td>JavaVersion，也可以使用字符串或数字，比如 ‘1.5’ 或者 1.5</td>
<td>sourceCompatibility</td>
<td>生成 classes 的 java 版本</td>
</tr>
<tr>
<td>archivesBaseName</td>
<td>String</td>
<td>projectName</td>
<td>作为归档文件的默认名称，如JAR 或者 ZIP 文件的名称</td>
</tr>
</tbody></table>
<h3 id="3-6-6、Java插件分析"><a href="#3-6-6、Java插件分析" class="headerlink" title="3.6.6、Java插件分析"></a>3.6.6、Java插件分析</h3><p><a href="https://docs.gradle.org/current/userguide/plugin_reference.html" target="_blank" rel="noopener">参考</a></p>
<p>以 Java 插件为例，讲解需要关注的几点：</p>
<p><strong>第一点：我们要关注插件使用</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">'java'</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第二点：我们要关注插件的功能</strong></p>
<p>我们可通过官方文档介绍了解某个插件功能或者百度、再或者大家可以通过 gradle tasks 查看加入 java 插件前后的区别。</p>
<p><strong>第三点：项目布局</strong></p>
<p>一般加入一个插件之后，插件也会提供相应的目录结构，例如：java 插件的目录结构<br><img src="/img/java/gradle/1659396557742.png" srcset="/img/loading.gif" lazyload alt="1659396557742"></p>
<p>当然这个默认的目录结构也是可以改动的例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    main &#123;<br>        java &#123;<br>            srcDirs = [<span class="hljs-string">'src/java'</span>]<br>        &#125;<br>        resources &#123;<br>            srcDirs = [<span class="hljs-string">'src/resources'</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可设置源集的属性等信息。</p>
<p><strong>第四点：依赖管理：以 java 插件为例，提供了很多依赖管理项</strong><br><img src="/img/java/gradle/1659396629778.png" srcset="/img/loading.gif" lazyload alt="1659396629778"><br><img src="/img/java/gradle/1659396643990.png" srcset="/img/loading.gif" lazyload alt="1659396643990"></p>
<p><strong>第五点：额外的属性和方法</strong></p>
<h2 id="3-7、build-gradle-文件"><a href="#3-7、build-gradle-文件" class="headerlink" title="3.7、build.gradle 文件"></a>3.7、build.gradle 文件</h2><ul>
<li>build.gradle 是一个 gradle 的构建脚本文件，支持 java、groovy 等语言。</li>
<li>每个 project 都会有一个 build.gradle 文件，该文件是项目构建的入口，可配置版本、插件、依赖库等信息。</li>
<li>每个 build 文件都有一个对应的 Project 实例，对 build.gradle 文件配置，本质就是设置 Project 实例的属性和方法。</li>
<li>由于每个 project 都会有一个 build 文件，那么 Root Project 也不列外。Root Project 可以获取到所有 Child Project，所以在 Root Project 的 build 文件中我们可以对 Child Project 统一配置，比如应用的插件、依赖的 maven 中心仓库等。</li>
<li>build 文件中常见的属性和方法如下所示：<br><img src="/img/java/gradle/1659396785539.png" srcset="/img/loading.gif" lazyload alt="1659396785539"></li>
</ul>
<h3 id="3-7-1、常见属性代码"><a href="#3-7-1、常见属性代码" class="headerlink" title="3.7.1、常见属性代码"></a>3.7.1、常见属性代码</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//指定使用什么版本的JDK语法编译源代码,跟编译环境有关,在有java插件时才能用</span><br>sourceCompatibility = <span class="hljs-number">1.8</span><br><span class="hljs-comment">//指定生成特定于某个JDK版本的class文件:跟运行环境有关,在有java插件时才能用</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><span class="hljs-comment">//业务编码字符集,注意这是指定源码解码的字符集[编译器]</span><br>compileJava.options.encoding <span class="hljs-string">"UTF-8"</span><br><span class="hljs-comment">//测试编码字符集,注意这是指定源码解码的字符集[编译器]</span><br>compileTestJava.options.encoding <span class="hljs-string">"UTF-8"</span><br><span class="hljs-comment">//编译JAVA文件时采用UTF-8:注意这是指定源码编码的字符集【源文件】</span><br>tasks.withType(JavaCompile) &#123;<br>    options.encoding = <span class="hljs-string">"UTF-8"</span><br>&#125;<br><span class="hljs-comment">//编译JAVA文件时采用UTF-8:注意这是指定文档编码的字符集【源文件】</span><br>tasks.withType(Javadoc) &#123;<br>    options.encoding = <span class="hljs-string">"UTF-8"</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>提示 1：group+name+version 类似于 maven 的 group+artifactId+version</li>
<li>提示 2：encoding 解决业务代码与测试代码中文乱码问题</li>
</ul>
<h3 id="3-7-2、Repositories"><a href="#3-7-2、Repositories" class="headerlink" title="3.7.2、Repositories"></a>3.7.2、Repositories</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>    <span class="hljs-comment">//gradle中会按着仓库配置的顺序，从上往下依次去对应的仓库中找所需要的jar包:</span><br>    <span class="hljs-comment">//如果找到，则停止向下搜索，如果找不到，继续在下面的仓库中查找</span><br>    <span class="hljs-comment">//指定去本地某个磁盘目录中查找:使用本地file文件协议:一般不用这种方式</span><br>    maven &#123; url <span class="hljs-string">'file:///D:/repos/mavenrepos3.5.4'</span>&#125;<br>    maven &#123; url <span class="hljs-string">"$rootDir/lib/release"</span> &#125;<br>    <span class="hljs-comment">//指定去maven的本地仓库查找</span><br>    mavenLocal()<br>    <span class="hljs-comment">//指定去maven的私服或者第三方镜像仓库查找</span><br>    maven &#123; name <span class="hljs-string">"Alibaba"</span> ; url <span class="hljs-string">"https://maven.aliyun.com/repository/public"</span> &#125;<br>    maven &#123; name <span class="hljs-string">"Bstek"</span> ; url <span class="hljs-string">"https://nexus.bsdn.org/content/groups/public/"</span> &#125;<br>    <span class="hljs-comment">//指定去maven的远程仓库查找:即 https://repo.maven.apache.org/maven2/</span><br>    mavenCentral()<br>    <span class="hljs-comment">//去google仓库查找</span><br>    google()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为 Gradle 没有自己的远程仓库，而是使用 Maven、jcenter、jvy、google 这些远程仓库。</p>
<h3 id="3-7-3、Subprojects与Allprojects"><a href="#3-7-3、Subprojects与Allprojects" class="headerlink" title="3.7.3、Subprojects与Allprojects"></a>3.7.3、Subprojects与Allprojects</h3><p>allprojects 是对所有 project(包括 Root Project + child Project<code>[当前工程和所有子工程]</code>)的进行统一配置，而 subprojects 是对所有 Child Project 的进行统一配置。</p>
<p>测试如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    tasks.create(<span class="hljs-string">'hello'</span>) &#123;<br>        doLast &#123;<br>            task -&gt;<br>                println <span class="hljs-string">"project name is $task.project.name"</span><br>        &#125;<br>    &#125;<br>&#125;<br>subprojects &#123;<br>    hello.doLast&#123;<br>        task-&gt;<br>            println <span class="hljs-string">"here is subprojects $task.project.name"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通常在 subprojects 和 allprojects 中:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects()&#123; <span class="hljs-comment">//本质Project中的allprojects方法，传递一个闭包作为参数。</span><br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span><br>    ext &#123;<br>        junitVersion = <span class="hljs-string">'4.10'</span><br>        ...<br>    &#125;<br>    task allTask&#123;<br>        ...<br>    &#125;<br>    repositories &#123;<br>        ...<br>    &#125;<br>    dependencies &#123;<br>        ...<br>    &#125;<br>&#125;<br>subprojects()&#123;<br>    ...<span class="hljs-comment">//同上面allprojects中的方法。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>拓展 1: 如果是直接在根 project 配置 repositories 和 dependencies 则只针对根工程有效。<br>拓展 2: 我们也可以在对单个 Project 进行单独配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">project(<span class="hljs-string">'subject01'</span>) &#123;<br>    task subject01 &#123;<br>        doLast &#123;<br>            println <span class="hljs-string">'for subject01'</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行 gradle build 指令即可查看测试效果。</p>
<h3 id="3-7-4、ext用户自定义属性"><a href="#3-7-4、ext用户自定义属性" class="headerlink" title="3.7.4、ext用户自定义属性"></a>3.7.4、ext用户自定义属性</h3><p>Project 和 Task 都允许用户添加额外的自定义属性，要添加额外的属性，通过应用所属对象的 ext 属性即可实现。添加之后可以通过 ext 属性对自定义属性读取和设置，如果要同时添加多个自定义属性，可以通过 ext 代码块:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//自定义一个Project的属性</span><br>ext.age = <span class="hljs-number">18</span><br><span class="hljs-comment">//通过代码块同时自定义多个属性</span><br>ext &#123;<br>    phone = <span class="hljs-number">19292883833</span><br>    address=<span class="hljs-string">"北京尚硅谷"</span><br>&#125;<br>task extCustomProperty &#123;<br>    <span class="hljs-comment">//在task中自定义属性</span><br>    ext &#123;<br>        desc = <span class="hljs-string">"奥利给"</span><br>    &#125;<br>    doLast &#123;<br>        println <span class="hljs-string">"年龄是：$&#123;age&#125;"</span><br>        println <span class="hljs-string">"电话是：$&#123;phone&#125;"</span><br>        println <span class="hljs-string">"地址是：$&#123;address&#125;"</span><br>        println <span class="hljs-string">"尚硅谷：$&#123;desc&#125;"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：通过 gradle extCustomProperty</p>
<p>输出结果为：<img src="/img/java/gradle/1659401087573.png" srcset="/img/loading.gif" lazyload alt="1659401087573"></p>
<p>拓展 1: ext 配置的是用户自定义属性，而 gradle.properties 中一般定义 系统属性、环境变量、项目属性、JVM 相关配置信息。例如 gradle.properties 文件案例：加快构建速度的，gradle.properties 文件中的属性会自动在项目运行时加载。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">## 设置此参数主要是编译下载包会占用大量的内存，可能会内存溢出</span><br><span class="hljs-meta">org.gradle.jvmargs</span>=<span class="hljs-string">-Xms4096m -Xmx8192m</span><br><span class="hljs-comment">## 开启gradle缓存</span><br><span class="hljs-meta">org.gradle.caching</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#开启并行编译</span><br><span class="hljs-meta">org.gradle.parallel</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#启用新的孵化模式</span><br><span class="hljs-meta">org.gradle.configureondemand</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#开启守护进程</span><br><span class="hljs-meta">org.gradle.daemon</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<p><a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties" target="_blank" rel="noopener">参考</a></p>
<h3 id="3-7-5、Buildscript"><a href="#3-7-5、Buildscript" class="headerlink" title="3.7.5、Buildscript"></a>3.7.5、Buildscript</h3><p>buildscript 里是 gradle 脚本执行所需依赖，分别是对应的 maven 库和插件。</p>
<p>案例如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64<br>buildscript &#123;<br>    repositories &#123;<br>        mavenCentral()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">group:</span> <span class="hljs-string">'commons-codec'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'commons-codec'</span>, <span class="hljs-string">version:</span> <span class="hljs-string">'1.2'</span><br>    &#125;<br>&#125;<br>tasks.register(<span class="hljs-string">'encode'</span>) &#123;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> <span class="hljs-keyword">byte</span>[] encodedString = <span class="hljs-keyword">new</span> Base64().encode(<span class="hljs-string">'hello world\n'</span>.getBytes())<br>        println <span class="hljs-keyword">new</span> String(encodedString)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<ol>
<li><code>buildscript{}</code> 必须在 build.gradle 文件的最前端。</li>
<li>对于多项目构建，项目的 buildscript ()方法声明的依赖关系可用于其所有子项目的构建脚本。</li>
<li>构建脚本依赖可能是 Gradle 插件。</li>
</ol>
<p>案例如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//老式apply插件的引用方式,使用apply+buildscript</span><br>buildscript &#123;<br>    ext &#123;<br>        springBootVersion = <span class="hljs-string">"2.3.3.RELEASE"</span><br>    &#125;<br>    repositories &#123;<br>        mavenLocal()<br>        maven &#123; url <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;<br>        jcenter()<br>    &#125;<br>    <span class="hljs-comment">//此处引入插件</span><br>    dependencies &#123;<br>        classpath(<span class="hljs-string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)<br>    &#125;<br>&#125;<br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span> <span class="hljs-comment">//核心插件，无需事先引入</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'org.springframework.boot'</span> <span class="hljs-comment">//社区插件，需要事先引入,才能应用，不必写版本号</span><br></code></pre></td></tr></table></figure>


<h2 id="3-8、publishing-项目发布"><a href="#3-8、publishing-项目发布" class="headerlink" title="3.8、publishing 项目发布"></a>3.8、publishing 项目发布</h2><p>接下来，将咱们写好的模块发布发布到公司的私服以供别人使用，如下所示：</p>
<p><img src="/img/java/gradle/1659401299586.png" srcset="/img/loading.gif" lazyload alt="1659401299586"></p>
<h3 id="3-8-1、引入maven发布的插件"><a href="#3-8-1、引入maven发布的插件" class="headerlink" title="3.8.1、引入maven发布的插件"></a>3.8.1、引入maven发布的插件</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">'java-library'</span> <span class="hljs-comment">//如果发布war包，需要war插件,java-library支持带源码、文档发布</span><br>    id <span class="hljs-string">'maven-publish'</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-8-2、设置发布代码"><a href="#3-8-2、设置发布代码" class="headerlink" title="3.8.2、设置发布代码"></a>3.8.2、设置发布代码</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//带源码和javadoc的发布:需要'java-library'插件支持:它是java的升级版，java插件的功能java-library都有</span><br><span class="hljs-comment">//javadoc.options.encoding="UTF-8"</span><br><span class="hljs-comment">//java &#123;</span><br>    <span class="hljs-comment">// withJavadocJar()</span><br>    <span class="hljs-comment">// withSourcesJar()</span><br><span class="hljs-comment">//&#125;</span><br>publishing &#123;<br>    publications &#123;<br>        myLibrary(MavenPublication) &#123;<br>            groupId = <span class="hljs-string">'org.gradle.sample'</span> <span class="hljs-comment">//指定GAV坐标信息</span><br>            artifactId = <span class="hljs-string">'library'</span><br>            version = <span class="hljs-string">'1.1'</span><br>            from components.java<span class="hljs-comment">//发布jar包</span><br>            <span class="hljs-comment">//from components.web///引入war插件，发布war包</span><br>        &#125;<br>    &#125;<br>    repositories &#123;<br>        <span class="hljs-comment">//本地仓库位于USER_HOME/.m2/repository</span><br>        mavenLocal()<br>        <span class="hljs-comment">//发布项目到私服中</span><br>        maven &#123;<br>            name = <span class="hljs-string">'myRepo'</span> <span class="hljs-comment">//name属性可选,表示仓库名称，url必填</span><br>            <span class="hljs-comment">//发布地址:可以是本地仓库或者maven私服</span><br>            <span class="hljs-comment">//url = layout.buildDirectory.dir("repo")</span><br>            <span class="hljs-comment">// change URLs to point to your repos, e.g. http://my.org/repo</span><br>            <span class="hljs-keyword">def</span> releasesRepoUrl = layout.buildDirectory.dir(<span class="hljs-string">'repos/releases'</span>)<br>            <span class="hljs-keyword">def</span> snapshotsRepoUrl = layout.buildDirectory.dir(<span class="hljs-string">'repos/snapshots'</span>)<br>            url = version.endsWith(<span class="hljs-string">'SNAPSHOT'</span>) ? snapshotsRepoUrl : releasesRepoUrl<br>            <span class="hljs-comment">//认证信息:用户名和密码</span><br>            <span class="hljs-comment">// credentials &#123;</span><br>                <span class="hljs-comment">// username = 'joe'</span><br>                <span class="hljs-comment">// password = 'secret'</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-8-3、执行发布指令"><a href="#3-8-3、执行发布指令" class="headerlink" title="3.8.3、执行发布指令"></a>3.8.3、执行发布指令</h3><p>执行发布命令，将项目发布到本地仓库或者远程仓库。常见的发布指令有：</p>
<ul>
<li><code>generatePomFileForPubNamePublication</code>: 生成 pom 文件</li>
<li><code>publishPubNamePublicationToRepoNameRepository</code>: 发布项目到指定仓库，如果没有仓库名，默认为 maven</li>
<li><code>publishPubNamePublicationToMavenLocal</code>: 将 PubName 发布复制到本地 Maven 仓库中包括 POM 文件和其他元数据。</li>
<li><code>publish</code>: 发布到 repositories 中指定的仓库(为比如 Maven 私服)</li>
<li><code>publishToMavenLocal</code>: 执行所有发布任务中的操作发布到本地 maven 仓库【默认在用户家目录下的.m2&#x2F;repository】。</li>
</ul>
<h2 id="3-9、生命周期中Hook"><a href="#3-9、生命周期中Hook" class="headerlink" title="3.9、生命周期中Hook"></a>3.9、生命周期中Hook</h2><p>生命周期中的这些钩子函数都是由 gradle 自动回调完成的，利用这些钩子函数可以帮助我们实现一些我们想要的功能。<br><img src="/img/java/gradle/1659401526234.png" srcset="/img/loading.gif" lazyload alt="1659401526234"></p>
<p>Gradle 在生命周期各个阶段都提供了用于回调的钩子函数:</p>
<p><strong>Gradle 初始化阶段</strong>:</p>
<ul>
<li>在 settings.gradle 执行完后，会回调 Gradle 对象的 settingsEvaluated 方法</li>
<li>在构建所有工程 build.gradle 对应的 Project 对象后，也既初始化阶段完毕，会回调 Gradle 对象的 projectsLoaded 方法</li>
</ul>
<p><strong>Gradle 配置阶段</strong>:</p>
<ul>
<li>Gradle 会循环执行每个工程的 build.gradle 脚本文件</li>
<li>在执行当前工程 build.gradle 前，会回调 Gradle 对象的 beforeProject 方法和当前 Project 对象的 beforeEvaluate 方法，虽然 beforeEvalute 属于 project 的生命周期， 但是此时 build script 尚未被加载， 所以 beforeEvaluate 的设置依然要在 init script 或 setting script 中进行，不要在 build script 中使用 project.beforeEvaluate 方法。</li>
<li>在执行当前工程 build.gradle 后，会回调 Gradle 对象的 afterProject 方法和当前 Project 对象的 afterEvaluate 方法</li>
<li>在所有工程的 build.gradle 执行完毕后，会回调 Gradle 对象的 projectsEvaluated 方法</li>
<li>在构建 Task 依赖有向无环图后，也就是配置阶段完毕，会回调 TaskExecutionGraph 对象的 whenReady 方法</li>
</ul>
<p><strong>Gradle 执行阶段</strong>:</p>
<ul>
<li>Gradle 会循环执行 Task 及其依赖的 Task</li>
<li>在当前 Task 执行之前，会回调 TaskExecutionGraph 对象的 beforeTask 方法</li>
<li>在当前 Task 执行之后，会回调 TaskExecutionGraph 对象的 afterTask 方法</li>
</ul>
<p>当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法。</p>
<p>提示：Gradle 执行脚本文件的时候会生成对应的实例，主要有如下几种对象：</p>
<ol>
<li>Gradle 对象：在项目初始化时构建，全局单例存在，只有这一个对象</li>
<li>Project 对象：每一个build.gradle文件 都会转换成一个 Project 对象，类似于maven中的pom.xml文件</li>
<li>Settings 对象：settings.gradle 会转变成一个 settings 对象，和整个项目是一对一的关系，一般只用到include方法</li>
<li>Task对象：从前面的有向无环图中，我们也可以看出，gradle最终是基于Task的，一个项目可以有一个或者多个Task</li>
</ol>
<p>钩子函数代码演示：项目目录结构如下：<br><img src="/img/java/gradle/1659401846479.png" srcset="/img/loading.gif" lazyload alt="1659401846479"></p>
<p>在 root project 的 settings.gradle 文件中添加：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs groovy">gradle.settingsEvaluated &#123; <span class="hljs-comment">//1.settingsEvaluated钩子函数,在初始化阶段完成</span><br>    println <span class="hljs-string">"settingsEvaluated"</span><br>&#125;<br>gradle.projectsLoaded &#123; <span class="hljs-comment">//2.projectsLoaded钩子函数,在初始化阶段完成</span><br>    println <span class="hljs-string">"projectsLoaded"</span><br>&#125;<br><span class="hljs-comment">//声明一个变量：表示当前项目名,在每次执行某个项目的beforeEvaluate方法时先给projectName变量赋值</span><br><span class="hljs-comment">//这样方便在：gradle.beforeProject和afterProject两个钩子函数使用。</span><br><span class="hljs-keyword">def</span> projectName=<span class="hljs-string">""</span><br>gradle.addProjectEvaluationListener( <span class="hljs-keyword">new</span> ProjectEvaluationListener()&#123;<br>    <span class="hljs-comment">//3.执行各个project的beforeEvaluate：在配置阶段完成</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> beforeEvaluate(Project project) &#123;<br>        projectName=project.name<br>        println <span class="hljs-string">"$&#123;project.name&#125; Project beforeEvaluate"</span><br>    &#125;<br>    <span class="hljs-comment">//5.执行各个project的afterEvaluate：在配置阶段完成</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> afterEvaluate(Project project, ProjectState projectState) &#123;<br>        println <span class="hljs-string">"$&#123;project.name&#125; Project afterEvaluate"</span><br>    &#125;<br>&#125;);<br>gradle.beforeProject &#123;<span class="hljs-comment">//4.执行各个project的beforeProject：在配置阶段完成</span><br>    println <span class="hljs-string">"$&#123;projectName&#125; beforeProject..."</span><br>&#125;<br>gradle.afterProject &#123;<span class="hljs-comment">//6.执行各个project的afterProject：在配置阶段完成</span><br>    println <span class="hljs-string">"$&#123;projectName&#125; afterProject..."</span><br>&#125;<br><span class="hljs-comment">//7.所有工程的 build.gradle 执行完毕后，回调 Gradle 对象的 projectsEvaluated 方法：在配置阶段完成</span><br><span class="hljs-keyword">def</span> rootProjectName=rootProject.getName()<br>gradle.projectsEvaluated &#123;<br>    println <span class="hljs-string">"$&#123;rootProjectName&#125; projectsEvaluated..."</span><br>&#125;<br><span class="hljs-comment">//8.配置阶段完毕后，回调 TaskExecutionGraph 对象的 whenReady 方法：在配置阶段完成</span><br>gradle.taskGraph.whenReady &#123;<br>    println <span class="hljs-string">"$&#123;rootProjectName&#125; taskGraph whenReady..."</span><br>&#125;<br><span class="hljs-comment">//9.在当前Task执行之前,会回调 TaskExecutionGraph 对象的 beforeTask方法：在执行阶段完成</span><br>gradle.taskGraph.beforeTask &#123;task -&gt;<br>    println <span class="hljs-string">"this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; beforeTask.."</span><br>&#125;<br><span class="hljs-comment">//10.在当前Task执行之后,会回调 TaskExecutionGraph 对象的 afterTask方法：在执行阶段完成</span><br>gradle.taskGraph.afterTask &#123;task -&gt;<br>    println <span class="hljs-string">"this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; afterTask.."</span><br>&#125;<br><span class="hljs-comment">//11.当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法：在执行阶段完成</span><br>gradle.buildFinished &#123;<br>    println <span class="hljs-string">"$&#123;rootProjectName&#125; buildFinished..."</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 root 的 build.gradle 文件中添加:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task A &#123;<br>    println <span class="hljs-string">"root taskA"</span><br>    doFirst()&#123;<br>        println <span class="hljs-string">"root taskA doFirst"</span><br>    &#125;<br>    doLast()&#123;<br>        println <span class="hljs-string">"root taskA doLast"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 subject01 的 build.gradle 文件中添加:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task B &#123;<br>    println <span class="hljs-string">"SubProject01 taskB"</span><br>    doFirst()&#123;<br>        println <span class="hljs-string">"SubProject01 taskB doFirst"</span><br>    &#125;<br>    doLast()&#123;<br>        println <span class="hljs-string">"SubProject01 taskB doLast"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 subject02 的 build.gradle 文件中添加:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//task C在上面</span><br>task C&#123;<br>    <span class="hljs-comment">//依赖task D</span><br>    dependsOn <span class="hljs-string">'D'</span><br>    println <span class="hljs-string">"SubProject02 taskC"</span><br>    doFirst()&#123;<br>        println <span class="hljs-string">"SubProject02 taskC doFirst"</span><br>    &#125;<br>    doLast()&#123;<br>        println <span class="hljs-string">"SubProject02 taskC doLast"</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//task D在下面</span><br>task D &#123;<br>    println <span class="hljs-string">"SubProject02 taskD"</span><br>    doFirst()&#123;<br>        println <span class="hljs-string">"SubProject02 taskD doFirst"</span><br>    &#125;<br>    doLast()&#123;<br>        println <span class="hljs-string">"SubProject02 taskD doLast"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：在 root 工程的根目录执行：gradle C .就能看到 gradle 生命周期的三个阶段，及每个阶段执行的钩子函数、还有在执行阶段有依赖关系的任务的执行顺序问题。</p>
<p>拓展 1：在 settings.gradle 中添加监听器，查看 task 有向无环图:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">gradle.taskGraph.addTaskExecutionGraphListener(<span class="hljs-keyword">new</span> TaskExecutionGraphListener() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//生成有向无环图</span><br>    <span class="hljs-keyword">void</span> graphPopulated(TaskExecutionGraph taskExecutionGraph) &#123;<br>        taskExecutionGraph.allTasks.forEach(task-&gt;&#123;<span class="hljs-comment">//核心逻辑:通过taskExecutionGraph获得所有的task</span><br>            taskExecutionGraph.allTasks.forEach(releaseTask-&gt;&#123;<br>                println <span class="hljs-string">"尚硅谷:"</span> + releaseTask.getProject().name + <span class="hljs-string">":"</span> + releaseTask.name<br>            &#125;)<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>测试：在 root 工程根目录下执行：gradle C。查看测试结果：</p>
<p><img src="/img/java/gradle/1659402304907.png" srcset="/img/loading.gif" lazyload alt="1659402304907"></p>
<p>拓展 2: 计算 Gradle 构建过程中各个阶段的耗时:需要注意，这里只是计算了初始化阶段的 settings 文件，并没有计算 init.gradle 初始化的时间。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> projectName=rootProject.getName() <span class="hljs-comment">//定义项目名</span><br><span class="hljs-keyword">long</span> beginOfSetting = System.currentTimeMillis() <span class="hljs-comment">//初始化阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfConfig <span class="hljs-comment">//配置阶段开始时间</span><br><span class="hljs-keyword">def</span> configHasBegin = <span class="hljs-literal">false</span> <span class="hljs-comment">//配置阶段是否开始了，只执行一次</span><br><span class="hljs-keyword">def</span> beginOfProjectConfig = <span class="hljs-keyword">new</span> HashMap() <span class="hljs-comment">//存放每个 build.gradle执行之前的时间</span><br><span class="hljs-keyword">def</span> beginOfTaskExecute <span class="hljs-comment">//执行阶段开始时间</span><br>gradle.projectsLoaded &#123; <span class="hljs-comment">//初始化阶段执行完毕</span><br>    println <span class="hljs-string">"$&#123;projectName&#125;工程 初始化总耗时 $&#123;System.currentTimeMillis() *   beginOfSetting&#125; ms"</span><br>&#125;<br><span class="hljs-comment">//build.gradle执行前</span><br>gradle.beforeProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">if</span>(!configHasBegin)&#123;<br>        configHasBegin = <span class="hljs-literal">true</span><br>        beginOfConfig = System.currentTimeMillis()<br>    &#125;<br>    beginOfProjectConfig.put(project,System.currentTimeMillis())<br>&#125;<br><span class="hljs-comment">//build.gradle执行后</span><br>gradle.afterProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">def</span> begin = beginOfProjectConfig.get(project)<br>    <span class="hljs-keyword">if</span>(project.name == projectName) &#123;<br>        println <span class="hljs-string">"根工程$&#123;projectName&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() *   begin&#125; ms"</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        println <span class="hljs-string">"子工程$&#123;project.name&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() *   begin&#125; ms"</span><br>    &#125;<br>&#125;<br>gradle.taskGraph.whenReady &#123;<span class="hljs-comment">//配置阶段完毕</span><br>    println <span class="hljs-string">"整个$&#123;projectName&#125;项目在配置阶段总耗时：$&#123;System.currentTimeMillis() *   beginOfConfig&#125; ms"</span><br>    beginOfTaskExecute = System.currentTimeMillis()<br>&#125;<br><span class="hljs-comment">//执行阶段开始</span><br>gradle.taskGraph.beforeTask &#123;Task task -&gt;<br>    task.doFirst &#123;<br>        task.ext.beginOfTask = System.currentTimeMillis()<br>    &#125;<br>    task.doLast &#123;<br>        println <span class="hljs-string">"$&#123;task.name&#125;在执行阶段耗时：$&#123;System.currentTimeMillis() *   task.ext.beginOfTask&#125; ms"</span><br>    &#125;<br>&#125;<br>gradle.buildFinished &#123;<span class="hljs-comment">//执行阶段完毕</span><br>    println <span class="hljs-string">" 执行阶段总耗时：$&#123;System.currentTimeMillis() *   beginOfTaskExecute&#125; ms"</span><br>    println <span class="hljs-string">" 整个构建过程耗时：$&#123;System.currentTimeMillis() *   beginOfSetting&#125; ms"</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="3-10、创建Springboot项目"><a href="#3-10、创建Springboot项目" class="headerlink" title="3.10、创建Springboot项目"></a>3.10、创建Springboot项目</h2><p>Spring Boot Gradle 插件在 Gradle 提供 Spring Boot 支持。它允许您打包可执行 jar 或 war 归档文件，运行 Spring Boot 应用程序，并使用 Spring-Boot-dependencies 提供的依赖管理。 <a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#running-your-application" target="_blank" rel="noopener">参考</a></p>
<h3 id="3-10-1、引入springboot插件"><a href="#3-10-1、引入springboot插件" class="headerlink" title="3.10.1、引入springboot插件"></a>3.10.1、引入springboot插件</h3><p>该插件发布在 Gradle 的插件门户网站上，可以使用插件块来应用:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">'org.springframework.boot'</span> version <span class="hljs-string">'2.3.7.RELEASE'</span> <span class="hljs-comment">//维护springboot版本号,不单独使用,和下面两个插件一起用</span><br>    id <span class="hljs-string">'io.spring.dependency-management'</span> version <span class="hljs-string">'1.0.10.RELEASE'</span> <span class="hljs-comment">//进行依赖管理,在引入其它boot依赖时省略版本号、解决jar包冲突问题</span><br>    id <span class="hljs-string">'java'</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-10-2、引入所需要的依赖"><a href="#3-10-2、引入所需要的依赖" class="headerlink" title="3.10.2、引入所需要的依赖"></a>3.10.2、引入所需要的依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter'</span><br>    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span> <span class="hljs-comment">//省略版本,原生bom支持,插件management提供</span><br>    testImplementation(<span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;<br>        exclude <span class="hljs-string">group:</span> <span class="hljs-string">'org.junit.vintage'</span>, <span class="hljs-string">module:</span> <span class="hljs-string">'junit-vintage-engine'</span><br>    &#125;<br>&#125;<br>test &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-10-3、执行gradle-bootRun指令"><a href="#3-10-3、执行gradle-bootRun指令" class="headerlink" title="3.10.3、执行gradle bootRun指令"></a>3.10.3、执行gradle bootRun指令</h3><p>要想运行当前 Springboot 项目，直接执行 gradle bootRun 指令或者 idea 右侧按钮即可。</p>
<p>当然如果想让当前项目打成可执行 jar 包，只需执行： gradle bootJar 指令即可。</p>
<p>Cloud 项目创建也可以借助于脚手架创建，与 Boot 项目类似。</p>
<h3 id="3-10-4、拓展spring-boot-gradle-plugin插件"><a href="#3-10-4、拓展spring-boot-gradle-plugin插件" class="headerlink" title="3.10.4、拓展spring-boot-gradle-plugin插件"></a>3.10.4、拓展spring-boot-gradle-plugin插件</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        maven &#123; url <span class="hljs-string">'https://maven.aliyun.com/repository/public'</span> &#125;<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">'org.springframework.boot:spring-boot-gradle-plugin:2.4.1'</span><br>    &#125;<br>&#125;<br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'org.springframework.boot'</span><br>apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'io.spring.dependency-management'</span><br></code></pre></td></tr></table></figure>


<h2 id="3-11、基于ssm多模块项目案例"><a href="#3-11、基于ssm多模块项目案例" class="headerlink" title="3.11、基于ssm多模块项目案例"></a>3.11、基于ssm多模块项目案例</h2><h3 id="3-11-1、多项目模块划分"><a href="#3-11-1、多项目模块划分" class="headerlink" title="3.11.1、多项目模块划分"></a>3.11.1、多项目模块划分</h3><p><img src="/img/java/gradle/1659402835865.png" srcset="/img/loading.gif" lazyload alt="1659402835865"></p>
<ul>
<li>meinian-mobile-web: 美年旅游项目的用户系统</li>
<li>meinian-web: 美年旅游项目的管理员系统</li>
<li>meinian-service: 美年旅游项目的业务逻辑层</li>
<li>meinian-dao: 美年旅游项目的持久化层</li>
<li>meinian-bean: 美年旅游项目的 Model 封装</li>
</ul>
<h3 id="3-11-2、项目搭建前配置分析"><a href="#3-11-2、项目搭建前配置分析" class="headerlink" title="3.11.2、项目搭建前配置分析"></a>3.11.2、项目搭建前配置分析</h3><p><img src="/img/java/gradle/1659402862160.png" srcset="/img/loading.gif" lazyload alt="1659402862160"></p>
<h3 id="3-11-3、代码演示"><a href="#3-11-3、代码演示" class="headerlink" title="3.11.3、代码演示"></a>3.11.3、代码演示</h3><p>代码和配置文件同单体 ssm 一样。只不过做了拆分。</p>
<h3 id="3-11-4、settings-gradle文件中"><a href="#3-11-4、settings-gradle文件中" class="headerlink" title="3.11.4、settings.gradle文件中"></a>3.11.4、settings.gradle文件中</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">rootProject.name = <span class="hljs-string">'meinian-parent'</span><br>include <span class="hljs-string">'meinian-bean'</span><br>include <span class="hljs-string">'meinian-dao'</span><br>include <span class="hljs-string">'meinian-service'</span><br>include <span class="hljs-string">'meinian-web'</span><br>include <span class="hljs-string">'meinian-mobile-web'</span><br></code></pre></td></tr></table></figure>


<h3 id="3-11-5、在根工程build-gradle文件中抽取子模块的公共配置"><a href="#3-11-5、在根工程build-gradle文件中抽取子模块的公共配置" class="headerlink" title="3.11.5、在根工程build.gradle文件中抽取子模块的公共配置"></a>3.11.5、在根工程build.gradle文件中抽取子模块的公共配置</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs groovy">group <span class="hljs-string">'com.atguigu'</span><br>version <span class="hljs-string">'1.0-SNAPSHOT'</span><br>subprojects &#123;<br>    <span class="hljs-comment">//添加插件</span><br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span><br>    <span class="hljs-comment">//基本JDK配置</span><br>    sourceCompatibility = <span class="hljs-number">1.8</span><br>    targetCompatibility = <span class="hljs-number">1.8</span><br>    compileJava.options.encoding <span class="hljs-string">"UTF-8"</span><br>    compileTestJava.options.encoding <span class="hljs-string">"UTF-8"</span><br>    tasks.withType(JavaCompile) &#123;<br>        options.encoding = <span class="hljs-string">"UTF-8"</span><br>    &#125;<br>    group <span class="hljs-string">'com.atguigu'</span><br>    version <span class="hljs-string">'1.0-SNAPSHOT'</span><br>    repositories &#123;<br>        mavenLocal()<br>        maven &#123;url <span class="hljs-string">"https://maven.aliyun.com/repository/public"</span>&#125;<br>        maven &#123;url <span class="hljs-string">"https://maven.aliyun.com/repository/central"</span>&#125;<br>        maven &#123;url <span class="hljs-string">"https://maven.aliyun.com/repository/google"</span>&#125;<br>        maven &#123;url <span class="hljs-string">"https://maven.aliyun.com/repository/spring"</span>&#125;<br>        mavenCentral()<br>    &#125;<br>    <span class="hljs-comment">//依赖的配置:设置通用的依赖</span><br>    dependencies &#123;<br>        testImplementation <span class="hljs-string">'org.junit.jupiter:junit-jupiter-api'</span><br>        testRuntimeOnly <span class="hljs-string">'org.junit.jupiter:junit-jupiter-engine'</span><br>        implementation <span class="hljs-string">'log4j:log4j:1.2.17'</span><br>    &#125;<br>    test &#123;<br>        useJUnitPlatform()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-11-6、在根工程的build-gradle文件中配置各个模块的依赖信息"><a href="#3-11-6、在根工程的build-gradle文件中配置各个模块的依赖信息" class="headerlink" title="3.11.6、在根工程的build.gradle文件中配置各个模块的依赖信息"></a>3.11.6、在根工程的build.gradle文件中配置各个模块的依赖信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs groovy">project(<span class="hljs-string">"meinian-bean"</span>)&#123;<br>    dependencies &#123;<br>        compileOnly <span class="hljs-string">'org.projectlombok:lombok:1.18.24'</span><br>    &#125;<br>&#125;<br>project(<span class="hljs-string">"meinian-dao"</span>)&#123;<br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java-library'</span><span class="hljs-comment">//支持api</span><br>    dependencies &#123;<br>        api project(<span class="hljs-string">':meinian-bean'</span>)<br>        implementation <span class="hljs-string">'org.mybatis:mybatis-spring:1.2.3'</span><br>        implementation <span class="hljs-string">'com.alibaba:druid:1.0.15'</span><br>        implementation <span class="hljs-string">'org.mybatis:mybatis:3.3.0'</span><br>        implementation <span class="hljs-string">'mysql:mysql-connector-java:5.1.36'</span><br>    &#125;<br>&#125;<br>project(<span class="hljs-string">"meinian-service"</span>)&#123;<br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java-library'</span><span class="hljs-comment">//支持api</span><br>    dependencies &#123;<br>        api project(<span class="hljs-string">':meinian-dao'</span>)<br>        implementation <span class="hljs-string">'org.springframework:spring-web:4.1.7.RELEASE'</span><br>        implementation <span class="hljs-string">'org.springframework:spring-test:4.0.5.RELEASE'</span><br>        implementation <span class="hljs-string">'org.springframework:spring-jdbc:4.1.7.RELEASE'</span><br>        implementation <span class="hljs-string">'org.aspectj:aspectjweaver:1.8.6'</span><br>    &#125;<br>&#125;<br>project(<span class="hljs-string">"meinian-web"</span>)&#123;<br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'war'</span><br>    dependencies &#123;<br>        implementation project(<span class="hljs-string">':meinian-service'</span>)<br>        implementation <span class="hljs-string">'org.springframework:spring-webmvc:4.1.7.RELEASE'</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-databind:2.2.3"</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-annotations:2.2.3"</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-core:2.2.3"</span><br>        compileOnly <span class="hljs-string">'javax.servlet:servlet-api:2.5'</span><br>        implementation <span class="hljs-string">'jstl:jstl:1.2'</span><br>    &#125;<br>&#125;<br>project(<span class="hljs-string">"meinian-mobile-web"</span>)&#123;<br>    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'war'</span><br>    dependencies &#123;<br>        <span class="hljs-comment">//implementation project(':meinian-bean')</span><br>        implementation project(<span class="hljs-string">':meinian-service'</span>)<br>        implementation <span class="hljs-string">'org.springframework:spring-webmvc:4.1.7.RELEASE'</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-databind:2.2.3"</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-annotations:2.2.3"</span><br>        implementation <span class="hljs-string">"com.fasterxml.jackson.core:jackson-core:2.2.3"</span><br>        compileOnly <span class="hljs-string">'javax.servlet:servlet-api:2.5'</span><br>        implementation <span class="hljs-string">'jstl:jstl:1.2'</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽取之后，各子模块的 build.gradle 文件就不用配置了。</p>
<h2 id="3-12、微服务实战"><a href="#3-12、微服务实战" class="headerlink" title="3.12、微服务实战"></a>3.12、微服务实战</h2><h3 id="3-12-1、创建数据库及表"><a href="#3-12-1、创建数据库及表" class="headerlink" title="3.12.1、创建数据库及表"></a>3.12.1、创建数据库及表</h3><p>创建对应的数据库：CREATE DATABASE micro_user</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span>(<br>    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">UNSIGNED</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,<br>    username <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户名'</span>,<br>    email <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'邮箱'</span>,<br>    gender <span class="hljs-built_in">TINYINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'性别'</span><br>)<br></code></pre></td></tr></table></figure>

<p>创建对应的数据库：CREATE DATABASE micro_order</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> micro_order;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`orderinfo`</span> (<br>    <span class="hljs-string">`oid`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>    <span class="hljs-string">`uid`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,<br>    <span class="hljs-string">`product_name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'省份'</span>,<br>    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`oid`</span>)<br>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8<br></code></pre></td></tr></table></figure>


<h3 id="3-12-2、搭建项目架构"><a href="#3-12-2、搭建项目架构" class="headerlink" title="3.12.2、搭建项目架构"></a>3.12.2、搭建项目架构</h3><p><img src="/img/java/gradle/1659403079254.png" srcset="/img/loading.gif" lazyload alt="1659403079254"></p>
<ul>
<li>microservice-parent：统一管理所有模块的 jar 包版本信息</li>
<li>microservice-bean： 统一管理所有模块的用到的 pojo 类</li>
<li>microservice-common：统一管理所有模块的用到的工具类、枚举类、异常处理、日志文件、统一返回结果信息</li>
<li>microservice-service：统一封装所有的微服务</li>
<li>microservice-gateway：封装网关信息</li>
</ul>
<h3 id="3-12-3、具体演示"><a href="#3-12-3、具体演示" class="headerlink" title="3.12.3、具体演示"></a>3.12.3、具体演示</h3><p>创建项目结构，记得将 gradle 改成本地自己安装的 gradle。详情请参考视频。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Gradle/" class="category-chain-item">Gradle</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/Gradle/" class="print-no-link">#Gradle</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>30-Gradle 进阶</div>
      <div>https://flepeng.github.io/021-Java-13-Gradle-30-Gradle-进阶/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/021-Java-13-Gradle-71-%E6%8A%A5%E9%94%99-CreateProcess-error-%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%96%E6%89%A9%E5%B1%95%E5%90%8D%E5%A4%AA%E9%95%BF/" title="71-报错 CreateProcess error 文件名或扩展名太长">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">71-报错 CreateProcess error 文件名或扩展名太长</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/043-gRPC-01-gRPC-%E7%AE%80%E4%BB%8B/" title="01-gRPC 简介">
                        <span class="hidden-mobile">01-gRPC 简介</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
