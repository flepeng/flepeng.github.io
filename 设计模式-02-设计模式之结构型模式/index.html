

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="结构型模式是用来设计程序的结构的。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。包括以下几种：  适配器模式 桥接模式 组合模式（不常用） 装饰模式 外观模式（不常用） 享元模式（不常用） 代理模式  1、适配器模式说到适配器，我们最熟悉的莫过于电源适配器了，也就是手机的充电头。它就是适配器模式的一个应用。 试想一下，你有一条连接电脑和手机的 USB 数据线，连接电脑的一端从电脑接口处">
<meta property="og:type" content="article">
<meta property="og:title" content="02-设计模式之结构型模式">
<meta property="og:url" content="https://flepeng.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="结构型模式是用来设计程序的结构的。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。包括以下几种：  适配器模式 桥接模式 组合模式（不常用） 装饰模式 外观模式（不常用） 享元模式（不常用） 代理模式  1、适配器模式说到适配器，我们最熟悉的莫过于电源适配器了，也就是手机的充电头。它就是适配器模式的一个应用。 试想一下，你有一条连接电脑和手机的 USB 数据线，连接电脑的一端从电脑接口处">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pica.zhimg.com/v2-996bb76203be586161b57280d252c64e_r.jpg?source=1940ef5c">
<meta property="og:image" content="https://pica.zhimg.com/80/v2-b02e80f8c9e31c309cfa41ba191a0919_720w.jpg?source=1940ef5c">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-35efe24140308ba0394d7758fd7546c4_720w.jpg?source=1940ef5c">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-c75e41044733a59739f416b2100e21b7_720w.jpg?source=1940ef5c">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-751d3caaf8f304bd67097a4d5a7888ce_720w.jpg?source=1940ef5c">
<meta property="article:published_time" content="2021-03-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.502Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pica.zhimg.com/v2-996bb76203be586161b57280d252c64e_r.jpg?source=1940ef5c">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>02-设计模式之结构型模式 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="02-设计模式之结构型模式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-03-08 00:00" pubdate>
          2021年3月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          99 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">02-设计模式之结构型模式</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>结构型模式是用来设计程序的结构的</strong>。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。包括以下几种：</p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式（不常用）</li>
<li>装饰模式</li>
<li>外观模式（不常用）</li>
<li>享元模式（不常用）</li>
<li>代理模式</li>
</ul>
<h2 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h2><p>说到适配器，我们最熟悉的莫过于电源适配器了，也就是手机的充电头。它就是适配器模式的一个应用。</p>
<p>试想一下，你有一条连接电脑和手机的 USB 数据线，连接电脑的一端从电脑接口处接收 5V 的电压，连接手机的一端向手机输出 5V 的电压，并且他们工作良好。</p>
<p>中国的家用电压都是 220V，所以 USB 数据线不能直接拿来给手机充电，这时候我们有两种方案：</p>
<ul>
<li>单独制作手机充电器，接收 220V 家用电压，输出 5V 电压。</li>
<li>添加一个适配器，将 220V 家庭电压转化为类似电脑接口的 5V 电压，再连接数据线给手机充电。</li>
</ul>
<p>如果你使用过早期的手机，就会知道以前的手机厂商采用的就是第一种方案：早期的手机充电器都是单独制作的，充电头和充电线是连在一起的。现在的手机都采用了电源适配器加数据线的方案。这是生活中应用适配器模式的一个进步。</p>
<blockquote>
<p>适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</blockquote>
<p>适配的意思是适应、匹配。通俗地讲，适配器模式适用于 <strong>有相关性但不兼容的结构</strong>，源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p>
<p>家用电源和 USB 数据线有相关性：家用电源输出电压，USB 数据线输入电压。但两个接口无法兼容，因为一个输出 220V，一个输入 5V，通过适配器将输出 220V 转换成输出 5V 之后才可以一起工作。</p>
<p>让我们用程序来模拟一下这个过程。</p>
<p>首先，家庭电源提供 220V 的电压：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeBattery</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">supply</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 家用电源提供一个 220V 的输出电压</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">220</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>USB 数据线只接收 5V 的充电电压：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USBLine</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> volt)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果电压不是 5V，抛出异常</span><br>        <span class="hljs-keyword">if</span> (volt != <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-function">Il <span class="hljs-title">legalArgumentException</span><span class="hljs-params">(<span class="hljs-string">"只能接收 5V 电压"</span>)</span></span>;<br>        <span class="hljs-comment">// 如果电压是 5V，正常充电</span><br>        System.out.println(<span class="hljs-string">"正常充电"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先来看看适配之前，用户如果直接用家庭电源给手机充电：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chargeForPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        HomeBattery homeBattery = <span class="hljs-keyword">new</span> HomeBattery();<br>        <span class="hljs-keyword">int</span> homeVolt = homeBattery.supply();<br>        System.out.println(<span class="hljs-string">"家庭电源提供的电压是 "</span> + homeVolt + <span class="hljs-string">"V"</span>);<br><br>        USBLine usbLine = <span class="hljs-keyword">new</span> USBLine();<br>        usbLine.charge(homeVolt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">家庭电源提供的电压是 220V<br>java.lang.IllegalArgumentException: 只能接收 5V 电压<br></code></pre></td></tr></table></figure>

<p>这时，我们加入电源适配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> homeVolt)</span> </span>&#123;<br>        <span class="hljs-comment">// 适配过程：使用电阻、电容等器件将其降低为输出 5V</span><br>        <span class="hljs-keyword">int</span> chargeVolt = homeVolt - <span class="hljs-number">215</span>;<br>        <span class="hljs-keyword">return</span> chargeVolt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，用户再使用适配器将家庭电源提供的电压转换为充电电压：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chargeForPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        HomeBattery homeBattery = <span class="hljs-keyword">new</span> HomeBattery();<br>        <span class="hljs-keyword">int</span> homeVolt = homeBattery.supply();<br>        System.out.println(<span class="hljs-string">"家庭电源提供的电压是 "</span> + homeVolt + <span class="hljs-string">"V"</span>);<br><br>        Adapter adapter = <span class="hljs-keyword">new</span> Adapter();<br>        <span class="hljs-keyword">int</span> chargeVolt = adapter.convert(homeVolt);<br>        System.out.println(<span class="hljs-string">"使用适配器将家庭电压转换成了 "</span> + chargeVolt + <span class="hljs-string">"V"</span>);<br><br>        USBLine usbLine = <span class="hljs-keyword">new</span> USBLine();<br>        usbLine.charge(chargeVolt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">家庭电源提供的电压是 220V<br>使用适配器将家庭电压转换成了 5V<br>正常充电<br></code></pre></td></tr></table></figure>

<p>这就是适配器模式。在我们日常的开发中经常会使用到各种各样的 Adapter，都属于适配器模式的应用。</p>
<p>但适配器模式并不推荐多用。因为未雨绸缪好过亡羊补牢，如果事先能预防接口不同的问题，不匹配问题就不会发生，只有遇到源接口无法改变时，才应该考虑使用适配器。比如现代的电源插口中很多已经增加了专门地充电接口，让我们不需要再使用适配器转换接口，这又是社会的一个进步。</p>
<h2 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h2><p>考虑这样一个需求：绘制矩形、圆形、三角形这三种图案。按照面向对象的理念，我们至少需要三个具体类，对应三种不同的图形。</p>
<p>抽象接口 IShape：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>三个具体形状类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制矩形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Round</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制圆形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制三角形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们有了新的需求，每种形状都需要有四种不同的颜色：红、蓝、黄、绿。</p>
<p>这时我们很容易想到两种设计方案：</p>
<ul>
<li>为了复用形状类，将每种形状定义为父类，每种不同颜色的图形继承自其形状父类。此时一共有 12 个类。</li>
<li>为了复用颜色类，将每种颜色定义为父类，每种不同颜色的图形继承自其颜色父类。此时一共有 12 个类。</li>
</ul>
<p>乍一看没什么问题，我们使用了面向对象的继承特性，复用了父类的代码并扩展了新的功能。</p>
<p>但仔细想一想，如果以后要增加一种颜色，比如黑色，那么我们就需要增加三个类；如果再要增加一种形状，我们又需要增加五个类，对应 5 种颜色。</p>
<p>更不用说遇到增加 20 个形状，20 种颜色的需求，不同的排列组合将会使工作量变得无比的庞大。看来我们不得不重新思考设计方案。</p>
<p>形状和颜色，都是图形的两个属性。他们两者的关系是平等的，所以不属于继承关系。更好的的实现方式是：<strong>将形状和颜色分离，根据需要对形状和颜色进行组合</strong>，这就是桥接模式的思想。</p>
<blockquote>
<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p>
</blockquote>
<p>官方定义非常精准、简练，但却有点不易理解。通俗地说，如果一个对象有两种或者多种分类方式，并且两种分类方式都容易变化，比如本例中的形状和颜色。这时使用继承很容易造成子类越来越多，所以更好的做法是把这种分类方式分离出来，让他们独立变化，使用时将不同的分类进行组合即可。</p>
<p>说到这里，不得不提一个设计原则：合成&#x2F;聚合复用原则。虽然它没有被划分到六大设计原则中，但它在面向对象的设计中也非常重要。</p>
<blockquote>
<p>合成&#x2F;聚合复用原则：优先使用合成&#x2F;聚合，而不是类继承。</p>
</blockquote>
<p>继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成&#x2F;聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。</p>
<p>让我们一起来看一下本例使用桥接模式的程序实现：</p>
<p>新建接口类 IColor，仅包含一个获取颜色的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IColor</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每种颜色都实现此接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"红"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"蓝"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yellow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"黄"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Green</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"绿"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在每个形状类中，桥接 IColor 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IColor color;       <span class="hljs-comment">// 桥接 IColor 接口</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(IColor color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制"</span> + color.getColor() + <span class="hljs-string">"矩形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Round</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IColor color;       <span class="hljs-comment">// 桥接 IColor 接口</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(IColor color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制"</span> + color.getColor() + <span class="hljs-string">"圆形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IColor color;       <span class="hljs-comment">// 桥接 IColor 接口</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(IColor color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"绘制"</span> + color.getColor() + <span class="hljs-string">"三角形"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTest</span><span class="hljs-params">()</span> </span>&#123;<br>    Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle();<br>    rectangle.setColor(<span class="hljs-keyword">new</span> Red());<br>    rectangle.draw();<br>    <br>    Round round = <span class="hljs-keyword">new</span> Round();<br>    round.setColor(<span class="hljs-keyword">new</span> Blue());<br>    round.draw();<br>    <br>    Triangle triangle = <span class="hljs-keyword">new</span> Triangle();<br>    triangle.setColor(<span class="hljs-keyword">new</span> Yellow());<br>    triangle.draw();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">绘制红矩形<br>绘制蓝圆形<br>绘制黄三角形<br></code></pre></td></tr></table></figure>

<p>这时我们再来回顾一下官方定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。抽象部分指的是父类，对应本例中的形状类，实现部分指的是不同子类的区别之处。将子类的区别方式 —— 也就是本例中的颜色 —— 分离成接口，通过组合的方式桥接颜色和形状，这就是桥接模式，它主要用于 <strong>两个或多个同等级的接口</strong>。</p>
<h2 id="3、组合模式（不常用）"><a href="#3、组合模式（不常用）" class="headerlink" title="3、组合模式（不常用）"></a>3、组合模式（不常用）</h2><p>上文说到，桥接模式用于将同等级的接口互相组合，那么组合模式和桥接模式有什么共同点吗？</p>
<p>事实上组合模式和桥接模式的组合完全不一样。组合模式用于 <strong>整体与部分的结构</strong>，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。例如：</p>
<ul>
<li>文件夹和子文件夹的关系：文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样。</li>
<li>总公司子公司的关系：总公司可以设立部门，也可以设立分公司，子公司也一样。</li>
<li>树枝和分树枝的关系：树枝可以长出叶子，也可以长出树枝，分树枝也一样。</li>
</ul>
<p>在这些关系中，虽然整体包含了部分，但无论整体或部分，都具有一致的行为。</p>
<blockquote>
<p>组合模式：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
</blockquote>
<p>考虑这样一个实际应用：设计一个公司的人员分布结构，结构如下图所示。</p>
<p><img src="https://pica.zhimg.com/v2-996bb76203be586161b57280d252c64e_r.jpg?source=1940ef5c" srcset="/img/loading.gif" lazyload></p>
<p>我们注意到人员结构中有两种结构，一是管理者，如老板，PM，CFO，CTO，二是职员。其中有的管理者不仅仅要管理职员，还会管理其他的管理者。这就是一个典型的整体与部分的结构。</p>
<h3 id="3-1、不使用组合模式的设计方案"><a href="#3-1、不使用组合模式的设计方案" class="headerlink" title="3.1、不使用组合模式的设计方案"></a>3.1、不使用组合模式的设计方案</h3><p>要描述这样的结构，我们很容易想到以下设计方案：</p>
<p>新建管理者类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;<br>    <span class="hljs-comment">// 职位</span><br>    <span class="hljs-keyword">private</span> String position;<br>    <span class="hljs-comment">// 工作内容</span><br>    <span class="hljs-keyword">private</span> String job;<br>    <span class="hljs-comment">// 管理的管理者</span><br>    <span class="hljs-keyword">private</span> List&lt;Manager&gt; managers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 管理的职员</span><br>    <span class="hljs-keyword">private</span> List&lt;Employee&gt; employees = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.job = job;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addManager</span><span class="hljs-params">(Manager manager)</span> </span>&#123;<br>        managers.add(manager);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeManager</span><span class="hljs-params">(Manager manager)</span> </span>&#123;<br>        managers.remove(manager);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEmployee</span><span class="hljs-params">(Employee employee)</span> </span>&#123;<br>        employees.add(employee);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeEmployee</span><span class="hljs-params">(Employee employee)</span> </span>&#123;<br>        employees.remove(employee);<br>    &#125;<br><br>    <span class="hljs-comment">// 做自己的本职工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是"</span> + position + <span class="hljs-string">"，我正在"</span> + job);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查下属</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        work();<br>        <span class="hljs-keyword">for</span> (Employee employee : employees) &#123;<br>            employee.work();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Manager manager : managers) &#123;<br>            manager.check();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建职员类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-comment">// 职位</span><br>    <span class="hljs-keyword">private</span> String position;<br>    <span class="hljs-comment">// 工作内容</span><br>    <span class="hljs-keyword">private</span> String job;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.job = job;<br>    &#125;<br><br>    <span class="hljs-comment">// 做自己的本职工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是"</span> + position + <span class="hljs-string">"，我正在"</span> + job);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端建立人员结构关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Manager boss = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"老板"</span>, <span class="hljs-string">"唱怒放的生命"</span>);<br>        Employee HR = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"人力资源"</span>, <span class="hljs-string">"聊微信"</span>);<br>        Manager PM = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"产品经理"</span>, <span class="hljs-string">"不知道干啥"</span>);<br>        Manager CFO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"财务主管"</span>, <span class="hljs-string">"看剧"</span>);<br>        Manager CTO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"技术主管"</span>, <span class="hljs-string">"划水"</span>);<br>        Employee UI = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"设计师"</span>, <span class="hljs-string">"画画"</span>);<br>        Employee operator = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"运营人员"</span>, <span class="hljs-string">"兼职客服"</span>);<br>        Employee webProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"程序员"</span>, <span class="hljs-string">"学习设计模式"</span>);<br>        Employee backgroundProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"后台程序员"</span>, <span class="hljs-string">"CRUD"</span>);<br>        Employee accountant = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"会计"</span>, <span class="hljs-string">"背九九乘法表"</span>);<br>        Employee clerk = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"文员"</span>, <span class="hljs-string">"给老板递麦克风"</span>);<br>        boss.addEmployee(HR);<br>        boss.addManager(PM);<br>        boss.addManager(CFO);<br>        PM.addEmployee(UI);<br>        PM.addManager(CTO);<br>        PM.addEmployee(operator);<br>        CTO.addEmployee(webProgrammer);<br>        CTO.addEmployee(backgroundProgrammer);<br>        CFO.addEmployee(accountant);<br>        CFO.addEmployee(clerk);<br><br>        boss.check();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行测试方法，输出如下（为方便查看，添加了缩进）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">我是老板，我正在唱怒放的生命<br>    我是人力资源，我正在聊微信<br>    我是产品经理，我正在不知道干啥<br>        我是设计师，我正在画画<br>        我是运营人员，我正在兼职客服<br>        我是技术主管，我正在划水<br>            我是程序员，我正在学习设计模式<br>            我是后台程序员，我正在CRUD<br>    我是财务主管，我正在看剧<br>        我是会计，我正在背九九乘法表<br>        我是文员，我正在给老板递麦克风<br></code></pre></td></tr></table></figure>

<p>这样我们就设计出了公司的结构，但是这样的设计有两个弊端：</p>
<ul>
<li>name 字段，job 字段，work 方法重复了。</li>
<li>管理者对其管理的管理者和职员需要区别对待。</li>
</ul>
<p>关于第一个弊端，虽然这里为了讲解，只有两个字段和一个方法重复，实际工作中这样的整体部分结构会有相当多的重复。比如此例中还可能有工号、年龄等字段，领取工资、上下班打卡、开各种无聊地会等方法。</p>
<p>大量的重复显然是很丑陋的代码，分析一下可以发现， Manager 类只比 Employee 类多一个管理人员的列表字段，多几个增加 &#x2F; 移除人员的方法，其他的字段和方法全都是一样的。</p>
<p>有读者应该会想到：我们可以将重复的字段和方法提取到一个工具类中，让 Employee 和 Manager 都去调用此工具类，就可以消除重复了。</p>
<p>这样固然可行，但属于 Employee 和 Manager 类自己的东西却要通过其他类调用，并不利于程序的高内聚。</p>
<p>关于第二个弊端，此方案无法解决，此方案中 Employee 和 Manager 类完全是两个不同的对象，两者的相似性被忽略了。</p>
<p>所以我们有更好的设计方案，那就是组合模式！</p>
<h3 id="3-2、使用组合模式的设计方案"><a href="#3-2、使用组合模式的设计方案" class="headerlink" title="3.2、使用组合模式的设计方案"></a>3.2、使用组合模式的设计方案</h3><p>组合模式最主要的功能就是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件，所以我们先新建一个抽象的组件类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 职位</span><br>    <span class="hljs-keyword">private</span> String position;<br>    <span class="hljs-comment">// 工作内容</span><br>    <span class="hljs-keyword">private</span> String job;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Component</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.job = job;<br>    &#125;<br><br>    <span class="hljs-comment">// 做自己的本职工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是"</span> + position + <span class="hljs-string">"，我正在"</span> + job);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addComponent</span><span class="hljs-params">(Component component)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeComponent</span><span class="hljs-params">(Component component)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>管理者继承自此抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 管理的组件</span><br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; components = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(position, job);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        components.add(component);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        components.remove(component);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查下属</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        work();<br>        <span class="hljs-keyword">for</span> (Component component : components) &#123;<br>            component.check();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>职员同样继承自此抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(position, job);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"职员没有管理权限"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"职员没有管理权限"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        work();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改客户端如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        Component boss = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"老板"</span>, <span class="hljs-string">"唱怒放的生命"</span>);<br>        Component HR = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"人力资源"</span>, <span class="hljs-string">"聊微信"</span>);<br>        Component PM = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"产品经理"</span>, <span class="hljs-string">"不知道干啥"</span>);<br>        Component CFO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"财务主管"</span>, <span class="hljs-string">"看剧"</span>);<br>        Component CTO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"技术主管"</span>, <span class="hljs-string">"划水"</span>);<br>        Component UI = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"设计师"</span>, <span class="hljs-string">"画画"</span>);<br>        Component operator = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"运营人员"</span>, <span class="hljs-string">"兼职客服"</span>);<br>        Component webProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"程序员"</span>, <span class="hljs-string">"学习设计模式"</span>);<br>        Component backgroundProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"后台程序员"</span>, <span class="hljs-string">"CRUD"</span>);<br>        Component accountant = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"会计"</span>, <span class="hljs-string">"背九九乘法表"</span>);<br>        Component clerk = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"文员"</span>, <span class="hljs-string">"给老板递麦克风"</span>);<br>        boss.addComponent(HR);<br>        boss.addComponent(PM);<br>        boss.addComponent(CFO);<br>        PM.addComponent(UI);<br>        PM.addComponent(CTO);<br>        PM.addComponent(operator);<br>        CTO.addComponent(webProgrammer);<br>        CTO.addComponent(backgroundProgrammer);<br>        CFO.addComponent(accountant);<br>        CFO.addComponent(clerk);<br><br>        boss.check();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行测试方法，输出结果与之前的结果一模一样。</p>
<p>可以看到，使用组合模式后，我们解决了之前的两个弊端。一是将共有的字段与方法移到了父类中，消除了重复，并且在客户端中，可以一致对待 Manager 和 Employee 类：</p>
<ul>
<li>Manager 类和 Employee 类统一声明为 Component 对象</li>
<li>统一调用 Component 对象的 addComponent 方法添加子对象即可。</li>
</ul>
<h3 id="3-3、组合模式中的安全方式与透明方式"><a href="#3-3、组合模式中的安全方式与透明方式" class="headerlink" title="3.3、组合模式中的安全方式与透明方式"></a>3.3、组合模式中的安全方式与透明方式</h3><p>读者可能已经注意到了，Employee 类虽然继承了父类的 addComponent 和 removeComponent 方法，但是仅仅提供了一个空实现，因为 Employee 类是不支持添加和移除组件的。这样是否违背了接口隔离原则呢？</p>
<blockquote>
<p>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</p>
</blockquote>
<p>答案是肯定的，这样确实违背了接口隔离原则。这种方式在组合模式中被称作透明方式.</p>
<blockquote>
<p>透明方式：在 Component 中声明所有管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。</p>
</blockquote>
<p>这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。</p>
<p>但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 removeComponent 方法，导致程序出错，所以这种方式是不安全的。</p>
<p>那么我们可不可以将 addComponent 和 removeComponent 方法移到 Manager 子类中去单独实现，让 Employee 不再实现这两个方法呢？我们来尝试一下。</p>
<p>将抽象类修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 职位</span><br>    <span class="hljs-keyword">private</span> String position;<br>    <span class="hljs-comment">// 工作内容</span><br>    <span class="hljs-keyword">private</span> String job;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Component</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.job = job;<br>    &#125;<br><br>    <span class="hljs-comment">// 做自己的本职工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是"</span> + position + <span class="hljs-string">"，我正在"</span> + job);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，我们在父类中去掉了 addComponent 和 removeComponent 这两个抽象方法。</p>
<p>Manager 类修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 管理的组件</span><br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; components = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(position, job);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        components.add(component);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeComponent</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        components.remove(component);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查下属</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        work();<br>        <span class="hljs-keyword">for</span> (Component component : components) &#123;<br>            component.check();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Manager 类单独实现了 addComponent 和 removeComponent 这两个方法，去掉了 @Override 注解。</p>
<p>Employee 类修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String position, String job)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(position, job);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        work();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端建立人员结构关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        Manager boss = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"老板"</span>, <span class="hljs-string">"唱怒放的生命"</span>);<br>        Employee HR = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"人力资源"</span>, <span class="hljs-string">"聊微信"</span>);<br>        Manager PM = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"产品经理"</span>, <span class="hljs-string">"不知道干啥"</span>);<br>        Manager CFO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"财务主管"</span>, <span class="hljs-string">"看剧"</span>);<br>        Manager CTO = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"技术主管"</span>, <span class="hljs-string">"划水"</span>);<br>        Employee UI = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"设计师"</span>, <span class="hljs-string">"画画"</span>);<br>        Employee operator = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"运营人员"</span>, <span class="hljs-string">"兼职客服"</span>);<br>        Employee webProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"程序员"</span>, <span class="hljs-string">"学习设计模式"</span>);<br>        Employee backgroundProgrammer = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"后台程序员"</span>, <span class="hljs-string">"CRUD"</span>);<br>        Employee accountant = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"会计"</span>, <span class="hljs-string">"背九九乘法表"</span>);<br>        Employee clerk = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"文员"</span>, <span class="hljs-string">"给老板递麦克风"</span>);<br>        boss.addComponent(HR);<br>        boss.addComponent(PM);<br>        boss.addComponent(CFO);<br>        PM.addComponent(UI);<br>        PM.addComponent(CTO);<br>        PM.addComponent(operator);<br>        CTO.addComponent(webProgrammer);<br>        CTO.addComponent(backgroundProgrammer);<br>        CFO.addComponent(accountant);<br>        CFO.addComponent(clerk);<br><br>        boss.check();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出结果与之前一模一样。</p>
<p>这种方式在组合模式中称之为安全方式。</p>
<blockquote>
<p>安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p>
</blockquote>
<p>安全方式遵循了接口隔离原则，但由于不够透明，Manager 和 Employee 类不具有相同的接口，在客户端中，我们无法将 Manager 和 Employee 统一声明为 Component 类了，必须要区别对待，带来了使用上的不方便。</p>
<p>安全方式和透明方式各有好处，在使用组合模式时，需要根据实际情况决定。但大多数使用组合模式的场景都是采用的透明方式，虽然它有点不安全，但是客户端无需做任何判断来区分是叶子结点还是枝节点，用起来是真香。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</p>
</li>
<li><p>从一个整体中能够独立出部分模块或功能的场景。</p>
</li>
</ul>
<p>注意：只要是树形结构，就考虑使用组合模式。</p>
<h2 id="4、装饰模式"><a href="#4、装饰模式" class="headerlink" title="4、装饰模式"></a>4、装饰模式</h2><p>提到装饰，我们先来想一下生活中有哪些装饰：</p>
<ul>
<li><strong>女生的首饰</strong>：戒指、耳环、项链等装饰品</li>
<li><strong>家居装饰品</strong>：粘钩、镜子、壁画、盆栽等</li>
</ul>
<p>我们为什么需要这些装饰品呢？很容易想到是为了美，戒指、耳环、项链、壁画、盆栽等都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：</p>
<ul>
<li><strong>增强原有的特性</strong>：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。</li>
<li><strong>添加新的特性</strong>：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。</li>
</ul>
<p>并且，我们发现装饰品并不会改变物品本身，只是起到锦上添花的作用。装饰模式也一样，它的主要作用就是：</p>
<ul>
<li><strong>增强一个类原有的功能</strong></li>
<li><strong>为一个类添加新的功能</strong></li>
</ul>
<p>并且 <strong>装饰模式也不会改变原有的类</strong>。</p>
<blockquote>
<p><strong>装饰模式</strong>：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p>
</blockquote>
<h3 id="1、用于增强功能的装饰模式"><a href="#1、用于增强功能的装饰模式" class="headerlink" title="1、用于增强功能的装饰模式"></a>1、用于增强功能的装饰模式</h3><p>我们用程序来模拟一下戴上装饰品提高我们颜值的过程：</p>
<p>新建颜值接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBeauty</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeautyValue</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建 Me 类，实现颜值接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Me</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBeauty</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeautyValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>戒指装饰类，将 Me 包装起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RingDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBeauty</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IBeauty me;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RingDecorator</span><span class="hljs-params">(IBeauty me)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.me = me;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeautyValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> me.getBeautyValue() + <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        IBeauty me = <span class="hljs-keyword">new</span> Me();<br>        System.out.println(<span class="hljs-string">"我原本的颜值："</span> + me.getBeautyValue());<br><br>        IBeauty meWithRing = <span class="hljs-keyword">new</span> RingDecorator(me);<br>        System.out.println(<span class="hljs-string">"戴上了戒指后，我的颜值："</span> + meWithRing.getBeautyValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">我原本的颜值：100<br>戴上了戒指后，我的颜值：120<br></code></pre></td></tr></table></figure>

<p>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p>
<p>耳环装饰类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EarringDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBeauty</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IBeauty me;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EarringDecorator</span><span class="hljs-params">(IBeauty me)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.me = me;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeautyValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> me.getBeautyValue() + <span class="hljs-number">50</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>项链装饰类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NecklaceDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBeauty</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IBeauty me;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NecklaceDecorator</span><span class="hljs-params">(IBeauty me)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.me = me;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeautyValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> me.getBeautyValue() + <span class="hljs-number">80</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        IBeauty me = <span class="hljs-keyword">new</span> Me();<br>        System.out.println(<span class="hljs-string">"我原本的颜值："</span> + me.getBeautyValue());<br><br>        <span class="hljs-comment">// 随意挑选装饰</span><br>        IBeauty meWithNecklace = <span class="hljs-keyword">new</span> NecklaceDecorator(me);<br>        System.out.println(<span class="hljs-string">"戴上了项链后，我的颜值："</span> + meWithNecklace.getBeautyValue());<br><br>        <span class="hljs-comment">// 多次装饰</span><br>        IBeauty meWithManyDecorators = <span class="hljs-keyword">new</span> NecklaceDecorator(<span class="hljs-keyword">new</span> RingDecorator(<span class="hljs-keyword">new</span> EarringDecorator(me)));<br>        System.out.println(<span class="hljs-string">"戴上耳环、戒指、项链后，我的颜值："</span> + meWithManyDecorators.getBeautyValue());<br><br>        <span class="hljs-comment">// 任意搭配装饰</span><br>        IBeauty meWithNecklaceAndRing = <span class="hljs-keyword">new</span> NecklaceDecorator(<span class="hljs-keyword">new</span> RingDecorator(me));<br>        System.out.println(<span class="hljs-string">"戴上戒指、项链后，我的颜值："</span> + meWithNecklaceAndRing.getBeautyValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">我原本的颜值：100<br>戴上了项链后，我的颜值：180<br>戴上耳环、戒指、项链后，我的颜值：250<br>戴上戒指、项链后，我的颜值：200<br></code></pre></td></tr></table></figure>

<p>可以看到，装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器<strong>仅用于增强功能，并不会改变 Me 原有的功能</strong>，这种装饰模式称之为 <strong>透明装饰模式</strong>，由于没有改变接口，也没有新增方法，所以<strong>透明装饰模式可以无限装饰</strong>。</p>
<p>装饰模式是 <strong>继承</strong> 的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类……各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就 <strong>增加对象功能</strong> 来说，<strong>装饰模式比生成子类实现更为灵活</strong>。</p>
<h3 id="2、用于添加功能的装饰模式"><a href="#2、用于添加功能的装饰模式" class="headerlink" title="2、用于添加功能的装饰模式"></a>2、用于添加功能的装饰模式</h3><p>我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：</p>
<p>新建房屋接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHouse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>房屋类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHouse</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"房屋原有的功能：居住功能"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建粘钩装饰器接口，继承自房屋接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IStickyHookHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IHouse</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hangThings</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>粘钩装饰类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StickyHookDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IStickyHookHouse</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IHouse house;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StickyHookDecorator</span><span class="hljs-params">(IHouse house)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.house = house;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span> </span>&#123;<br>        house.live();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hangThings</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"有了粘钩后，新增了挂东西功能"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        IHouse house = <span class="hljs-keyword">new</span> House();<br>        house.live();<br><br>        IStickyHookHouse stickyHookHouse = <span class="hljs-keyword">new</span> StickyHookDecorator(house);<br>        stickyHookHouse.live();<br>        stickyHookHouse.hangThings();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">房屋原有的功能：居住功能<br>房屋原有的功能：居住功能<br>有了粘钩后，新增了挂东西功能<br></code></pre></td></tr></table></figure>

<p>这就是用于 <strong>新增功能</strong> 的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为 <strong>半透明装饰模式</strong>。</p>
<p>为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待 <strong>装饰前的对象和装饰后的对象</strong>。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。</p>
<p>我们可以添加更多的装饰器：</p>
<p>新建镜子装饰器的接口，继承自房屋接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMirrorHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IHouse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lookMirror</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>镜子装饰类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MirrorDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMirrorHouse</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IHouse house;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MirrorDecorator</span><span class="hljs-params">(IHouse house)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.house = house;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span> </span>&#123;<br>        house.live();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookMirror</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"有了镜子后，新增了照镜子功能"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        IHouse house = <span class="hljs-keyword">new</span> House();<br>        house.live();<br><br>        IMirrorHouse mirrorHouse = <span class="hljs-keyword">new</span> MirrorDecorator(house);<br>        mirrorHouse.live();<br>        mirrorHouse.lookMirror();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">房屋原有的功能：居住功能<br>房屋原有的功能：居住功能<br>有了镜子后，新增了照镜子功能<br></code></pre></td></tr></table></figure>

<p>现在我们仿照 <strong>透明装饰模式</strong> 的写法，同时添加粘钩和镜子装饰试一试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        IHouse house = <span class="hljs-keyword">new</span> House();<br>        house.live();<br><br>        IStickyHookHouse stickyHookHouse = <span class="hljs-keyword">new</span> StickyHookDecorator(house);<br>        IMirrorHouse houseWithStickyHookMirror = <span class="hljs-keyword">new</span> MirrorDecorator(stickyHookHouse);<br>        houseWithStickyHookMirror.live();<br>        houseWithStickyHookMirror.hangThings(); <span class="hljs-comment">// 这里会报错，找不到 hangThings 方法</span><br>        houseWithStickyHookMirror.lookMirror();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们会发现，第二次装饰时，无法获得上一次装饰添加的方法。原因很明显，当我们用 IMirrorHouse 装饰器后，接口变为了 IMirrorHouse，这个接口中并没有 hangThings 方法。</p>
<p>那么我们能否让 IMirrorHouse 继承自 IStickyHookHouse，以实现新增两个功能呢？</p>
<p>可以，但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了。装饰类不应该存在依赖关系，而应该在原本的类上进行装饰。这就意味着，<strong>半透明装饰模式中</strong>，<strong>我们无法多次装饰</strong>。</p>
<p>有的同学会问了，既增强了功能，又添加了新功能的装饰模式叫什么呢？</p>
<p>举一反三，肯定是叫全不透明装饰模式！</p>
<p>并不是！只要添加了新功能的装饰模式都称之为 <strong>半透明装饰模式</strong>，他们都具有不可以多次装饰的特点。仔细理解上文半透明名称的由来就知道了，“透明”指的是我们无需知道被装饰者具体的类，既增强了功能，又添加了新功能的装饰模式仍然具有半透明特性。</p>
<p>看了这两个简单的例子，是不是发现装饰模式很简单呢？恭喜你学会了 1 + 1 &#x3D; 2，现在你已经掌握了算数的基本思想，接下来我们来做一道微积分题练习一下。</p>
<h3 id="I-x2F-O-中的装饰模式"><a href="#I-x2F-O-中的装饰模式" class="headerlink" title="I&#x2F;O 中的装饰模式"></a>I&#x2F;O 中的装饰模式</h3><p>I&#x2F;O 指的是 Input&#x2F;Output，即输入、输出。我们以 Input 为例。先在 <code>src</code> 文件夹下新建一个文件 readme.text，随便写点文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">禁止套娃<br>禁止禁止套娃<br>禁止禁止禁止套娃<br></code></pre></td></tr></table></figure>

<p>然后用 Java 的 InputStream 读取，代码一般长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    InputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"src/readme.txt"</span>));<br>    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (in.read(buffer) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> String(buffer));<br>    &#125;<br>    in.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样写有一个问题，如果读取过程中出现了 IO 异常，InputStream 就不能正确关闭，所以我们要用 <code>try...finally</code> 来保证 InputStream 正确关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    InputStream in = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"src/readme.txt"</span>));<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> (in.read(buffer) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(buffer));<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;<br>            in.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种写法实在是太丑了，而 IO 操作又必须这么写，显然 Java 也意识到了这个问题，所以 Java 7 中引入了 <code>try(resource)</code> 语法糖，IO 的代码就可以简化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> (InputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"src/readme.txt"</span>))) &#123;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> (in.read(buffer) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(buffer));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种写法和上一种逻辑是一样的，运行程序，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">禁止套娃<br>禁止禁止套娃<br>禁止禁止禁止套娃<br></code></pre></td></tr></table></figure>

<p>观察获取 InputStream 这句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"src/readme.txt"</span>));<br></code></pre></td></tr></table></figure>

<p>是不是和我们之前多次装饰的代码非常相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多次装饰</span><br>IBeauty meWithManyDecorators = <span class="hljs-keyword">new</span> NecklaceDecorator(<span class="hljs-keyword">new</span> RingDecorator(<span class="hljs-keyword">new</span> EarringDecorator(me)));<br></code></pre></td></tr></table></figure>

<p>事实上，查看 I&#x2F;O 的源码可知，Java I&#x2F;O 的设计框架便是使用的 <strong>装饰者模式</strong>，InputStream 的继承关系如下：</p>
<p><img src="https://pica.zhimg.com/80/v2-b02e80f8c9e31c309cfa41ba191a0919_720w.jpg?source=1940ef5c" srcset="/img/loading.gif" lazyload></p>
<p>其中，InputStream 是一个抽象类，对应上文例子中的 IHouse，其中最重要的方法是 read 方法，这是一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法会读取输入流的下一个字节，并返回字节表示的 int 值（0~255），返回 -1 表示已读到末尾。由于它是抽象方法，所以具体的逻辑交由子类实现。</p>
<p>上图中，左边的三个类 FileInputStream、ByteArrayInputStream、ServletInputStream 是 InputStream 的三个子类，对应上文例子中实现了 IHouse 接口的 House。</p>
<p>右下角的三个类 BufferedInputStream、DataInputStream、CheckedInputStream 是三个具体的装饰者类，他们都为 InputStream 增强了原有功能或添加了新功能。</p>
<p>FilterInputStream 是所有装饰类的父类，它没有实现具体的功能，仅用来包装了一下 InputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStream</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.in = in;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> in.read();<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们以 BufferedInputStream 为例。原有的 InputStream 读取文件时，是一个字节一个字节读取的，这种方式的执行效率并不高，所以我们可以设立一个缓冲区，先将内容读取到缓冲区中，缓冲区读满后，将内容从缓冲区中取出来，这样就变成了一段一段读取，用内存换取效率。BufferedInputStream 就是用来做这个的。它继承自 FilterInputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FilterInputStream</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="hljs-number">8192</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> buf[];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Buffer size &lt;= 0"</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先来看它的构造方法，在构造方法中，新建了一个 <code>byte[]</code> 作为缓冲区，从源码中我们看到，Java 默认设置的缓冲区大小为 8192 byte，也就是 8 KB。</p>
<p>然后我们来查看 read 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FilterInputStream</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos &gt;= count) &#123;<br>            fill();<br>            <span class="hljs-keyword">if</span> (pos &gt;= count)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 往缓冲区内填充读取内容的过程</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 read 方法中，调用了 fill 方法，fill 方法的作用就是往缓冲区中填充读取的内容。这样就实现了增强原有的功能。</p>
<p>在源码中我们发现，BufferedInputStream 没有添加 InputStream 中没有的方法，所以 BufferedInputStream 使用的是 <strong>透明的装饰模式</strong>。</p>
<p>DataInputStream 用于更加方便地读取 int、double 等内容，观察 DataInputStream 的源码可以发现，DataInputStream 中新增了 readInt、readLong 等方法，所以 DataInputStream 使用的是 <strong>半透明装饰模式</strong>。</p>
<p>理解了 InputStream 后，再看一下 OutputStream 的继承关系，相信大家一眼就能看出各个类的作用了：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35efe24140308ba0394d7758fd7546c4_720w.jpg?source=1940ef5c" srcset="/img/loading.gif" lazyload></p>
<p>这就是装饰模式，注意不要和适配器模式混淆了。两者在使用时都是包装一个类，但两者的区别其实也很明显：</p>
<ul>
<li>纯粹的适配器模式 <strong>仅用于改变接口</strong>，不改变其功能，部分情况下我们需要改变一点功能以适配新接口。但使用适配器模式时，接口一定会有一个 <strong>回炉重造</strong> 的过程。</li>
<li>装饰模式 <strong>不改变原有的接口</strong>，仅用于增强原有功能或添加新功能，强调的是 <strong>锦上添花</strong>。</li>
</ul>
<p>掌握了装饰者模式之后，理解 Java I&#x2F;O 的框架设计就非常容易了。但对于不理解装饰模式的人来说，各种各样相似的 InputStream 非常容易让开发者感到困惑。这一点正是装饰模式的缺点：<strong>容易造成程序中有大量相似的类</strong>。虽然这更像是开发者的缺点，我们应该做的是提高自己的技术，掌握了这个设计模式之后它就是我们的一把利器。现在我们再看到 I&#x2F;O 不同的 InputStream 装饰类，只需要关注它增强了什么功能或添加了什么功能即可。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>需要扩展一个类的功能，或给一个类增加附加功能。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</li>
</ul>
<h2 id="5、外观模式（不常用）"><a href="#5、外观模式（不常用）" class="headerlink" title="5、外观模式（不常用）"></a>5、外观模式（不常用）</h2><p>外观模式非常简单，体现的就是 Java 中封装的思想。将多个子系统封装起来，提供一个更简洁地接口供外部调用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c75e41044733a59739f416b2100e21b7_720w.jpg?source=1940ef5c" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p><strong>外观模式</strong>：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。</p>
</blockquote>
<p>举个例子，比如我们每天打开电脑时，都需要做三件事：</p>
<ul>
<li>打开浏览器</li>
<li>打开 IDE</li>
<li>打开微信</li>
</ul>
<p>每天下班时，关机前需要做三件事：</p>
<ul>
<li>关闭浏览器</li>
<li>关闭 IDE</li>
<li>关闭微信</li>
</ul>
<p>用程序模拟如下：</p>
<p>新建浏览器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Browser</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"打开浏览器"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"关闭浏览器"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建 IDE 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDE</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"打开 IDE"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"关闭 IDE"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建微信类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wechat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"打开微信"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"关闭微信"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"上班:"</span>);<br>        Browser.open();<br>        IDE.open();<br>        Wechat.open();<br><br>        System.out.println(<span class="hljs-string">"下班:"</span>);<br>        Browser.close();<br>        IDE.close();<br>        Wechat.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">上班:<br>打开浏览器<br>打开 IDE<br>打开微信<br>下班:<br>关闭浏览器<br>关闭 IDE<br>关闭微信<br></code></pre></td></tr></table></figure>

<p>由于我们每天都要做这几件事，所以我们可以使用<strong>外观模式</strong>，将这几个子系统封装起来，提供更简洁的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        Browser.open();<br>        IDE.open();<br>        Wechat.open();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        Browser.close();<br>        IDE.close();<br>        Wechat.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端就可以简化代码，只和这个外观类打交道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Facade facade = <span class="hljs-keyword">new</span> Facade();<br>        System.out.println(<span class="hljs-string">"上班:"</span>);<br>        facade.open();<br><br>        System.out.println(<span class="hljs-string">"下班:"</span>);<br>        facade.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出与之前一样。</p>
<p>外观模式就是这么简单，它使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。</p>
<p>外观模式非常常用，（当然了！写代码哪有不封装的！）尤其是在第三方库的设计中，我们应该尽量提供简洁的接口供别人调用。另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口</li>
<li>子系统相对独立——外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散</li>
</ul>
<h2 id="6、享元模式（不常用）"><a href="#6、享元模式（不常用）" class="headerlink" title="6、享元模式（不常用）"></a>6、享元模式（不常用）</h2><p>享元模式体现的是 <strong>程序可复用</strong> 的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don’t repeat yourself. 简单来说 <strong>享元模式就是共享对象</strong>，提高复用性，官方的定义倒是显得文绉绉的：</p>
<blockquote>
<p><strong>享元模式</strong>：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p>
</blockquote>
<p>有个细节值得注意：有些对象本身不一样，但通过一点点变化后就可以复用，我们编程时可能稍不注意就会忘记复用这些对象。比如说伟大的《超级玛丽》，谁能想到草和云更改一下颜色就可以实现复用呢？</p>
<p>还有里面的三种乌龟，换一个颜色、加一个装饰就变成了不同的怪：</p>
<p><img src="https://pic2.zhimg.com/80/v2-751d3caaf8f304bd67097a4d5a7888ce_720w.jpg?source=1940ef5c" srcset="/img/loading.gif" lazyload></p>
<p>在《超级玛丽》中，这样的细节还有很多，正是这些精湛的复用使得这一款红遍全球的游戏仅有 40KB 大小。正是印证了那句名言：神在细节之中。</p>
<h2 id="7、代理模式"><a href="#7、代理模式" class="headerlink" title="7、代理模式"></a>7、代理模式</h2><p>现在我们有一个 <code>人</code> 类，他整天就只负责吃饭、睡觉：</p>
<p><code>人</code> 类的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPerson</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>人</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPerson</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我在吃饭"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我在睡觉"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        person.eat();<br>        person.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">我在吃饭<br>我在睡觉<br></code></pre></td></tr></table></figure>

<p>我们可以把这个类包装到另一个类中，实现完全一样的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPerson</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Person person;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonProxy</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.person = person;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        person.eat();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        person.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将客户端修改为调用这个新的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        PersonProxy proxy = <span class="hljs-keyword">new</span> PersonProxy(person);<br>        proxy.eat();<br>        proxy.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">我在吃饭<br>我在睡觉<br></code></pre></td></tr></table></figure>

<p>这就是代理模式。</p>
<p>笔者尽量用最简洁的代码讲解此模式，只要理解了上述这个简单的例子，你就知道代理模式是怎么一回事了。我们在客户端和 Person 类之间新增了一个中间件 PersonProxy，这个类就叫做代理类，他实现了和 Person 类一模一样的行为。</p>
<blockquote>
<p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</blockquote>
<p>现在这个代理类还看不出任何意义，我们来模拟一下工作中的需求。在实际工作中，我们可能会遇到这样的需求：在网络请求前后，分别打印将要发送的数据和接收到数据作为日志信息。此时我们就可以新建一个网络请求的代理类，让它代为处理网络请求，并在代理类中打印这些日志信息。</p>
<p>新建网络请求接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHttp</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String sendData)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String receivedData)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建 Http 请求工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHttp</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String sendData)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"网络请求中..."</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String receivedData)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"网络请求完成。"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建 Http 代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHttp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpUtil httpUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpProxy</span><span class="hljs-params">(HttpUtil httpUtil)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpUtil = httpUtil;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String sendData)</span> </span>&#123;<br>        httpUtil.request(sendData);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String receivedData)</span> </span>&#123;<br>        httpUtil.onSuccess(receivedData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，和我们上述吃饭睡觉的代码是一模一样的，现在我们在 HttpProxy 中新增打印日志信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHttp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpUtil httpUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpProxy</span><span class="hljs-params">(HttpUtil httpUtil)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpUtil = httpUtil;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String sendData)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"发送数据:"</span> + sendData);<br>        httpUtil.request(sendData);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String receivedData)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"收到数据:"</span> + receivedData);<br>        httpUtil.onSuccess(receivedData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        HttpUtil httpUtil = <span class="hljs-keyword">new</span> HttpUtil();<br>        HttpProxy proxy = <span class="hljs-keyword">new</span> HttpProxy(httpUtil);<br>        proxy.request(<span class="hljs-string">"request data"</span>);<br>        proxy.onSuccess(<span class="hljs-string">"received result"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">发送数据:request data<br>网络请求中...<br>收到数据:received result<br>网络请求完成。<br></code></pre></td></tr></table></figure>

<p>这就是代理模式的一个应用，除了 <strong>打印日志</strong>，它还可以用来做<strong>权限管理</strong>。读者看到这里可能已经发现了，这个代理类看起来和装饰模式的 FilterInputStream 一模一样，但两者的目的不同，装饰模式是为了 <strong>增强功能或添加功能</strong>，代理模式主要是为了<strong>加以控制</strong>。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>上例中的代理被称之为静态代理，动态代理与静态代理的原理一模一样，只是换了一种写法。使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否需要加以控制。用伪代码表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProxy</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpUtil httpUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpProxy</span><span class="hljs-params">(HttpUtil httpUtil)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpUtil = httpUtil;<br>    &#125;<br><br>    <span class="hljs-comment">// 假设调用 httpUtil 的任意方法时，都要通过这个方法间接调用, methodName 表示方法名，args 表示方法中传入的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">visit</span><span class="hljs-params">(String methodName, Object[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">"request"</span>)) &#123;<br>            <span class="hljs-comment">// 如果方法名是 request，打印日志，并调用 request 方法，args 的第一个值就是传入的参数</span><br>            System.out.println(<span class="hljs-string">"发送数据:"</span> + args[<span class="hljs-number">0</span>]);<br>            httpUtil.request(args[<span class="hljs-number">0</span>].toString());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">"onSuccess"</span>)) &#123;<br>            <span class="hljs-comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法，args 的第一个值就是传入的参数</span><br>            System.out.println(<span class="hljs-string">"收到数据:"</span> + args[<span class="hljs-number">0</span>]);<br>            httpUtil.onSuccess(args[<span class="hljs-number">0</span>].toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>伪代码看起来还是很简单的，实现起来唯一的难点就是<strong>怎么让 httpUtil 调用任意方法时</strong>，<strong>都通过一个方法间接调用</strong>。这里需要用到反射技术，不了解反射技术也没有关系，不妨把它记做固定的写法。实际的动态代理类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> HttpUtil httpUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IHttp <span class="hljs-title">getInstance</span><span class="hljs-params">(HttpUtil httpUtil)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpUtil = httpUtil;<br>        <span class="hljs-keyword">return</span> (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 httpUtil 的任意方法时，都要通过这个方法调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"request"</span>)) &#123;<br>            <span class="hljs-comment">// 如果方法名是 request，打印日志，并调用 request 方法</span><br>            System.out.println(<span class="hljs-string">"发送数据:"</span> + args[<span class="hljs-number">0</span>]);<br>            result = method.invoke(httpUtil, args);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"onSuccess"</span>)) &#123;<br>            <span class="hljs-comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法</span><br>            System.out.println(<span class="hljs-string">"收到数据:"</span> + args[<span class="hljs-number">0</span>]);<br>            result = method.invoke(httpUtil, args);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先看 getInstance 方法，Proxy.newProxyInstance 方法是 Java 系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的 ClassLoader，第二个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的目的：<strong>调用被代理类的任意方法时</strong>，<strong>都通过一个方法间接调用</strong>。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个目的。</p>
<p>第三个参数是 InvocationHandler 接口，这个接口中只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br></code></pre></td></tr></table></figure>

<p>那么不用猜就知道，现在我们调用被代理类 httpUtil 的任意方法时，都会通过这个 invoke 方法调用了。invoke 方法中，第一个参数我们暂时用不上，第二个参数 method 就是调用的方法，使用 method.getName() 可以获取到方法名，第三个参数是调用 method 方法需要传入的参数。本例中无论 request 还是 onSuccess 都只有一个 String 类型的参数，对应到这里就是 args[0]。返回的 Object 是 method 方法的返回值，本例中都是无返回值的。</p>
<p>我们在 invoke 方法中判断了当前调用方法的方法名，如果现在调用的方法是 request，那么打印请求参数，并使用这一行代码继续执行当前方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">result = method.invoke(httpUtil, args);<br></code></pre></td></tr></table></figure>

<p>这就是 <strong>反射调用函数</strong> 的写法，如果不了解可以记做固定写法，想要了解的同学可以看之前的这篇文章：**<a href="https://zhuanlan.zhihu.com/p/86293659" target="_blank" rel="noopener">详解面试中常考的 Java 反射机制</a>**。虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。</p>
<p>如果现在调用的方法是 onSuccess，那么打印接收到的数据，并反射继续执行当前方法。</p>
<p>修改客户端验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        HttpUtil httpUtil = <span class="hljs-keyword">new</span> HttpUtil();<br>        IHttp proxy = <span class="hljs-keyword">new</span> HttpProxy().getInstance(httpUtil);<br>        proxy.request(<span class="hljs-string">"request data"</span>);<br>        proxy.onSuccess(<span class="hljs-string">"received result"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，输出与之前一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">发送数据:request data<br>网络请求中...<br>收到数据:received result<br>网络请求完成。<br></code></pre></td></tr></table></figure>

<p>动态代理本质上与静态代理没有区别，它的好处是<strong>节省代码量</strong>。比如被代理类有 20 个方法，而我们只需要控制其中的两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就需要将另外的 18 个方法也写出来，非常繁琐。这就是动态代理的优势所在。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理模式、适配器模式、装饰器模式很像，只是目的不同。</p>
<ul>
<li><p>代理模式：在不改变原始接口的条件下，为原始类控制访问、新增一些业务无关的功能。控制和管理对对象的访问。</p>
</li>
<li><p>适配器模式：将不兼容的接口转换为可兼容的接口。（一种以修正为目的的设计模式）。</p>
</li>
<li><p>装饰器模式：是对原始类的功能进行增强，支持多个装饰类的嵌套增强。不改变接口，但加入责任。</p>
</li>
<li><p>外观模式：将一群对象包装起来以简化其接口。让接口更简单，提供子系统的一个简化接口</p>
</li>
<li><p>组合模式，其实就是一个类中调用另一个类。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="category-chain-item">设计模式</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="print-no-link">#设计模式</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>02-设计模式之结构型模式</div>
      <div>https://flepeng.github.io/设计模式-02-设计模式之结构型模式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年3月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86-Python-%E5%85%BC%E8%81%8C/" title="Python 兼职">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Python 兼职</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="01-设计模式之构建型模式">
                        <span class="hidden-mobile">01-设计模式之构建型模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
