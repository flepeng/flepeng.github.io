

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="Python 编码规范 点评：企业的 Python 编码规范基本上是参照PEP-8或谷歌开源项目风格指南来制定的，后者还提到了可以使用 Lint 工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下 Python 编码的注意事项。  PE8 规范  默认使用 UTF-8，甚至 ASCII 作为编码方式。  不要在一句代码中 import 多个库。  使用 4">
<meta property="og:type" content="article">
<meta property="og:title" content="01-Python 基础">
<meta property="og:url" content="https://flepeng.github.io/interview-20-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E7%B1%BB-21-Python-01-Python-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="Python 编码规范 点评：企业的 Python 编码规范基本上是参照PEP-8或谷歌开源项目风格指南来制定的，后者还提到了可以使用 Lint 工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下 Python 编码的注意事项。  PE8 规范  默认使用 UTF-8，甚至 ASCII 作为编码方式。  不要在一句代码中 import 多个库。  使用 4">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.484Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>01-Python 基础 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="01-Python 基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-08-08 00:00" pubdate>
          2020年8月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          94 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">01-Python 基础</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Python-编码规范"><a href="#Python-编码规范" class="headerlink" title="Python 编码规范"></a>Python 编码规范</h2><blockquote>
<p>点评：企业的 Python 编码规范基本上是参照<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP-8</a>或<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/" target="_blank" rel="noopener">谷歌开源项目风格指南</a>来制定的，后者还提到了可以使用 Lint 工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下 Python 编码的注意事项。</p>
</blockquote>
<p>PE8 规范</p>
<ol>
<li><p>默认使用 UTF-8，甚至 ASCII 作为编码方式。</p>
</li>
<li><p>不要在一句代码中 import 多个库。</p>
</li>
<li><p>使用 4 个空格而不是 tab 键进行缩进。</p>
</li>
<li><p>每行长度不能超过 79。</p>
</li>
<li><p>使用空行来间隔函数和类，以及函数内部的大块代码。</p>
</li>
<li><p>必要时候，在每一行下写注释。</p>
</li>
<li><p>使用文档注释，写出函数注释。</p>
</li>
<li><p>在类中总是使用 self 来作为默认。</p>
</li>
<li><p>尽量不要使用魔法方法。</p>
</li>
<li><p>换行可以使用反斜杠，最好使用圆括号。</p>
</li>
<li><p>不要将多句语句写在同一行。<code>if/for/while</code> 语句中，即使执行语句只有一句，也必须另起一行。</p>
</li>
<li><p>空格的使用：</p>
<ul>
<li>在操作符和逗号之后使用空格，但是不要在括号内部使用。</li>
<li>各种右括号前不要加空格。</li>
<li>函数的左括号前不要加空格。如 <code>Func(1)</code>。</li>
<li>序列的左括号前不要加空格。如 <code>list[2]</code>。</li>
<li>逗号、冒号、分号前不要加空格。  </li>
<li>操作符左右各加一个空格，不要为了对齐增加空格。</li>
<li>函数默认参数使用的赋值符左右省略空格。</li>
</ul>
</li>
<li><p>命名类和函数：</p>
<ul>
<li>使用 <code>PascalCase(大驼峰)</code> 来命名类。eg：<code>StudentInfo</code>、<code>UserInfo</code>。</li>
<li>使用 <code>snake_case(蛇形命名法)</code> 来命名函数和方法，类属性（方法和变量）。eg: <code>max_limit</code>。</li>
</ul>
</li>
<li><p>使用大写命名常量。</p>
</li>
<li><p>变量命名规范：</p>
<ul>
<li>以字母，数字，下划线任由结合。</li>
<li>不能命名太长，不使用拼音，中文。</li>
<li>不能以数字开头。</li>
<li>不能用 Python 关键字。</li>
</ul>
</li>
</ol>
<h2 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h2><h3 id="Python-数据类型"><a href="#Python-数据类型" class="headerlink" title="Python 数据类型"></a>Python 数据类型</h3><h4 id="字符串、列表、元组、字典常用的方法-★★★★★"><a href="#字符串、列表、元组、字典常用的方法-★★★★★" class="headerlink" title="字符串、列表、元组、字典常用的方法 ★★★★★"></a>字符串、列表、元组、字典常用的方法 ★★★★★</h4><p>参考链接：<a href="https://blog.csdn.net/fenglepeng/article/details/103587293" target="_blank" rel="noopener" title="Python 之数据类型">Python 之数据类型</a></p>
<ul>
<li><p>字符串：</p>
<ol>
<li>字符串用单引号(‘’)或双引号(“”)括起来。</li>
<li>字符串不可变。</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vim">索引，切片，加<br><span class="hljs-keyword">find</span>：通过元素找索引，可切片，找不到返回 -<span class="hljs-number">1</span>。 ★★★<br><span class="hljs-built_in">index</span>：通过元素找索引，不可切片，找不到报错。 ★★★<br><span class="hljs-keyword">split</span>：由字符串分割成列表，默认按空格分割。   ★★★<br><br>captalize：首字母大写，其他字母小写。<br>upper：全大写。<br>lower：全小写。<br>title：每个单词的首字母大写。<br>swapcase：大小写翻转。<br>startswith：判断以什么为开头，可以切片，整体概念。<br>endswith：判断以什么为结尾，可以切片，整体概念。<br><br>strip：默认去掉两侧空格。                    ★★★<br>lstrip，rstrip：去掉左边或者右边的空格。 <br><span class="hljs-keyword">center</span>：居中，默认空格。<br><span class="hljs-built_in">count</span>：统计元素的个数，可以切片，若没有返回 <span class="hljs-number">0</span>。   <br>expandtabs：将一个 <span class="hljs-keyword">tab</span> 键变成 <span class="hljs-number">8</span> 个空格，如果 <span class="hljs-keyword">tab</span> 前面的字符长度不足 <span class="hljs-number">8</span> 个，则补全 <span class="hljs-number">8</span> 个。<br>replace(old,<span class="hljs-keyword">new</span>,次数)：替换。<br><br>isdigit：字符串由字母或数字组成。    ★★★<br>isalpha：字符串只由字母组成。        ★★★<br>isalnum：字符串只由数字组成。        ★★★<br><br><span class="hljs-keyword">for</span> i in str：循环。                 ★★★<br></code></pre></td></tr></table></figure>
</li>
<li><p>列表：</p>
<ol>
<li>List 写在方括号之间 <code>[]</code>，元素用逗号隔开。</li>
<li>和字符串一样，list 可以被索引和切片。</li>
<li>List 可以使用 <code>+</code> 操作符进行拼接。</li>
<li>List 中的元素是可以改变的。</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">索引，切片，加，乘，检查成员。<br>增加：<br>    <span class="hljs-keyword">append</span>：在后面添加。   ★★★<br>    <span class="hljs-keyword">insert</span>：按照索引添加。 ★★★<br>    expend：迭代着添加。<span class="hljs-keyword">e</span><span class="hljs-variable">g:list</span>.<span class="hljs-built_in">extend</span>(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。<br>删除：<br>    <span class="hljs-keyword">pop</span>：删除 <span class="hljs-keyword">list</span> 最后一个值并返回。★★★<br>    <span class="hljs-keyword">pop</span>(<span class="hljs-built_in">index</span>)：按照索引删除。       ★★★<br>    <span class="hljs-built_in">remove</span>：可以按照元素去删除。<br>    clear：清空列表。<br>    del：<span class="hljs-number">1</span>、可以按照索引去删除；<span class="hljs-number">2</span>、切片；<span class="hljs-number">3</span>、步长（隔着删）。<br>改：<span class="hljs-number">1</span>、索引；<span class="hljs-number">2</span>、切片：先删除，再迭代着添加。<br><span class="hljs-keyword">list</span>.<span class="hljs-built_in">count</span>(obj)：统计某个元素在列表中出现的次数。<br><span class="hljs-keyword">list</span>.<span class="hljs-built_in">index</span>(obj)：从列表中找出某个值第一个匹配项的索引位置。<br><span class="hljs-keyword">list</span>.<span class="hljs-built_in">reverse</span>()：反向列表中元素。<br><span class="hljs-keyword">list</span>.<span class="hljs-keyword">sort</span>([func])：对原列表进行排序。 ★★★<br></code></pre></td></tr></table></figure>
</li>
<li><p>元组</p>
<ol>
<li>与字符串一样，元组的元素不能修改。<ul>
<li>如果元素中有可变元素，可变元素可修改。<code>(0, [], 3)[1].append(2)</code></li>
</ul>
</li>
<li>元组也可以被索引和切片，方法和 list 一样。</li>
<li>注意构造包含 0 或 1个 元素的元组的特殊语法规则。</li>
<li>元组也可以使用 <code>+</code> 操作符进行拼接。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmp</span><span class="hljs-params">(tuple1, tuple2)</span></span>：比较两个元组元素。<br><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(tuple)</span></span>：计算元组元素个数。<br><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(tuple)</span></span>：返回元组中元素最大值。<br><span class="hljs-function"><span class="hljs-title">min</span><span class="hljs-params">(tuple)</span></span>：返回元组中元素最小值。<br><span class="hljs-function"><span class="hljs-title">tuple</span><span class="hljs-params">(seq)</span></span>：将列表转换为元组。<br></code></pre></td></tr></table></figure>
</li>
<li><p>字典：</p>
<ol>
<li>字典无序（不能索引）。</li>
<li>字典是键值对，唯一一个映射数据类型。</li>
<li>字典的键必须是可哈希的不可变类型。在同一个字典中，键(key)必须是唯一的。</li>
<li>创建空字典使用 <code>{ }</code> 或者 <code>dict()</code></li>
<li>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keys： 输出所有的键。       ★★★<br>valus：输出所有的值。       ★★★<br>items：输出所有的键值对。   ★★★<br>clear：清空字典。<br><span class="hljs-built_in">del</span>：删除键值对，<span class="hljs-built_in">del</span> 的键如果没有则报错，eg:<span class="hljs-built_in">del</span> dic[<span class="hljs-string">"name"</span>]。<br><span class="hljs-built_in">pop</span>：删除键值对，<span class="hljs-built_in">pop</span> 根据 <span class="hljs-built_in">key</span> 删除键值对，并返回对应的值，如果没有 <span class="hljs-built_in">key</span> 则返回默认返回值，eg:dic.<span class="hljs-built_in">pop</span>(<span class="hljs-string">"a"</span>,'无<span class="hljs-built_in">key</span>默认返回值')。<br>popitem：随机删键值对。<br>update：改。               ★★★<br><span class="hljs-built_in">get</span>：查，没有对应键时不会报错，没有可以返回设定的返回值。★★★<br></code></pre></td></tr></table></figure></li>
<li><p>集合</p>
<ol>
<li>集合是一个无序不重复元素的序列。</li>
<li>可以使用大括号 <code>{ }</code> 或者 <code>set()</code> 函数创建集合，创建一个空集合必须用 <code>set()</code> 而不是 <code>{ }</code>，因为 <code>{ }</code> 是用来创建一个空字典的。</li>
<li><strong>同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误。</strong></li>
</ol>
</li>
</ul>
<h4 id="列举布尔值为-False-的常见值-★★★"><a href="#列举布尔值为-False-的常见值-★★★" class="headerlink" title="列举布尔值为 False 的常见值 ★★★"></a>列举布尔值为 False 的常见值 ★★★</h4><p><code>0, &#39;&#39;, {}, [], (), set(), False, 不成立的表达式, None 等</code></p>
<ul>
<li>数值只有 0 视为 False，其余数值（包括小数、负数、复数）均视为 True。</li>
<li>字符串只有空字符串视为 False，其余（包括空格、制表、换行、回车等空白符，也包括字符串 <code>&#39;False&#39;</code>）均视为 True。</li>
</ul>
<h4 id="常用字符串格式化哪几种"><a href="#常用字符串格式化哪几种" class="headerlink" title="常用字符串格式化哪几种"></a>常用字符串格式化哪几种</h4><ol>
<li><p>占位符%: <code>%d</code> 表示那个位置是整数；<code>%f</code> 表示浮点数；<code>%s</code> 表示字符串。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'Hello,%s'</span> % <span class="hljs-string">'Python'</span>)  <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'Hello,%d%s%.2f'</span> % (666, <span class="hljs-string">'Python'</span>, 9.99)) # 打印：Hello,666Python10.00<br></code></pre></td></tr></table></figure>
</li>
<li><p>format</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">res</span>=<span class="hljs-string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(<span class="hljs-string">'egon'</span>,<span class="hljs-number">18</span>,<span class="hljs-string">'male'</span>)     <span class="hljs-comment"># egon 18 male  </span><br><span class="hljs-attr">res</span>=<span class="hljs-string">'&#123;1&#125; &#123;0&#125; &#123;1&#125;'</span>.format(<span class="hljs-string">'egon'</span>,<span class="hljs-number">18</span>,<span class="hljs-string">'male'</span>)  <span class="hljs-comment"># 18 egon 18  </span><br><span class="hljs-attr">res</span>=<span class="hljs-string">'&#123;name&#125; &#123;age&#125; &#123;sex&#125;'</span>.format(sex=<span class="hljs-string">'male'</span>,name=<span class="hljs-string">'egon'</span>,age=<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="Python-可变类型和不可变类型-★★★"><a href="#Python-可变类型和不可变类型-★★★" class="headerlink" title="Python 可变类型和不可变类型 ★★★"></a>Python 可变类型和不可变类型 ★★★</h4><ul>
<li>可变数据类型：列表、字典、可变集合。</li>
<li>不可变数据类型：数字、字符串、元组、不可变集合、布尔。</li>
</ul>
<h4 id="字典和集合的区别-★★★"><a href="#字典和集合的区别-★★★" class="headerlink" title="字典和集合的区别 ★★★"></a>字典和集合的区别 ★★★</h4><p>字典是一系列由键（key）和值（value）配对组成的元素的集合。</p>
<p>在 Python3.7+，字典被确定为有序（在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的。其长度大小可变，元素可以任意地删减和改变。</p>
<p>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。</p>
<p>而集合和字典基本相同，唯一的区别，就是<strong>集合没有键和值的配对，是一系列无序的、唯一的元素组合</strong>。集合可以进行交集、并集、补集等操作。</p>
<p><strong>字典和集合的相同点：</strong></p>
<ul>
<li>字典和集合的键和值都可以为混合类型。比如，键可以是 int，str 等类型。</li>
<li>均有 key 值，且 key 值不重复。</li>
<li>不可放入可变的对象，否则无法保证<strong>内部值不重复</strong>。</li>
<li>有初始值后，均可重新赋值。</li>
<li>想要判断一个元素在不在字典或集合内，可以用 <code>value in dict/set</code> 来判断。</li>
<li>除了创建和访问，字典和集合也同样支持增加、删除、更新等操作。</li>
<li>在大量数据中查找或匹配元素时，最好将数据存为字典 or 集合。</li>
</ul>
<p><strong>字典和集合的不同点</strong></p>
<ul>
<li>字典访问可以直接索引键，如果不存在，就会抛出异常。也可以使用 <code>get(key, default)</code> 函数， 如果键不存在，可以返回一个默认值。</li>
<li>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。</li>
<li>字典有 value，每个 key 对应一个 value，集合没有 value。</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">d = &#123;<span class="hljs-string">'b'</span>: 1, <span class="hljs-string">'a'</span>: 2, <span class="hljs-string">'c'</span>: 10&#125;<br><br><span class="hljs-comment"># 将字典按照键排序</span><br>d_sorted_by_key = sorted(d.items(), <span class="hljs-attribute">key</span>=lambda x:x[0])<br><span class="hljs-comment"># 将字典按照值排序</span><br>d_sorted_by_value = sorted(d.items(), <span class="hljs-attribute">key</span>=lambda x:x[1])<br><span class="hljs-builtin-name">print</span>(d_sorted_by_key)      # [(<span class="hljs-string">'a'</span>, 2), (<span class="hljs-string">'b'</span>, 1), (<span class="hljs-string">'c'</span>, 10)]<br><span class="hljs-builtin-name">print</span>(d_sorted_by_value)    # [(<span class="hljs-string">'b'</span>, 1), (<span class="hljs-string">'a'</span>, 2), (<span class="hljs-string">'c'</span>, 10)]<br><br>s = &#123;1, 4, 6, 2&#125;<br><span class="hljs-comment"># 对集合进行排序</span><br><span class="hljs-builtin-name">print</span>(sorted(s))            # [1, 2, 4, 6]<br></code></pre></td></tr></table></figure>

<p><strong>字典和集合的性能对比</strong></p>
<p>字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="列举常见的内置函数"><a href="#列举常见的内置函数" class="headerlink" title="列举常见的内置函数"></a>列举常见的内置函数</h4><ul>
<li><p><code>abs()</code>：返回数字的绝对值。</p>
</li>
<li><p><code>map()</code>：根据函数对指定序列做映射，函数接收两个参数，一个是函数，一个是可迭代对象，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 list 返回。 ★★★<br>返回值：<br>Python2 返回列表。<br>Python3 返回迭代器。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 例子<span class="hljs-number">1</span>：<br>def mul(x):<br>    <span class="hljs-keyword">return</span> x*x<br>n = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>res = list(map(mul,n))<br>print(res)         # [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><br># 例子<span class="hljs-number">2</span>：abs()  返回数字的绝对值  <br>ret = map(abs,[<span class="hljs-number">-1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-7</span>])  <br>print(list(ret))    # [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>filter()</code>：接收一个函数 <code>f()</code> 和一个 <code>list()</code>，这个函数 <code>f()</code> 的作用是对每个元素进行判断，返回 True 或 False，根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。★★★</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">def is_odd(x):  <br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>  <br>v=list(filter(is_odd, [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>]))  <br>print(v)      # [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">17</span>]<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>map</code> 与 <code>filter</code> 总结</p>
<ul>
<li>相同点：<br>参数: 都是一个函数名 + 可迭代对象。<br>返回值: 都是返回可迭代对象。</li>
<li>区别：<br><code>filter</code> 是做筛选的，结果还是原来就在可迭代对象中的项。<br><code>map</code> 是对可迭代对象中每一项做操作的，结果不一定是原来就在可迭代对象中的项。</li>
</ul>
</li>
<li><p><code>zip()</code>：拉链函数，用于将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表迭代器。<br>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lsl">print(<span class="hljs-type">list</span>(zip([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],['a','b'])))    # [(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, 'a'), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, 'b')]<br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>zipped = zip(a,b)     # 打包为元组的列表  [(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br>zip(a,c)              # 元素个数与最短的列表一致  [(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br>zip(*zipped)          # 与 zip 相反，可理解为解压，返回二维矩阵式  [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)]<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>reduce()</code>：函数会对参数序列中元素进行累积，函数将一个数据集合(链表、元组等)中的所有数据进行下列操作。<br>注意：Python3 已经将 <code>reduce()</code> 从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 <code>reduce()</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br>def add(x,y):<br>    <span class="hljs-keyword">return</span> x + y<br><br>print(reduce(add,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))  #  <span class="hljs-number">15</span><br>print(reduce(lambda x, y: x+y, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))  # <span class="hljs-number">15</span><br>print(reduce(add,range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)))  #  <span class="hljs-number">5050</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="pass-的作用"><a href="#pass-的作用" class="headerlink" title="pass 的作用"></a><code>pass</code> 的作用</h4><p>pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</p>
<h4 id="arg-和-kwarg-作用-★★★★★"><a href="#arg-和-kwarg-作用-★★★★★" class="headerlink" title="*arg 和 **kwarg 作用 ★★★★★"></a><code>*arg</code> 和 <code>**kwarg</code> 作用 ★★★★★</h4><ul>
<li><code>*args</code> 位置参数。可以接收 0 个或任意多个参数，当不确定调用者会传入多少个位置参数时，就可以使用可变参数，它会将传入的参数打包成一个元组。</li>
<li><code>**kwargs</code> 关键字参数。可以接收用 <code>参数名=参数值</code> 的方式传入的参数，传入的参数的会打包成一个字典。</li>
</ul>
<p>位置参数一定要放在关键字前面。定义函数时如果同时使用 <code>*args</code> 和 <code>**kwargs</code>，那么函数可以接收任意参数。</p>
<h4 id="is-和-的区别-★★★"><a href="#is-和-的区别-★★★" class="headerlink" title="is 和 == 的区别 ★★★"></a><code>is</code> 和 <code>==</code> 的区别 ★★★</h4><ul>
<li><p><code>==</code> 比较两边的数值是否相等，即内存地址可以不一样，内容一样就可以了。默认会调用对象的 <code>__eq__()</code> 方法。</p>
</li>
<li><p><code>is</code> 比较两边的内存地址是否相等。如果内存地址相等，那么这两边其实是指向同一个内存地址。可以说如果内存地址相同，那么值肯定相同，但是如果值相同，内存地址不一定相同。</p>
</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">a = <span class="hljs-string">"lishi"</span><br>str1 = <span class="hljs-string">"li"</span><br>str2 = <span class="hljs-string">"shi"</span><br>str3 = str1 + str2  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">"a == str3"</span>,a == str3)    <span class="hljs-comment"># a == str3 True        == 只需要内容相等  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"a is str3"</span>,a <span class="hljs-keyword">is</span> str3)    <span class="hljs-comment"># a is str3 False       is 需要内存地址相等  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"id(a)"</span>,id(a))            <span class="hljs-comment"># id(a) 38565848  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"id(str3)"</span>,id(str3))      <span class="hljs-comment"># id(str3) 39110280</span><br></code></pre></td></tr></table></figure>

<p>在比较的时候会受到 代码块的缓存机制和不同代码块的小地址池的 影响，详情请参考 <a href="https://blog.csdn.net/fenglepeng/article/details/128731432" target="_blank" rel="noopener">Python 之代码块和小数据池</a></p>
<h4 id="如何在函数中设置一个全局变量-★★★"><a href="#如何在函数中设置一个全局变量-★★★" class="headerlink" title="如何在函数中设置一个全局变量 ★★★"></a>如何在函数中设置一个全局变量 ★★★</h4><p>Python 中的 <code>global</code> 语句是被用来声明全局变量的。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">x = <span class="hljs-number">2</span>  <br>def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>:  </span><br>    <span class="hljs-keyword">global</span> x  <br>    x = <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">return</span> x  <br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>  </span><br>print(x)  <span class="hljs-meta"># 1</span><br></code></pre></td></tr></table></figure>


<h4 id="isinstance-作用以及应用场景"><a href="#isinstance-作用以及应用场景" class="headerlink" title="isinstance 作用以及应用场景"></a><code>isinstance</code> 作用以及应用场景</h4><p><code>isinstance(对象，类)</code> 判断这个对象是不是这个类或者这个类的子类的实例化，类似 <code>type()</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 判断 a 属不属于 A 这个类（可以判断到祖宗类）  <br><span class="hljs-keyword">class</span> <span class="hljs-symbol">A:</span><br>    <span class="hljs-symbol">pass</span><br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">B</span>(<span class="hljs-symbol">A</span>):<br>    <span class="hljs-symbol">pass</span>  <br>    <br><span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()<br><span class="hljs-symbol">b</span> = <span class="hljs-symbol">B</span>()<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">b,<span class="hljs-symbol">A</span></span>)) # ===<span class="hljs-symbol">True</span>  判断到祖宗类<br><br># 任何与 <span class="hljs-symbol">object</span> 都是 <span class="hljs-symbol">True</span>，内部都继承 <span class="hljs-symbol">object</span><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">A:</span><br>    <span class="hljs-symbol">pass</span><br><span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">a,<span class="hljs-symbol">object</span></span>))  #  <span class="hljs-symbol">True</span><br></code></pre></td></tr></table></figure>

<p><code>isinstance()</code> 与 <code>type()</code> 区别：  </p>
<ul>
<li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li>
<li>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 2  <br><span class="hljs-builtin-name">print</span>(isinstance(a,int))   # <span class="hljs-literal">True</span>  <br><span class="hljs-builtin-name">print</span>(isinstance(a,str))   # <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># type() 与 isinstance() 区别  </span><br>class A:  <br>    pass  <br>class B(A):  <br>    pass<br><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">"isinstance"</span>,isinstance(A(),A))    # isinstance <span class="hljs-literal">True</span>  <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">"type"</span>,type(A())  == A)            #<span class="hljs-built_in"> type </span><span class="hljs-literal">True</span><br><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'isinstance'</span>,isinstance(B(),A) )   # isinstance <span class="hljs-literal">True</span>  <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'type'</span>,type(B()) == A)             #<span class="hljs-built_in"> type </span><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>


<h3 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h3><h4 id="三元运算写法和应用场景-★★★"><a href="#三元运算写法和应用场景-★★★" class="headerlink" title="三元运算写法和应用场景 ★★★"></a>三元运算写法和应用场景 ★★★</h4><ul>
<li>语法：<code>条件成立时的结果 if 条件 else 条件不成立时的结果</code> 例：<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">result = '<span class="hljs-keyword">gt</span>' <span class="hljs-keyword">if</span> <span class="hljs-number">1</span>&gt;<span class="hljs-number">3</span> <span class="hljs-keyword">else</span> '<span class="hljs-keyword">lt</span>'<br><span class="hljs-keyword">print</span>(result)       <span class="hljs-meta"># lt</span><br></code></pre></td></tr></table></figure></li>
<li>理解：如果条件为真，把 if 前面的值赋值给变量，否则把 else 后面的值赋值给变量。</li>
<li>应用场景：简化 if 语句。</li>
</ul>
<h4 id="lambda-表达式格式以及应用场景"><a href="#lambda-表达式格式以及应用场景" class="headerlink" title="lambda 表达式格式以及应用场景"></a>lambda 表达式格式以及应用场景</h4><p>Lambda 表达式（函数）也叫匿名函数，它是用一行代码就能实现的功能简单的小型函数。Python 中的 Lambda 函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写 <code>return</code> 关键字。Lambda 函数因为没有名字，所以也不会跟其他函数发生命名冲突的问题。</p>
<p>应用场景：<strong>Lambda 函数最主要的用途是把一个函数传入另一个高阶函数（如 Python 内置的 <code>filter</code>、<code>map</code>、<code>sort</code> 等）中来为函数做解耦合，增强函数的灵活性和通用性</strong>。</p>
<p>语法：<code>函数名 = lambda 参数1,参数2,参数n：返回值</code></p>
<ul>
<li>参数可以有多个，用逗号隔开。</li>
<li>匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值。 </li>
<li>返回值和正常的函数一样可以是任意数据类型。</li>
</ul>
<p>下面通过使用 <code>filter</code> 和 <code>map</code> 函数，实现了从列表中筛选出奇数并求平方构成新列表的操作，因为用到了高阶函数，过滤和映射数据的规则都是函数的调用者通过另外一个函数传入的，因此 <code>filter</code> 和 <code>map</code> 函数没有跟特定的过滤和映射数据的规则耦合在一起。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">items = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">19</span>]<br>items = list(map(<span class="hljs-keyword">lambda</span> x: x ** <span class="hljs-number">2</span>, filter(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span>, items)))<br>print(items)    <span class="hljs-comment"># [25, 49, 361]</span><br></code></pre></td></tr></table></figure>

<p><strong>扩展</strong>：用列表推导式来实现上面的代码会更加简单明了，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">items = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">19</span>]<br>items = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> items <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span>]<br>print(items)    <span class="hljs-comment"># [25, 49, 361]</span><br></code></pre></td></tr></table></figure>


<h4 id="说一下-namedtuple-的用法和作用。"><a href="#说一下-namedtuple-的用法和作用。" class="headerlink" title="说一下 namedtuple 的用法和作用。"></a>说一下 <code>namedtuple</code> 的用法和作用。</h4><blockquote>
<p>点评：Python 标准库的 <code>collections</code> 提供了很多有用的数据结构，这些内容并不是每个开发者都清楚。此外，<code>deque</code> 也是一个非常有用但又经常被忽视的类，还有 <code>Counter</code>、<code>OrderedDict</code>、<code>defaultdict</code>、<code>UserDict</code> 等类。</p>
</blockquote>
<p>在使用面向对象编程语言的时候，定义类是最常见的一件事情，有的时候，我们会用到只有属性没有方法的类，这种类的对象通常只用于组织数据，并不能接收消息，所以我们把这种类称为数据类或者退化的类，就像 C 语言中的结构体那样。我们并不建议使用这种退化的类，在 Python 中可以用 <code>namedtuple</code>（命名元组）来替代这种类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Card = namedtuple(<span class="hljs-string">'Card'</span>, (<span class="hljs-string">'suite'</span>, <span class="hljs-string">'face'</span>))<br>card1 = Card(<span class="hljs-string">'红桃'</span>, <span class="hljs-number">13</span>)<br>card2 = Card(<span class="hljs-string">'草花'</span>, <span class="hljs-number">5</span>)<br>print(<span class="hljs-string">f'<span class="hljs-subst">&#123;card1.suite&#125;</span><span class="hljs-subst">&#123;card1.face&#125;</span>'</span>)<br>print(<span class="hljs-string">f'<span class="hljs-subst">&#123;card2.suite&#125;</span><span class="hljs-subst">&#123;card2.face&#125;</span>'</span>)<br></code></pre></td></tr></table></figure>

<p>命名元组与普通元组一样是不可变容器，一旦将数据存储在 <code>namedtuple</code> 的顶层属性中，数据就不能再修改了，也就意味着对象上的所有属性都遵循 <strong>一次写入，多次读取</strong> 的原则。和普通元组不同的是，命名元组中的数据有访问名称，可以通过名称而不是索引来获取保存的数据，不仅在操作上更加简单，代码的可读性也会更好。</p>
<p>命名元组的本质就是一个类，所以它还可以作为父类创建子类。除此之外，命名元组内置了一系列的方法，例如，可以通过 <code>_asdict()</code> 方法将命名元组处理成字典，也可以通过 <code>_replace()</code> 方法创建命名元组对象的浅拷贝。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class MyCard(Card):<br>    <br>    def show(self):<br>        faces = [<span class="hljs-string">''</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'10'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'K'</span>]<br>        return f<span class="hljs-string">'&#123;self.suite&#125;&#123;faces[self.face]&#125;'</span><br><br><br><span class="hljs-builtin-name">print</span>(Card)    # &lt;class <span class="hljs-string">'__main__.Card'</span>&gt;<br>card3 = MyCard(<span class="hljs-string">'方块'</span>, 12)<br><span class="hljs-builtin-name">print</span>(card3.show())    # 方块Q<br><span class="hljs-builtin-name">print</span>(dict(card1._asdict()))    # &#123;<span class="hljs-string">'suite'</span>: <span class="hljs-string">'红桃'</span>, <span class="hljs-string">'face'</span>: 13&#125;<br><span class="hljs-builtin-name">print</span>(card2._replace(<span class="hljs-attribute">suite</span>=<span class="hljs-string">'方块'</span>))    # Card(<span class="hljs-attribute">suite</span>=<span class="hljs-string">'方块'</span>, <span class="hljs-attribute">face</span>=5)<br></code></pre></td></tr></table></figure>

<p>总而言之，命名元组能更好的组织数据结构，让代码更加清晰和可读，在很多场景下是元组、字典和数据类的替代品。在需要创建占用空间更少的不可变类时，命名元组就是很好的选择。</p>
<h3 id="是否使用过-functools-中的函数？其作用是什么？★★★"><a href="#是否使用过-functools-中的函数？其作用是什么？★★★" class="headerlink" title="是否使用过 functools 中的函数？其作用是什么？★★★"></a>是否使用过 functools 中的函数？其作用是什么？★★★</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于修复装饰器</span><br><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deco</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">    @functools.wraps(func)  # 加在最内层函数正上方</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@deco</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""哈哈哈哈"""</span><br>    x = <span class="hljs-number">10</span><br>    print(<span class="hljs-string">'from index'</span>)<br> <br>print(index.__name__)<br>print(index.__doc__)<br> <br><span class="hljs-comment"># 加 @functools.wraps</span><br><span class="hljs-comment"># index</span><br><span class="hljs-comment"># 哈哈哈哈</span><br> <br><span class="hljs-comment"># 不加 @functools.wraps</span><br><span class="hljs-comment"># wrapper</span><br><span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure>


<h3 id="异常处理写法以及如何主动抛出异常-★★★"><a href="#异常处理写法以及如何主动抛出异常-★★★" class="headerlink" title="异常处理写法以及如何主动抛出异常 ★★★"></a>异常处理写法以及如何主动抛出异常 ★★★</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 异常处理 except</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">temp_convert</span><span class="hljs-params">(var)</span>:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> int(var)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> Argument:<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"参数没有包含数字%s"</span>%Argument)<br> <br><span class="hljs-comment"># 调用函数</span><br>temp_convert(<span class="hljs-string">"xyz"</span>)<br><span class="hljs-comment"># 以10为基数的int()的无效文字:“xyz”</span><br><br><span class="hljs-comment"># 主动曝出异常：raise</span><br><span class="hljs-comment"># raise [Exception [, args [, traceback]]]</span><br><span class="hljs-comment">#       Exception 是异常的类型，可以自己定义；args 是自已提供的异常参数。</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Networkerror</span><span class="hljs-params">(RuntimeError)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, arg)</span>:</span><br>        self.args = arg<br><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> Networkerror(<span class="hljs-string">"Bad hostname"</span>)<br><span class="hljs-keyword">except</span> Networkerror <span class="hljs-keyword">as</span> e:<br>    print(e.args)<br></code></pre></td></tr></table></figure>


<h4 id="with-statement-是什么"><a href="#with-statement-是什么" class="headerlink" title="with statement 是什么"></a>with statement 是什么</h4><p>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的 <strong>清理</strong> 操作以释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(<span class="hljs-string">"a.file"</span>, <span class="hljs-string">"r"</span>) <span class="hljs-keyword">as</span> f:<br>    pass<br></code></pre></td></tr></table></figure>


<h4 id="断言和应用场景"><a href="#断言和应用场景" class="headerlink" title="断言和应用场景"></a>断言和应用场景</h4><p>断言：条件成立（布尔值为True）时继续往下执行，否则抛出异常。</p>
<p>一般用于：满足某个条件之后，才能执行，否则抛出异常。</p>
<p>语法：<code>assert  判断条件  如果为 False，报错内容</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写API的时候，继承GenericAPIView</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericAPIView</span><span class="hljs-params">(views.APIView)</span>:</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    Base class for all other generic views.</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-comment"># You'll need to either set these attributes,</span><br>    <span class="hljs-comment"># or override `get_queryset()`/`get_serializer_class()`.</span><br>    <span class="hljs-comment"># If you are overriding a view method, it is important that you call</span><br>    <span class="hljs-comment"># `get_queryset()` instead of accessing the `queryset` property directly,</span><br>    <span class="hljs-comment"># as `queryset` will get evaluated only once, and those results are cached</span><br>    <span class="hljs-comment"># for all subsequent requests.</span><br>    queryset = <span class="hljs-literal">None</span><br>    serializer_class = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># If you want to use object lookups other than pk, set 'lookup_field'.</span><br>    <span class="hljs-comment"># For more complex lookup requirements override `get_object()`.</span><br>    lookup_field = <span class="hljs-string">'pk'</span><br>    lookup_url_kwarg = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># The filter backend classes to use for queryset filtering</span><br>    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS<br><br>    <span class="hljs-comment"># The style to use for queryset pagination.</span><br>    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_queryset</span><span class="hljs-params">(self)</span>:</span><br><br>        <span class="hljs-keyword">assert</span> self.queryset <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>, (<br>            <span class="hljs-string">"'%s' should either include a `queryset` attribute, "</span><br>            <span class="hljs-string">"or override the `get_queryset()` method."</span><br>            % self.__class__.__name__<br>        )<br><br>        queryset = self.queryset<br>        <span class="hljs-keyword">if</span> isinstance(queryset, QuerySet):<br>            <span class="hljs-comment"># Ensure queryset is re-evaluated on each request.</span><br>            queryset = queryset.all()<br>        <span class="hljs-keyword">return</span> queryset<br></code></pre></td></tr></table></figure>


<h3 id="Python-特性"><a href="#Python-特性" class="headerlink" title="Python 特性"></a>Python 特性</h3><h4 id="Python3-和-Python2-的区别-★★★"><a href="#Python3-和-Python2-的区别-★★★" class="headerlink" title="Python3 和 Python2 的区别 ★★★"></a>Python3 和 Python2 的区别 ★★★</h4><p>参考：<a href="https://blog.csdn.net/fenglepeng/article/details/103585262" target="_blank" rel="noopener">Python2 和 Python3 的区别</a></p>
<h4 id="Python-递归的最大层数"><a href="#Python-递归的最大层数" class="headerlink" title="Python 递归的最大层数"></a>Python 递归的最大层数</h4><p>Python 中默认的递归层数约为 998 左右(会报错) 和计算机性能有关系。</p>
<h4 id="Python-中变量的作用域"><a href="#Python-中变量的作用域" class="headerlink" title="Python 中变量的作用域"></a>Python 中变量的作用域</h4><p>Python 中有四种作用域，分别是局部作用域（<strong>L</strong>ocal）、嵌套作用域（<strong>E</strong>mbedded）、全局作用域（<strong>G</strong>lobal）、内置作用域（<strong>B</strong>uilt-in），搜索一个标识符时，会按照<strong>LEGB</strong>的顺序进行搜索，如果所有的作用域中都没有找到这个标识符，就会引发 <code>NameError</code> 异常。</p>
<h3 id="参数陷阱"><a href="#参数陷阱" class="headerlink" title="参数陷阱"></a>参数陷阱</h3><p><code>def func(a,b=[])</code> 这种写法有什什么坑？</p>
<p>函数传参为列表陷阱，列表是可变数据类型，可能会在函数执行过程中修改 list 里面的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a,b=[])</span>:</span><br>    b.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(a,b)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a=2)</span>  # 2 [1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(2)</span>    # 2 [1, 1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(2)</span>    # 2 [1, 1, 1]</span><br></code></pre></td></tr></table></figure>

<p>函数的默认参数是一个 list 当第一次执行的时候实例化了一个 list，第二次执行还是用第一次执行的时候实例化的地址存储，所以三次执行的结果就是 <code>[1, 1, 1]</code> 想每次执行只输出 <code>[1]</code>，默认参数应该设置为 None。</p>
<h3 id="简述-深浅拷贝及其实现方法和应用场景-★★★★★"><a href="#简述-深浅拷贝及其实现方法和应用场景-★★★★★" class="headerlink" title="简述 深浅拷贝及其实现方法和应用场景 ★★★★★"></a>简述 深浅拷贝及其实现方法和应用场景 ★★★★★</h3><p>在 Python 的赋值语句中，如 <code>a = 1</code>，赋值的其实是元素的内存地址。赋值分为以下几种情况：</p>
<ul>
<li>赋值的是值，如 <code>a = 1</code>。Python 会创建一个新的对象，并把对象的内存地址返回给变量。</li>
<li>赋值的是其他变量，如 <code>b = a</code>。简单来说就是对于同一个对象，增加一个别名。原理就是将一个对象的地址赋值给一个变量，使得变量指向该内存地址。这里要分两种情况讨论：<ul>
<li>如果赋的值是不可变数据类型（如 int、str 等）：当修改 b 的值时，不会影响 a 的值。</li>
<li>如果赋的值是可变数据类型（如 dict、tuple 等）：当对 b 中子对象的值进行修改时，因为 a 和 b 有着相同的内存地址，a 的值也会被修改，比如当 列表a 拷贝到了列表b，如果修改 列表b 里的元素，会把 原列表a 的元素也修改了，这会产生难以预测的后果，所以需要深浅拷贝。</li>
</ul>
</li>
</ul>
<p><strong>深浅拷贝</strong></p>
<ul>
<li>浅拷贝：重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用。</li>
<li>深拷贝：重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一层的情况：</span><br><span class="hljs-keyword">import</span> copy<br> <br><span class="hljs-comment"># 浅拷贝</span><br>li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>li2 = li1.copy()<br>li1.append(<span class="hljs-number">4</span>)<br>print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, 4] [1, 2, 3]</span><br><span class="hljs-comment"># 深拷贝</span><br>li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>li2 = copy.deepcopy(li1)<br>li1.append(<span class="hljs-number">4</span>)<br>print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, 4] [1, 2, 3]</span><br><br><span class="hljs-comment"># 多层的情况：</span><br><span class="hljs-keyword">import</span> copy<br> <br><span class="hljs-comment"># 浅拷贝 指向共有的地址</span><br>li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">6</span>]<br>li2 = li1.copy()<br>li1[<span class="hljs-number">3</span>].append(<span class="hljs-number">7</span>)<br>print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5, 7], 6]</span><br><span class="hljs-comment"># 深拷贝 重指向</span><br>li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">6</span>]<br>li2 = copy.deepcopy(li1)<br>li1[<span class="hljs-number">3</span>].append(<span class="hljs-number">7</span>)<br>print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5], 6]</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：这个题目出现的频率非常高，但是就题而言没有什么技术含量，因此在回答的时候一定要让你的答案能够超出面试官的预期。除了答出这个浅拷贝和深拷贝的区别，尽量说出深拷贝的时候可能遇到的两大问题，还要说出 Python 标准库对浅拷贝和深拷贝的支持，然后可以说说列表、字典如何实现拷贝操作以及如何通过序列化和反序列的方式实现深拷贝，最后还可以提到设计模式中的原型模式以及它在项目中的应用。</p>
</blockquote>
<p>浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。</p>
<p>深拷贝可能会遇到两个问题：</p>
<ul>
<li>一是：一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝。</li>
<li>二是：深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。</li>
</ul>
<p>Python 通过 <code>copy</code> 模块中的 <code>copy</code> 和 <code>deepcopy</code> 函数来实现浅拷贝和深拷贝操作，其中 <code>deepcopy</code> 可以通过 <code>memo</code> 字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过 <code>copyreg</code> 模块的 <code>pickle</code> 函数来定制指定类型对象的拷贝行为。</p>
<p><code>deepcopy</code> 函数的本质其实就是对象的一次序列化和一次反序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，我们可以使用 <code>pickle</code> 模块的 <code>dumps</code> 和 <code>loads</code> 来做到，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pickle<br><br>my_deep_copy = <span class="hljs-keyword">lambda</span> obj: pickle.loads(pickle.dumps(obj))<br></code></pre></td></tr></table></figure>

<p>列表的切片操作 <code>[:]</code> 相当于实现了列表对象的浅拷贝，而字典的 <code>copy</code> 方法可以实现字典对象的浅拷贝。</p>
<p>对象拷贝其实是更为快捷的创建对象的方式。在 Python 中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。</p>
<p>在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。</p>
<p>在 Python 中，我们可以通过元类的方式来实现原型模式，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> copy<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeMeta</span><span class="hljs-params">(type)</span>:</span><br>    <span class="hljs-string">"""实现原型模式的元类"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(cls, *args, **kwargs)</span>:</span><br>        super().__init__(*args, **kwargs)<br>        <span class="hljs-comment"># 为对象绑定clone方法来实现对象拷贝</span><br>        cls.clone = <span class="hljs-keyword">lambda</span> self, is_deep=<span class="hljs-literal">True</span>: copy.deepcopy(self) <span class="hljs-keyword">if</span> is_deep <span class="hljs-keyword">else</span> copy.copy(self)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(metaclass=PrototypeMeta)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>p1 = Person()<br>p2 = p1.clone()                 <span class="hljs-comment"># 深拷贝</span><br>p3 = p1.clone(is_deep=<span class="hljs-literal">False</span>)    <span class="hljs-comment"># 浅拷贝</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/338797138" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/338797138</a></p>
</blockquote>
<h3 id="简述-生成器、迭代器、可迭代对象以及应用场景-★★★★★"><a href="#简述-生成器、迭代器、可迭代对象以及应用场景-★★★★★" class="headerlink" title="简述 生成器、迭代器、可迭代对象以及应用场景 ★★★★★"></a>简述 生成器、迭代器、可迭代对象以及应用场景 ★★★★★</h3><ul>
<li><p>迭代器：含有 <code>__iter__</code> 和 <code>__next__</code> 方法的对象。</p>
</li>
<li><p>生成器：生成器是迭代器的一种，是自己写的，调动 <code>next</code> 把函数变成迭代器。生成器有两种：</p>
<ul>
<li>生成器函数：包含了 <code>yield</code> 关键字的函数就叫做生成器函数。</li>
<li>生成器表达式：生成器表达式和列表推导式差不多，我们只需要包列表推导式的 <code>[]</code> 改为 <code>()</code>，这样就是一个生成器表达式了。<ol>
<li>列表推导式与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存</li>
<li>生成器表达式是按需计算（或称惰性求值，延迟计算）需要的时候才计算</li>
<li>列表推导式是立即返回值</li>
</ol>
</li>
</ul>
<p>应用场景：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>、<span class="hljs-built_in">range</span>/xrange<br>- py2：<span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>) 会立即创建，xrange(<span class="hljs-number">1000000</span>) 生成器<br>- <span class="hljs-keyword">py3</span>：<span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>) 生成器<br><br><span class="hljs-number">2</span>、redis 获取值 hscan_iter 用到了  <br>conn = Redis(...)<br><br>def hscan_iter(self, name, <span class="hljs-keyword">match</span>=None, <span class="hljs-built_in">count</span>=None):  <br>    <span class="hljs-built_in">cursor</span> = <span class="hljs-string">'0'</span>  <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">cursor</span> != <span class="hljs-number">0</span>:  <br>        # 去redis中获取数据：<span class="hljs-number">12</span>  <br>        # <span class="hljs-built_in">cursor</span>，下一次取的位置  <br>        # data：本地获取的<span class="hljs-number">12</span>条数数据  <br>        <span class="hljs-built_in">cursor</span>, data = self.hscan(name, <span class="hljs-built_in">cursor</span>=<span class="hljs-built_in">cursor</span>,<span class="hljs-keyword">match</span>=<span class="hljs-keyword">match</span>, <span class="hljs-built_in">count</span>=<span class="hljs-built_in">count</span>)  <br>        <span class="hljs-keyword">for</span> item in data.<span class="hljs-built_in">items</span>():  <br>             yield item<br><br><span class="hljs-number">3</span>、stark 组件<br>def <span class="hljs-built_in">index</span>(request):<br>    data = [  <br>        &#123;<span class="hljs-string">'k1'</span>:<span class="hljs-number">1</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'alex'</span>&#125;,<br>        &#123;<span class="hljs-string">'k1'</span>:<span class="hljs-number">2</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'老男孩'</span>&#125;,<br>        &#123;<span class="hljs-string">'k1'</span>:<span class="hljs-number">3</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'小男孩'</span>&#125;,<br>    ]  <br>    new_data = []<br>    <span class="hljs-keyword">for</span> item in dat<span class="hljs-variable">a:</span><br>        item[<span class="hljs-string">'email'</span>] = <span class="hljs-string">"xxx@qq.com"</span><br>        new_data.<span class="hljs-keyword">append</span>(item)<br><br>    <span class="hljs-keyword">return</span> render(request,<span class="hljs-string">'xx.html'</span>,&#123;<span class="hljs-string">'data'</span>:new_data&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>可迭代对象：一个类内部实现 <code>__iter__</code> 方法（不包含 <code>__next__</code> 方法），且调用该方法后返回一个迭代器。<br>应用场景：</p>
<ul>
<li>wtforms 中对 form 对象进行循环时候，显示 form 中包含的所有字段。  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class LoginForm(Form):  <br>    name = simple.StringField(  <br>        <span class="hljs-attribute">label</span>=<span class="hljs-string">'用户名'</span>,  <br>        validators=[  <br>            validators.DataRequired(<span class="hljs-attribute">message</span>=<span class="hljs-string">'用户名不能为空.'</span>),  <br>            validators.Length(<span class="hljs-attribute">min</span>=6, <span class="hljs-attribute">max</span>=18, <span class="hljs-attribute">message</span>=<span class="hljs-string">'用户名长度必须大于%(min)d且小于%(max)d'</span>)  <br>        ],<br>        <span class="hljs-attribute">widget</span>=widgets.TextInput(),  <br>        render_kw=&#123;<span class="hljs-string">'class'</span>: <span class="hljs-string">'form-control'</span>&#125;  <br>    )  <br>    pwd = simple.PasswordField(  <br>        <span class="hljs-attribute">label</span>=<span class="hljs-string">'密码'</span>,  <br>        validators=[  <br>            validators.DataRequired(<span class="hljs-attribute">message</span>=<span class="hljs-string">'密码不能为空.'</span>),  <br>            validators.Length(<span class="hljs-attribute">min</span>=8, <span class="hljs-attribute">message</span>=<span class="hljs-string">'用户名长度必须大于%(min)d'</span>),  <br>            validators.Regexp(<span class="hljs-attribute">regex</span>=<span class="hljs-string">"^(?=.\*\[a-z\])(?=.\*\[A-Z\])(?=.\*\\d)(?=.\*\[<span class="hljs-variable">$@</span>$!%\*?&amp;\])\[A-Za-z\\d<span class="hljs-variable">$@</span>$!%\*?&amp;\]&#123;8,&#125;"</span>,  <br>                              <span class="hljs-attribute">message</span>=<span class="hljs-string">'密码至少8个字符，至少1个大写字母，1个小写字母，1个数字和1个特殊字符'</span>)<br>        ],  <br>        <span class="hljs-attribute">widget</span>=widgets.PasswordInput(),  <br>        render_kw=&#123;<span class="hljs-string">'class'</span>: <span class="hljs-string">'form-control'</span>&#125;  <br>    )<br><br>form = LoginForm()  <br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> form:  <br>    <span class="hljs-builtin-name">print</span>(item)<br></code></pre></td></tr></table></figure></li>
<li>列表、字典、元组。当时用 for 循环时，for 会自动调用 <code>__iter__()</code> 方法，将列表、字典、元组变为迭代器。</li>
<li><strong>判断一个可迭代对象里是否有值，可以使用 <code>for i in iter</code> 的方式</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>迭代器是实现了迭代器协议的对象。跟其他编程语言不同，Python 没有用于定义协议或表示约定的关键字，像 <code>interface</code>、<code>protocol</code> 这些单词并不在 Python 的关键字列表中。<br>Python 通过魔法方法来表示约定，也就是我们所说的协议，而 <code>__next__</code> 和 <code>__iter__</code> 这两个魔法方法就代表了迭代器协议。可以通过 <code>for i in</code> 循环从迭代器对象中取出值，也可以使用 <code>next</code> 函数取出迭代器对象中的下一个值。生成器是迭代器的语法升级版本，可以用更为简单的代码来实现一个迭代器。</p>
</blockquote>
<p>生成斐波那契数列的迭代器代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span><span class="hljs-params">(object)</span>:</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, num)</span>:</span><br>        self.num = num<br>        self.a, self.b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        self.idx = <span class="hljs-number">0</span><br>   <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">if</span> self.idx &lt; self.num:<br>            self.a, self.b = self.b, self.a + self.b<br>            self.idx += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> self.a<br>        <span class="hljs-keyword">raise</span> StopIteration()<br></code></pre></td></tr></table></figure>

<p>如果用生成器的语法来改写上面的代码，代码会简单优雅很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(num)</span>:</span><br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(num):<br>        a, b = b, a + b<br>        <span class="hljs-keyword">yield</span> a<br></code></pre></td></tr></table></figure>


<h4 id="简述-yield-和-yield-from-关键字"><a href="#简述-yield-和-yield-from-关键字" class="headerlink" title="简述 yield 和 yield from 关键字"></a>简述 <code>yield</code> 和 <code>yield from</code> 关键字</h4><p><strong><code>yield</code></strong></p>
<ol>
<li>函数中使用 <code>yield</code>，可以把该函数变成生成器。一个函数如果是生成一个数组，就必须把数据存储在内存中，如果使用生成器，则在调用的时候才生成数据，可以节省内存。  </li>
<li>生成器方法调用时，不会立即执行。需要调用 <code>next()</code> 或者使用 <code>for</code> 循环来执行。</li>
</ol>
<p><strong><code>yield from</code></strong></p>
<ol>
<li>为了让生成器能简易的在其他生成器中直接调用，就产生了 <code>yield from</code>。</li>
</ol>
<h3 id="反射以及应用场景"><a href="#反射以及应用场景" class="headerlink" title="反射以及应用场景"></a>反射以及应用场景</h3><p>反射就是把字符映射到实例的变量或实例的方法，然后该方法可以被调用或修改。</p>
<p>反射的本质(核心)：基于字符串的事件驱动，利用字符串的形式去操作对象&#x2F;模块中成员(方法、属性)。</p>
<p>反射的四个重要方法：</p>
<ol>
<li><code>getattr</code>：获取对象属性&#x2F;对象方法。</li>
<li><code>hasattr</code>：判断对象是否有对应的属性及方法。</li>
<li><code>delattr</code>：删除指定的属性。</li>
<li><code>setattr</code>：为对象设置内容。</li>
</ol>
<p>应用场景：Django 中的 CBV 就是基于反射实现的。</p>
<h3 id="闭包-★★★"><a href="#闭包-★★★" class="headerlink" title="闭包 ★★★"></a>闭包 ★★★</h3><p>如果 bar 函数在 foo 函数的代码块中定义，那么我们称 bar 是 foo 的内部函数。在 bar 的局部作用域中可以直接访问 foo 局部作用域中定义的 m、n 变量。简单的说，这种 <strong>内部函数可以使用外部函数变量的行为，就叫闭包</strong>。</p>
<p>判断闭包函数的方法：该方法是否含有 <code>__closure__</code>，如果含有 <code>__closure__</code> 则说明是闭包函数。</p>
<p>闭包的意义与应用：延迟计算。</p>
<p>使用闭包的时候需要注意，闭包会使得函数中创建的对象不会被垃圾回收，可能会导致很大的内存开销，所以<strong>闭包一定不能滥用</strong>。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span><br>    m=<span class="hljs-number">3</span><br>    n=<span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span><br>        a=<span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> m+n+a<br>    <span class="hljs-keyword">return</span> bar<br>    <br>bar =  foo()  <br>bar()        <span class="hljs-comment"># 12</span><br></code></pre></td></tr></table></figure>


<h3 id="装饰器-★★★★★"><a href="#装饰器-★★★★★" class="headerlink" title="装饰器 ★★★★★"></a>装饰器 ★★★★★</h3><p>含义：装饰器本质就是函数，为其他函数添加附加功能，能够在不修改原函数代码的基础上，在执行前后进行定制操作，是闭包函数的一种应用。</p>
<p>作用：装饰器可以用来装饰类或函数，为其提供额外的能力，属于设计模式中的<strong>装饰器模式（和代理模式很像，只是目的不同）</strong>。</p>
<p>原则：不修改被修饰函数的代码，不修改被修饰函数的调用方式。</p>
<p>场景：</p>
<ul>
<li>Flask 大量使用装饰器：路由系统、<code>flask before_request</code>、csrf、认证。</li>
<li>Django 内置认证。</li>
<li>Django 缓存。</li>
<li>无参装饰器在用户登录认证中常见。</li>
<li>插入日志、性能测试、事物处理、缓存、权限验证等，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</li>
</ul>
<p>简单装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(func)</span>:</span>  <br><span class="hljs-meta">    @functools.wraps(func)  # 不改变原函数属性  </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(*args, **kwargs)</span>:</span>  <br>        <span class="hljs-comment"># 执行函数前</span><br>        a = func(*args, **kwargs)  <br>        <span class="hljs-comment"># 执行函数后</span><br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-comment"># 1. 执行 wapper 函数，并将被装饰的函数当做参数。wapper(老index)  </span><br><span class="hljs-comment"># 2. 将第一步的返回值，重新赋值给新 index = wapper(老index)  </span><br><span class="hljs-meta">@wrapper    #index=wrapper(index)  </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">(x)</span>:</span>  <br>   <span class="hljs-keyword">return</span> x+<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>

<p>带参装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">record_time</span><span class="hljs-params">(canshu)</span>:</span><br>    <span class="hljs-string">"""可以参数化的装饰器"""</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">        @wraps(func)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>            start = time()<br>            result = func(*args, **kwargs)<br>            print(canshu)<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorate<br></code></pre></td></tr></table></figure>

<p>用类实现装饰器。类有 <code>__call__</code> 魔术方法，该类对象就是可调用对象，可以当做装饰器来使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Record</span>:</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, func)</span>:</span><br>        <br><span class="hljs-meta">        @wraps(func)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>            start = time()<br>            result = func(*args, **kwargs)<br>            print(<span class="hljs-string">f'<span class="hljs-subst">&#123;func.__name__&#125;</span>执行时间: <span class="hljs-subst">&#123;time() - start&#125;</span>秒'</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <br>        <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure>

<p>装饰器的运行顺序</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift">@wrapper1    # <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">wrapper1</span><span class="hljs-params">(<span class="hljs-keyword">func</span>)</span></span> 即 <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">wrapper2</span><span class="hljs-params">(inner2)</span></span> --&gt; f1 = inner2 --&gt; 打印 <span class="hljs-keyword">in</span> wrapper1 --&gt; <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">inner1</span></span><br><span class="hljs-function">@<span class="hljs-title">wrapper2</span>    # 2 <span class="hljs-title">func</span> = <span class="hljs-title">wrapper2</span><span class="hljs-params">(<span class="hljs-keyword">func</span>)</span></span> 即 <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">wrapper2</span><span class="hljs-params">(inner3)</span></span> --&gt; f2 = inner3 --&gt; 打印 <span class="hljs-keyword">in</span> wrapper2 --&gt; <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">inner2</span></span><br><span class="hljs-function">@<span class="hljs-title">wrapper3</span>    # 1 <span class="hljs-title">func</span> = <span class="hljs-title">wrapper3</span><span class="hljs-params">(<span class="hljs-keyword">func</span>)</span></span> --&gt; f3 = <span class="hljs-function"><span class="hljs-keyword">func</span> --&gt; 打印<span class="hljs-title">in</span> <span class="hljs-title">wrapper3</span> --&gt; <span class="hljs-title">func</span> = <span class="hljs-title">inner3</span></span><br><span class="hljs-function"><span class="hljs-title">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>:  # 先执行离被装饰函数最近的那个装饰器<br>    <span class="hljs-built_in">print</span>('<span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">func</span>')</span><br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">in</span> <span class="hljs-string">inner1</span><br><span class="hljs-attr">in</span> <span class="hljs-string">inner2</span><br><span class="hljs-attr">in</span> <span class="hljs-string">inner3</span><br><span class="hljs-attr">in</span> <span class="hljs-string">func</span><br><span class="hljs-attr">333</span><br><span class="hljs-attr">222</span><br><span class="hljs-attr">111</span><br></code></pre></td></tr></table></figure>


<h3 id="进程、线程、协程-★★★★★"><a href="#进程、线程、协程-★★★★★" class="headerlink" title="进程、线程、协程 ★★★★★"></a>进程、线程、协程 ★★★★★</h3><h4 id="进程、线程、协程的区别以及应用场景"><a href="#进程、线程、协程的区别以及应用场景" class="headerlink" title="进程、线程、协程的区别以及应用场景"></a>进程、线程、协程的区别以及应用场景</h4><ul>
<li>进程：进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</li>
<li>线程：线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度。</li>
<li>协程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。协程避免了无意义的调度，由此可以提高性能；但同时协程也失去了线程使用多 CPU 的能力。</li>
</ul>
<p>进程与线程的区别：</p>
<ol>
<li>地址空间：线程是进程内的一个执行单位，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间。</li>
<li>资源拥有：进程是资源分配和拥有的单位，同一个进程内线程共享进程的资源。</li>
<li>线程是处理器调度的基本单位，但进程不是。</li>
<li>二者均可并发执行。</li>
<li>每个独立的线程有一个程序运行的入口。</li>
</ol>
<p>协程与线程：</p>
<ol>
<li>一个线程可以有多个协程，一个进程也可以单独拥有多个协程，这样 Python 中则能使用多核 CPU。</li>
<li>线程进程都是同步机制，而协程是异步。</li>
<li>协程能保留上一次调用时的状态。</li>
</ol>
<p>多线程的优点在于多个线程可以共享进程的内存空间，所以进程间的通信非常容易实现；但是如果使用官方的 CPython 解释器，多线程受制于 GIL（全局解释器锁），并不能利用 CPU 的多核特性，这是一个很大的问题。使用多进程可以充分利用 CPU 的多核特性，但是进程间通信相对比较麻烦，需要使用 IPC 机制（管道、套接字等）。</p>
<p>多线程适合那些会花费大量时间在 I&#x2F;O 操作上，但没有太多并行计算需求且不需占用太多内存的 I&#x2F;O 密集型应用。多进程适合执行计算密集型任务（如：视频编码解码、数据处理、科学计算等）、可以分解为多个并行子任务并能合并子任务执行结果的任务，以及在内存使用方面没有任何限制且不强依赖于 I&#x2F;O 操作的任务。</p>
<blockquote>
<p>扩展：Python 中实现并发编程通常有多线程、多进程和异步编程三种选择。异步编程实现了协作式并发，通过多个相互协作的子程序的用户态切换，实现对 CPU 的高效利用，这种方式也是非常适合 I&#x2F;O 密集型应用的。</p>
</blockquote>
<h4 id="Python-中如何使用线程池和进程池"><a href="#Python-中如何使用线程池和进程池" class="headerlink" title="Python 中如何使用线程池和进程池"></a>Python 中如何使用线程池和进程池</h4><blockquote>
<p><a href="https://blog.csdn.net/fenglepeng/article/details/103986048" target="_blank" rel="noopener">https://blog.csdn.net/fenglepeng/article/details/103986048</a><br><a href="https://blog.csdn.net/fenglepeng/article/details/103974862" target="_blank" rel="noopener">https://blog.csdn.net/fenglepeng/article/details/103974862</a></p>
</blockquote>
<ul>
<li><p>进程相关的模块。</p>
<ul>
<li>multiprocessing.Process</li>
<li>multiprocessing.Lock</li>
<li>multiprocessing.Semaphore</li>
<li>multiprocessing.Event</li>
<li>multiprocessing.Queue</li>
<li>multiprocessing.Pool</li>
</ul>
</li>
<li><p>线程相关模块。<br>Python 提供了几个用于多线程编程的模块，包括 thread、threading 和 Queue 等。thread 和 threading 模块允许程序员创建和管理线程。thread 模块提供了基本的线程和锁的支持，threading 提供了更高级别、功能更强的线程管理的功能。Queue 模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。<br>避免使用 thread 模块，因为更高级别的 threading 模块更为先进，对线程的支持更为完善，而且使用 thread 模块里的属性有可能会与 threading 出现冲突；其次低级别的 thread 模块的同步原语很少(实际上只有一个)，而 threading 模块则有很多；再者，thread 模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading 模块能确保重要的子线程退出后进程才退出。<br>thread 模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而 threading 模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。</p>
<ul>
<li>threading.Thread</li>
<li>threading.RLock</li>
<li>concurrent.futures.ProcessPoolExecutor 进程池，提供异步调用</li>
<li>concurrent.futures.ThreadPoolExecutor  线程池，提供异步调用</li>
</ul>
</li>
</ul>
<p>线程池&#x2F;进程池是一种用于减少线程&#x2F;进程本身创建和销毁造成的开销的技术，属于典型的空间换时间操作。如果应用程序需要频繁的将任务派发到线程&#x2F;进程中执行，线程&#x2F;进程池就是必选项，因为创建和释放线程&#x2F;进程涉及到大量的系统底层操作，开销较大，如果能够在应用程序工作期间，将创建和释放线程&#x2F;进程的操作变成预创建和借还操作，将大大减少底层开销。</p>
<p>线程池和进程池类似，下面以线程池为例进行介绍：</p>
<ul>
<li>线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗CPU资源，但会占用少量的内存空间。</li>
<li>当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将该线程标记为已占用。</li>
<li>当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。</li>
<li>在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。</li>
</ul>
<p>基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小。</p>
<p>一般线程池都必须具备下面几个组成部分：</p>
<ol>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。</li>
<li>任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。</li>
<li>任务队列：线程池中保存等待被执行的任务的容器。</li>
</ol>
<h4 id="进程锁和线程锁的作用"><a href="#进程锁和线程锁的作用" class="headerlink" title="进程锁和线程锁的作用"></a>进程锁和线程锁的作用</h4><ul>
<li><p>线程锁：主要用来给方法、代码块加锁。<br>当某个方法或者代码块使用锁时，那么在同一时刻至多仅有一个线程在执行该段代码。<br>当有多个线程访问同一对象的加锁方法&#x2F;代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。<br>但是，其余线程是可以访问该对象中的非加锁代码块的。  </p>
</li>
<li><p>进程锁: 也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。  </p>
</li>
<li><p>分布式锁: 当多个进程不在同一个系统之中时，使用分布式锁控制多个进程对资源的访问。</p>
</li>
</ul>
<h2 id="刁钻类问题"><a href="#刁钻类问题" class="headerlink" title="刁钻类问题"></a>刁钻类问题</h2><h3 id="Python-是传值还是传引用-★★★"><a href="#Python-是传值还是传引用-★★★" class="headerlink" title="Python 是传值还是传引用 ★★★"></a>Python 是传值还是传引用 ★★★</h3><p>Python 不允许程序员选择采用传值还是传引用。Python 参数传递采用的肯定是<strong>传对象引用</strong>的方式。这种方式相当于传值和传引用的一种综合。</p>
<ul>
<li>如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值，相当于通过<strong>传引用</strong>来传递对象。</li>
<li>如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象，相当于通过<strong>传值</strong>来传递对象。</li>
</ul>
<h3 id="类和对象能不能作为字典的-key-★★★"><a href="#类和对象能不能作为字典的-key-★★★" class="headerlink" title="类和对象能不能作为字典的 key ★★★"></a>类和对象能不能作为字典的 key ★★★</h3><p>字典的 key 要求是任意不可变类型，是可 hash 的，所以一个对象和类能不能作为字典的 key，就取决于其有没有 <code>__hash__</code> 方法。Python 自带的所有类型中，除了 list、dict、set 和 tuple 之外，其余的对象都含有 <code>__hash__</code> 方法，都能当 key。</p>
<p>查看源代码可以看到 object 对象是定义了 <code>__hash__</code> 方法的，而 list、set 和 dict 都把 <code>__hash__</code> 赋值为 None 了，所以 list、dict、set 不能做字典的 key。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">object</span>:</span><br>    <span class="hljs-string">""" The most base type """</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__hash__</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span>  <span class="hljs-comment"># real signature unknown</span><br>        <span class="hljs-string">""" Return hash(self). """</span><br>        <span class="hljs-keyword">pass</span><br>  <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">list</span><span class="hljs-params">(object)</span>:</span><br>    __hash__ = <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">set</span><span class="hljs-params">(object)</span>:</span><br>    __hash__ = <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dict</span><span class="hljs-params">(object)</span>:</span><br>    __hash__ = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何读取大文件，例如内存只有-4G，如何读取一个大小为-8G-的文件？"><a href="#如何读取大文件，例如内存只有-4G，如何读取一个大小为-8G-的文件？" class="headerlink" title="如何读取大文件，例如内存只有 4G，如何读取一个大小为 8G 的文件？"></a>如何读取大文件，例如内存只有 4G，如何读取一个大小为 8G 的文件？</h3><p>很显然 4G 内存一次性加载大小为 8G 的文件是不现实的，遇到这种情况必须要考虑多次读取和分批次处理。</p>
<p>在 Python 中读取文件可以先通过 <code>open</code> 函数获取文件对象，在读取文件时，可以通过 <code>read</code> 方法的 <code>size</code> 参数指定读取的大小，也可以通过 <code>seek</code> 方法的 <code>offset</code> 参数指定读取的位置，这样就可以控制单次读取数据的字节数和总字节数。</p>
<p>除此之外，可以使用内置函数 <code>iter</code> 将文件对象处理成迭代器对象，每次只读取少量的数据进行处理，代码大致写法如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'...'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> iter(<span class="hljs-keyword">lambda</span>: file.read(<span class="hljs-number">2097152</span>), <span class="hljs-string">b''</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>在 Linux 系统上，可以通过 <code>split</code> 命令将大文件切割为小片，然后通过读取切割后的小文件对数据进行处理。例如下面的命令将名为 <code>filename</code> 的大文件切割为大小为 512M 的多个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">split -b 512m filename<br></code></pre></td></tr></table></figure>

<p>如果愿意，也可以将名为 <code>filename</code> 的文件切割为 10 个文件，命令如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">split -n 10 filename<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>扩展</strong>：外部排序跟上述的情况非常类似，由于处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。<strong>排序-归并算法</strong> 就是一种常用的外部排序策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件，然后在归并阶段将这些临时文件组合为一个大的有序文件，这个大的有序文件就是排序的结果。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
        <a href="/tags/Python/" class="print-no-link">#Python</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>01-Python 基础</div>
      <div>https://flepeng.github.io/interview-20-开发语言类-21-Python-01-Python-基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
