

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、持久化简介持久化的功能：Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次 Redis 重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。 持久化发生了什么 | 从内存到磁盘我们来考虑一下 Redis 作为一个 内存数据库 要做的关">
<meta property="og:type" content="article">
<meta property="og:title" content="03-Redis 持久化">
<meta property="og:url" content="https://flepeng.github.io/042-Redis-41-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-03-Redis-%E6%8C%81%E4%B9%85%E5%8C%96/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="一、持久化简介持久化的功能：Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次 Redis 重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。 持久化发生了什么 | 从内存到磁盘我们来考虑一下 Redis 作为一个 内存数据库 要做的关">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://flepeng.github.io/img/redis/1691418918-044b81f9ae06e5f897f5e7dd9b8fb36a.png">
<meta property="og:image" content="https://flepeng.github.io/img/redis/1691503495-6695c2940457533563515bcc77fb61b1.png">
<meta property="og:image" content="https://flepeng.github.io/img/redis/1691418918-10889a50cba9b4db27d6b95170bfc50a.png">
<meta property="og:image" content="https://flepeng.github.io/img/redis/1691503495-7d49e6cefbc28ee8df9c136b51e73df1.png">
<meta property="og:image" content="https://flepeng.github.io/img/redis/1691503495-8cc489c1373d16cb4521041ba08967b2.png">
<meta property="og:image" content="https://flepeng.github.io/img/redis/7896890-2f7887f84eaa34d9.webp">
<meta property="article:published_time" content="2020-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.365Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flepeng.github.io/img/redis/1691418918-044b81f9ae06e5f897f5e7dd9b8fb36a.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>03-Redis 持久化 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="03-Redis 持久化"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-01-01 00:00" pubdate>
          2021年1月1日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          81 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">03-Redis 持久化</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、持久化简介"><a href="#一、持久化简介" class="headerlink" title="一、持久化简介"></a>一、持久化简介</h1><p>持久化的功能：Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次 Redis 重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p>
<h2 id="持久化发生了什么-从内存到磁盘"><a href="#持久化发生了什么-从内存到磁盘" class="headerlink" title="持久化发生了什么 | 从内存到磁盘"></a>持久化发生了什么 | 从内存到磁盘</h2><p>我们来考虑一下 Redis 作为一个 <strong>内存数据库</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="/img/redis/1691418918-044b81f9ae06e5f897f5e7dd9b8fb36a.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>第一步：客户端向数据库发送 <strong>写命令</strong> (数据在客户端的内存中)</li>
<li>第二步：数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> (数据在服务器的内存中)</li>
<li>第三步：数据库 <strong>调用系统 API</strong> 将数据写入磁盘 (数据在内核缓冲区中)</li>
<li>第四步：操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控制器</strong> (数据在磁盘缓存中)</li>
<li>第五步：操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 (数据在磁盘中)</li>
</ol>
<p><strong>注意:</strong> 上面的过程其实是极度精简的，在实际的操作系统中，<strong>缓存和缓冲区</strong> 会比这多得多。</p>
<h2 id="如何尽可能保证持久化的安全"><a href="#如何尽可能保证持久化的安全" class="headerlink" title="如何尽可能保证持久化的安全"></a>如何尽可能保证持久化的安全</h2><p>如果故障仅仅涉及 <strong>软件层面(如该进程被管理员终止或程序崩溃)</strong> 并且没有接触到内核，那么在上述 <strong>第三步</strong> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果考虑 <strong>停电&#x2F; 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了 <strong>第五步</strong> 之后，才是安全的。</p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>第三、四、五步</strong>，所以我们分别来说。</p>
<ul>
<li><p>对于 <strong>第三步</strong>，Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，20 多年过去，还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, ...<span class="hljs-comment">/*,mode_t mode */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> filedes)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fname )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有现成的而且很好用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
</li>
<li><p>对于 <strong>第四步</strong>，我们知道，为了安全，操作系统不允许我们 <strong>直接操作</strong> 硬件，都需要通过 <strong>系统调用</strong> 来达到目的。</p>
<p>为了防止过慢的 I&#x2F;O 操作拖慢整个系统的运行，操作系统层面做了很多优化，譬如 <strong>写缓冲区</strong>。并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p>但是 <strong>30 秒</strong> 不是 Redis 能够承受的，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
</li>
<li><p>对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
</li>
</ul>
<p><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</p>
<h1 id="二、Redis-中的两种持久化方式"><a href="#二、Redis-中的两种持久化方式" class="headerlink" title="二、Redis 中的两种持久化方式"></a>二、Redis 中的两种持久化方式</h1><p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p>
<p>下面依次介绍RDB持久化和AOF持久化；由于Redis各个版本之间存在差异，如无特殊说明，以Redis3.0为准。</p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>RDB 持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)。RDB 是 Redis 默认的持久化方式。</p>
<p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<h3 id="RDB-触发条件"><a href="#RDB-触发条件" class="headerlink" title="RDB 触发条件"></a>RDB 触发条件</h3><p>RDB持久化的触发分为手动触发和自动触发两种。</p>
<h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p><code>save</code> 命令和 <code>bgsave</code> 命令都可以生成RDB文件。</p>
<ul>
<li><code>save</code>   命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在 Redis 服务器阻塞期间，服务器不能处理任何命令请求。</li>
<li><code>bgsave</code> 命令会fork()一个子进程，然后由子进程写入到临时文件中，持久化的过程结束之后，再用临时文件替换上次的快照文件，然后子进程退出并内存释放。<br>父进程(即Redis主进程)在fork之后继续处理请求。</li>
</ul>
<p><code>bgsave</code> 命令执行过程中，只有fork子进程时会阻塞服务器，而对于 <code>save</code> 命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用。</p>
<p>此外，在自动触发RDB持久化时，Redis 也会选择 <code>bgsave</code> 而不是 <code>save</code> 来进行持久化。</p>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>自动触发最常见的情况是在配置文件中配置 <code>save m n</code>，指定当m秒内发生n次变化时，会触发 <code>bgsave</code>，对应产生的数据文件为 dump.rdb。例如:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lsl">save <span class="hljs-number">900</span> <span class="hljs-number">1</span>       # 在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个<span class="hljs-type">key</span>发生变化，Redis就会自动触发BGSAVE命令创建快照。<br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span>      # 在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个<span class="hljs-type">key</span>发生变化，Redis就会自动触发BGSAVE命令创建快照。<br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span>    # 在<span class="hljs-number">60</span>秒(<span class="hljs-number">1</span>分钟)之后，如果至少有<span class="hljs-number">10000</span>个<span class="hljs-type">key</span>发生变化，Redis就会自动触发BGSAVE命令创建快照。<br></code></pre></td></tr></table></figure>

<p><strong><code>save m n</code> 的实现原理</strong></p>
<p>Redis 的 <code>save m n</code>，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。</p>
<ul>
<li>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。</li>
<li>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave&#x2F;save命令后，服务器状态进行了多少次修改(包括增删改)；而当save&#x2F;bgsave执行完成后，会将dirty重新置为0。<br>例如，如果Redis执行了<code>set mykey helloworld</code>，则dirty值会+1；如果执行了<code>sadd myset v1 v2 v3</code>，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。</li>
<li>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save&#x2F;bgsave的时间。</li>
</ul>
<p><code>save m n</code> 的过程：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：</p>
<ul>
<li><code>当前时间 - lastsave &gt; m</code></li>
<li><code>dirty &gt;= n</code></li>
</ul>
<h4 id="其他自动触发机制"><a href="#其他自动触发机制" class="headerlink" title="其他自动触发机制"></a>其他自动触发机制</h4><p>除了 <code>save m n</code> 以外，还有一些其他情况会触发 <code>bgsave</code>：</p>
<ul>
<li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行 <code>bgsave</code> 命令，并将rdb文件发送给从节点</li>
<li>执行shutdown命令时，自动执行rdb持久化</li>
</ul>
<h3 id="bgsave-COW-Copy-On-Write-机制"><a href="#bgsave-COW-Copy-On-Write-机制" class="headerlink" title="bgsave | COW(Copy On Write) 机制"></a>bgsave | COW(Copy On Write) 机制</h3><p><code>bgsave</code> 命令的执行流程，如下图所示:</p>
<p><img src="/img/redis/1691503495-6695c2940457533563515bcc77fb61b1.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>Redis 父进程首先判断：当前是否在执行<code>save</code>，或<code>bgsave/bgrewriteaof(重写)</code>的子进程，如果在执行则 <code>bgsave</code> 命令直接返回。<br><code>bgsave/bgrewriteaof</code> 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</p>
</li>
<li><p>父进程调用 <code>glibc</code> 的函数 <code>fork</code> 产生一个子进程，这个过程中父进程是阻塞的，Redis 不能执行来自客户端的任何命令。<br>主进程和子进程会共享内存里面的代码块和数据段，因为创建子进程的时候，子进程复制父进程的页表，但页表指向的物理内存还是一个。</p>
</li>
<li><p>父进程 <code>fork</code> 后，<code>bgsave</code> 命令返回 <code>”Background saving started”</code> 信息并不再阻塞父进程，并可以响应其他命令。</p>
<ul>
<li>如果主线程执行读操作，则主线程和 <code>bgsave</code> 进程互不影响；</li>
<li>如果主线程执行写操作，这个时候就会使用操作系统的 COW 机制来进行 <strong>数据段页面</strong> 的分离。<br>数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后 <strong>对这个复制的页面进行修改</strong>。<br>这时 <strong>子进程</strong> 相应的页面是 <strong>没有变化的</strong>，还是进程产生时那一瞬间的数据。</li>
</ul>
</li>
<li><p>子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成复制后对原有文件进行原子替换。<br>子进程做数据持久化，它 <strong>不会修改现有的内存数据结构</strong>，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。</p>
</li>
<li><p>子进程发送信号给父进程表示完成，父进程更新统计信息。</p>
</li>
</ol>
<p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化 <strong>叫「快照」的原因</strong>。</p>
<p><img src="/img/redis/1691418918-10889a50cba9b4db27d6b95170bfc50a.png" srcset="/img/loading.gif" lazyload></p>
<p>这里多说一点，<strong>为什么 fork 成功调用后会有两个返回值呢？</strong> </p>
<p>因为子进程在复制时复制了父进程的堆栈段，所以两个进程都停留在了 <code>fork</code> 函数中 (都在同一个地方往下继续”同时”执行)等待返回，所以 <strong>一次在父进程中返回子进程的 pid，另一次在子进程中返回零，系统资源不够时返回负数</strong>。 伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">pid = os.fork()<br><span class="hljs-keyword">if</span> pid &gt; <span class="hljs-number">0</span>:<br>  handle_client_request()  # 父进程继续处理客户端请求<br><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>  handle_snapshot_write()  # 子进程处理快照写磁盘<br><span class="hljs-keyword">if</span> pid &lt; <span class="hljs-number">0</span>:  <br>  # fork error<br></code></pre></td></tr></table></figure>


<h3 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h3><p>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。</p>
<p><strong>存储路径</strong></p>
<p>RDB文件的存储路径既可以在启动前通过配置文件配置，也可以通过命令动态设定。</p>
<ul>
<li>配置文件配置：dir 配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。</li>
<li>动态胚子：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为<code>config set dir {newdir}</code>和<code>config set dbfilename {newFileName}</code>。</li>
</ul>
<p><strong>RDB文件格式</strong></p>
<p>RDB文件格式如下图所示（图片来源：《Redis设计与实现》）：</p>
<p><img src="/img/redis/1691503495-7d49e6cefbc28ee8df9c136b51e73df1.png" srcset="/img/loading.gif" lazyload></p>
<p>其中各个字段的含义说明如下：</p>
<ol>
<li><code>REDIS</code>：常量，保存着”REDIS”5个字符。</li>
<li><code>db_version</code>：RDB文件的版本号，注意不是Redis的版本号。</li>
<li><code>SELECTDB 0 pairs</code>：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。</li>
<li><code>EOF</code>：常量，标志RDB文件正文内容结束。</li>
<li><code>check_sum</code>：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。</li>
</ol>
<p><strong>压缩</strong></p>
<p>Redis 默认采用 LZF 算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：</p>
<p><code>config set rdbcompression no</code></p>
<p>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。</p>
<h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p>
<p>Redis 载入 RDB文件时，会对 RDB 文件进行校验，如果文件损坏，则日志中会打印错误，Redis 启动失败。</p>
<h2 id="AOF-Append-Only-File-仅追加文件"><a href="#AOF-Append-Only-File-仅追加文件" class="headerlink" title="AOF(Append Only File - 仅追加文件)"></a>AOF(Append Only File - 仅追加文件)</h2><p>如果运行 Redis 的计算机停止运行，电源线出现故障或者 <code>kill -9</code> ，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些场景如交易，快照并不是可行的选择，所以出现了 AOF。</p>
<p><strong>AOF</strong> 非常简单：Redis 将每一个会更改 Redis 数据的命令通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。</p>
<p>当 Redis 收到客户端修改指令后，会先进行参数校验、逻辑处理，如果没问题，就 <strong>立即</strong> 将该指令文本 <strong>存储</strong> 到 AOF 日志中，也就是说，<strong>先执行指令再将日志存盘</strong>。这一点不同于 <code>MySQL</code>、<code>LevelDB</code>、<code>HBase</code> 等存储引擎，如果我们先存储日志再做逻辑处理，这样就可以保证即使宕机了，我们仍然可以通过之前保存的日志恢复到之前的数据状态，但是 <strong>Redis 为什么没有这么做呢？</strong></p>
<blockquote>
<p> 没找到特别满意的答案，引用一条来自知乎上的回答吧：</p>
<ul>
<li><strong>@缘于专注</strong> - 我甚至觉得没有什么特别的原因。仅仅是因为，由于AOF文件会比较大，为了避免写入无效指令（错误指令），必须先做指令检查？如何检查，只能先执行了。因为语法级别检查并不能保证指令的有效性，比如删除一个不存在的key。而MySQL这种是因为它本身就维护了所有的表的信息，所以可以语法检查后过滤掉大部分无效指令直接记录日志，然后再执行。</li>
<li>更多讨论参见：<a href="https://www.zhihu.com/question/342427472" target="_blank" rel="noopener">为什么Redis先执行指令，再记录AOF日志，而不是像其它存储引擎一样反过来呢？ - https://www.zhihu.com/question/342427472</a></li>
</ul>
</blockquote>
<h3 id="AOF-设置"><a href="#AOF-设置" class="headerlink" title="AOF 设置"></a>AOF 设置</h3><p>Redis 默认不开启 AOF，可以通过 appendonly 参数开启：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure>

<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always    <span class="hljs-comment"># 每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment"># 每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br>appendfsync <span class="hljs-literal">no</span>        <span class="hljs-comment"># 让操作系统决定何时进行同步</span><br></code></pre></td></tr></table></figure>

<p>当 RDB 和 AOF 两种方式同时开启时，数据恢复时，Redis 会优先选择AOF恢复。</p>
<h3 id="AOF-执行流程"><a href="#AOF-执行流程" class="headerlink" title="AOF 执行流程"></a>AOF 执行流程</h3><p>由于需要记录 Redis 的每条写命令，因此 AOF 不需要触发。AOF 的执行流程包括：</p>
<ul>
<li>命令追加(append)：将 Redis 的写命令追加到缓冲区<code>aof_buf</code>；</li>
<li>文件写入(write)和文件同步(sync)：根据不同的同步策略将 <code>aof_buf</code> 中的内容同步到硬盘；</li>
<li>文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</li>
</ul>
<h4 id="命令追加-append"><a href="#命令追加-append" class="headerlink" title="命令追加(append)"></a>命令追加(append)</h4><p>Redis 先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</p>
<p>命令追加的格式是 Redis 命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。</p>
<p>在AOF文件中，除了用于指定数据库的 select 命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。</p>
<h4 id="文件写入-write-和文件同步-sync"><a href="#文件写入-write-和文件同步-sync" class="headerlink" title="文件写入(write)和文件同步(sync)"></a>文件写入(write)和文件同步(sync)</h4><p>Redis 提供了多种 AOF 缓存区的同步文件策略，策略涉及到操作系统的 <code>write</code> 函数和 <code>fsync</code> 函数，说明如下：</p>
<p>为了提高文件写入效率，在现代操作系统中，当用户调用 <code>write</code> 函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。</p>
<p>这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</p>
<p>AOF缓存区的同步文件策略由参数 <code>appendfsync</code> 控制，各个值的含义如下：</p>
<ul>
<li><p><code>always</code>：命令写入 <code>aof_buf</code> 后立即调用系统 <code>fsync</code> 操作同步到AOF文件，<code>fsync</code> 完成后线程返回。<br>这种情况下，每次有写命令都要同步到 AOF 文件，硬盘IO成为性能瓶颈，Redis 只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。</p>
</li>
<li><p><code>no</code>：命令写入 <code>aof_buf</code> 后调用系统write操作，不对AOF文件做 <code>fsync</code> 同步；同步由操作系统负责，通常同步周期为30秒。<br>这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</p>
</li>
<li><p><code>everysec</code>：命令写入 <code>aof_buf</code> 后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<br><strong>everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。</strong></p>
</li>
</ul>
<h4 id="文件重写-rewrite"><a href="#文件重写-rewrite" class="headerlink" title="文件重写(rewrite)"></a>文件重写(rewrite)</h4><p>随着时间流逝，Redis 服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。</p>
<p>文件重写是指 <strong>定期重写AOF文件</strong>，减小AOF文件的体积。</p>
<p>需要注意的是，<strong>AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</strong></p>
<p>需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p>
<p>文件重写之所以能够压缩AOF文件，原因在于：</p>
<ul>
<li>过期的数据不再写入文件</li>
<li>无效的命令不再写入文件：如有些数据被重复设值<code>set mykey v1, set mykey v2</code>、有些数据被删除了<code>sadd myset v1, del myset</code>等等</li>
<li>多条命令可以合并为一个：如<code>sadd myset v1, sadd myset v2, sadd myset v3</code>可以合并为<code>sadd myset v1 v2 v3</code>。<br>不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。<br>这个常量在<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>中定义，不可更改，3.0版本中值是64。</li>
</ul>
<p>通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。</p>
<p><strong>文件重写的触发</strong></p>
<p>文件重写的触发，分为手动触发和自动触发：</p>
<ul>
<li><p>手动触发：直接调用<code>bgrewriteaof</code>命令，该命令的执行与<code>bgsave</code>有些类似：都是 fork 子进程进行具体的工作，且都只有在 fork 时阻塞。</p>
</li>
<li><p>自动触发：根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数，以及 <code>aof_current_size</code> 和 <code>aof_base_size</code> 状态确定触发时机。</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：执行AOF重写时，文件的最小体积，默认值为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：执行AOF重写时，当前AOF大小(即<code>aof_current_size</code>)和上一次重写时AOF大小(<code>aof_base_size</code>)的比值。</li>
</ul>
<p>其中，参数可以通过config get命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; auth 1cfbffd2-2fad<br>OK<br>127.0.0.1:6379&gt; config get auto-aof-rewrite-min-size<br>1) "auto-aof-rewrite-min-size"<br>2) "67108864"<br>127.0.0.1:6379&gt; config get auto-aof-rewrite-percentage<br>1) "auto-aof-rewrite-percentage"<br>2) "100"<br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<p>状态可以通过<code>info persistence</code>查看：</p>
<p>只有当<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</p>
</li>
</ul>
<p><strong>文件重写的流程</strong></p>
<p><img src="/img/redis/1691503495-8cc489c1373d16cb4521041ba08967b2.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>Redis 父进程首先判断当前是否存在正在执行 <code>bgsave/bgrewriteaof</code> 的子进程，如果存在则 <code>bgrewriteaof</code> 命令直接返回，如果存在 <code>bgsave</code> 命令则等 <code>bgsave</code> 执行完成后再执行。<br>前面曾介绍过，这个主要是基于性能方面的考虑。</p>
</li>
<li><p>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。</p>
</li>
<li><p>父进程fork后，<code>bgrewriteaof</code>命令返回 <code>”Background append only file rewrite started”</code> 信息并不再阻塞父进程，并可以响应其他命令。</p>
<p><strong>Redis的所有写命令依然写入AOF缓冲区，并根据 <code>appendfsync</code> 策略同步到硬盘，保证原有AOF机制的正确。</strong></p>
<p>由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。</p>
<p><strong>由于父进程依然在响应命令，因此 Redis 使用 AOF 重写缓冲区(<code>aof_rewrite_buf</code>)保存这部分数据，防止新 AOF 文件生成期间丢失这部分数据。<br>也就是说，<code>bgrewriteaof</code> 执行期间，Redis 的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewirte_buf</code> 两个缓冲区。</strong></p>
</li>
<li><p>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</p>
</li>
<li><p>子进程写完新的 AOF 文件后，向父进程发信号，父进程更新统计信息，具体可以通过 <code>info persistence</code> 查看。</p>
<p>父进程把AOF重写缓冲区(<code>aof_rewrite_buf</code>)的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</p>
<p>使用新的AOF文件替换老文件，完成AOF重写。</p>
</li>
</ol>
<p>总结一句话就是： 开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中，序列化完毕后再将操作期间发生的 <strong>增量 AOF 日志</strong> 追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了。</p>
<p>关于文件重写的流程，有两点需要特别注意：</p>
<ol>
<li>重写由父进程fork子进程进行；</li>
<li>重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了 <code>aof_rewrite_buf</code> 缓存。</li>
</ol>
<h3 id="启动时加载-1"><a href="#启动时加载-1" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。</p>
<p>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)。</p>
<p><strong>文件校验</strong></p>
<p>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</p>
<p>但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且<code>aof-load-truncated</code> 参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。</p>
<p><code>aof-load-truncated</code> 参数默认是开启的。</p>
<p><strong>伪客户端</strong></p>
<p>因为 Redis 的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；</p>
<p>因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。</p>
<h2 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h2><p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="/img/redis/7896890-2f7887f84eaa34d9.webp" srcset="/img/loading.gif" lazyload></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<h1 id="三、方案选择与常见问题"><a href="#三、方案选择与常见问题" class="headerlink" title="三、方案选择与常见问题"></a>三、方案选择与常见问题</h1><h2 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h2><p><strong>RDB持久化</strong></p>
<ul>
<li>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</li>
<li>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</li>
</ul>
<p><strong>AOF持久化</strong></p>
<ul>
<li>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</li>
</ul>
<h2 id="持久化策略选择"><a href="#持久化策略选择" class="headerlink" title="持久化策略选择"></a>持久化策略选择</h2><p>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p>
<p>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。</p>
<p>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p>
<ol>
<li><p>如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p>
</li>
<li><p>在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</p>
</li>
<li><p>但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。在这种情况下，一种可行的做法是：</p>
<ul>
<li>master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好</li>
<li>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；<br>然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。</li>
</ul>
<p>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p>
<ul>
<li>master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。</li>
<li>master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。</li>
</ul>
</li>
<li><p>异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</p>
</li>
<li><p>某厂的实践</p>
<ul>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自 己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产 生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重 写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也 减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
</li>
</ol>
<h2 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h2><p>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：</p>
<ul>
<li>当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；</li>
<li>当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；</li>
<li>以及持久化过程中的fork操作，下面详细说明。</li>
</ul>
<p>首先说明一下fork操作：</p>
<p>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父&#x2F;子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父&#x2F;子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。</p>
<p>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</p>
<p>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。</p>
<p>对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。</p>
<p>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。</p>
<h2 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h2><p>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。</p>
<p>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</p>
<p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p>
<p>AOF追加阻塞问题定位的方法：</p>
<ol>
<li><p>监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。</p>
</li>
<li><p>AOF阻塞时的Redis日志：<code>Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</code></p>
</li>
<li><p>如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9137897.html</a></li>
<li><a href="https://www.cnblogs.com/wmyskxz/p/12487505.html" target="_blank" rel="noopener">https://www.cnblogs.com/wmyskxz/p/12487505.html</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Redis/" class="category-chain-item">Redis</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Redis/" class="print-no-link">#Redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>03-Redis 持久化</div>
      <div>https://flepeng.github.io/042-Redis-41-核心概念-03-Redis-持久化/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年1月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/042-Redis-41-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-03-Redis-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="03-Redis 内存模型">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">03-Redis 内存模型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/042-Redis-41-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-04-Redis-%E4%BA%8B%E5%8A%A1/" title="04-Redis 事务">
                        <span class="hidden-mobile">04-Redis 事务</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
