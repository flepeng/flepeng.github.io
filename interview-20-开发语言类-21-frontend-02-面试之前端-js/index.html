

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="let、const、var 相关var：ES5 变量声明方式  在变量未赋值时，变量 undefined（未使用声明变量时也为 undefined） 作用域：var 的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用  let：ES6 变量声明方式  在变量未声明前直接使用会报错 作用域：let 为块作用域，通常 let 比 var 范围要小 let 禁止重复声明变量">
<meta property="og:type" content="article">
<meta property="og:title" content="02-面试之前端 js">
<meta property="og:url" content="https://flepeng.github.io/interview-20-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E7%B1%BB-21-frontend-02-%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%89%8D%E7%AB%AF-js/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="let、const、var 相关var：ES5 变量声明方式  在变量未赋值时，变量 undefined（未使用声明变量时也为 undefined） 作用域：var 的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用  let：ES6 变量声明方式  在变量未声明前直接使用会报错 作用域：let 为块作用域，通常 let 比 var 范围要小 let 禁止重复声明变量">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.486Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>02-面试之前端 js - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="02-面试之前端 js"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-08-08 00:00" pubdate>
          2020年8月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">02-面试之前端 js</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="let、const、var-相关"><a href="#let、const、var-相关" class="headerlink" title="let、const、var 相关"></a>let、const、var 相关</h2><p>var：ES5 变量声明方式</p>
<ol>
<li>在变量未赋值时，变量 undefined（未使用声明变量时也为 undefined）</li>
<li>作用域：var 的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</li>
</ol>
<p>let：ES6 变量声明方式</p>
<ol>
<li>在变量未声明前直接使用会报错</li>
<li>作用域：let 为块作用域，通常 let 比 var 范围要小</li>
<li>let 禁止重复声明变量，否则会报错；var 可以重复声明</li>
</ol>
<p>const：ES6 变量声明方式</p>
<ol>
<li>const 为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值</li>
<li>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</li>
</ol>
<h2 id="js-数据类型，区别"><a href="#js-数据类型，区别" class="headerlink" title="js 数据类型，区别"></a>js 数据类型，区别</h2><ul>
<li><p>基本数据类型：<code>Number，String，Boolean，null，undefined，symbol，bigint</code>（后两个为 ES6 新增）</p>
</li>
<li><p>引用数据类型：</p>
<ul>
<li>object，function（<strong>proto</strong> Function.prototype）</li>
<li>object：普通对象，数组对象，正则对象，日期对象，Math 数学函数对象。</li>
</ul>
</li>
<li><p>两种数据存储方式：</p>
<ul>
<li>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。</li>
<li>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
</li>
</ul>
<p>两种数据类型的区别：</p>
<ol>
<li>堆比栈空间大，栈比堆运行速度快。 </li>
<li>堆内存是无序存储，可以根据引用直接获取。</li>
<li>基础数据类型比较稳定，而且相对来说占用的内存小。</li>
<li>引用数据类型大小是动态的，而且是无限的。</li>
</ol>
<h2 id="Object-assign-的理解"><a href="#Object-assign-的理解" class="headerlink" title="Object.assign 的理解"></a>Object.assign 的理解</h2><p>作用：<code>Object.assign</code> 可以实现对象的合并。</p>
<p>语法：<code>Object.assign(target, ...sources)</code></p>
<p><strong>解析</strong>：</p>
<ol>
<li><code>Object.assign</code> 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖。</li>
<li>后续的 source 会覆盖前面的 source 的同名属性。</li>
<li><code>Object.assign</code> 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</li>
</ol>
<h2 id="constructor（构造函数）的理解"><a href="#constructor（构造函数）的理解" class="headerlink" title="constructor（构造函数）的理解"></a>constructor（构造函数）的理解</h2><p>创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。</p>
<p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。</p>
<h2 id="map-和-forEach-的区别"><a href="#map-和-forEach-的区别" class="headerlink" title="map 和 forEach 的区别"></a>map 和 forEach 的区别</h2><p>相同点：</p>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）</li>
<li>匿名函数中的 this 都是指向 window</li>
<li>只能遍历数组</li>
</ol>
<p>不同点：</p>
<ol>
<li><code>map()</code> 会分配内存空间存储新数组并返回，<code>forEach()</code> 不会返回数据。</li>
<li><code>forEach()</code> 允许 callback 更改原始数组的元素。<code>map()</code> 返回新的数组。</li>
</ol>
<h2 id="for-of-可以遍历哪些对象"><a href="#for-of-可以遍历哪些对象" class="headerlink" title="for of 可以遍历哪些对象"></a>for of 可以遍历哪些对象</h2><p><code>for..of..</code>: 它是 ES6 新增的一个遍历方法，但**只限于迭代器(iterator)**， 所以普通的对象用 <code>for..of</code> 遍历是会报错的。</p>
<p>可迭代的对象：包括 Array、Map、Set、String、TypedArray、arguments 对象等等</p>
<h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p><strong>js是动态类型语言</strong></p>
<p>静态类型语言 &amp; 动态类型语言</p>
<ul>
<li>静态类型语言：类型检查发生在编译阶段，因此除非修复错误，否则会一直编译失败</li>
<li>动态类型语言：只有在程序运行了一次的时候错误才会被发现，也就是在运行时，因此即使代码中包含了会在运行时阻止脚本正常运行的错误类型，这段代码也可以通过编译</li>
</ul>
<p><strong>js静态类型检查的方法</strong></p>
<p><strong>Flow</strong> 是 Facebook 开发和发布的一个开源的静态类型检查库，它允许你逐渐地向 JavaScript 代码中添加类型。</p>
<p><strong>TypeScript</strong> 是一个会编译为 JavaScript 的超集（尽管它看起来几乎像一种新的静态类型语言）</p>
<p><strong>使用静态类型的优势</strong></p>
<ul>
<li>可以尽早发现 bug 和错误</li>
<li>减少了复杂的错误处理</li>
<li>将数据和行为分离</li>
<li>减少单元测试的数量</li>
<li>提供了领域建模（domain modeling）工具</li>
<li>帮助我们消除了一整类bug</li>
<li>重构时更有信心</li>
</ul>
<p><strong>使用静态类型的劣势</strong></p>
<ul>
<li>代码冗长</li>
<li>需要花时间去掌握类型</li>
</ul>
<h2 id="indexof"><a href="#indexof" class="headerlink" title="indexof"></a>indexof</h2><p>语法：<code>str.indexOf(searchValue [, fromIndex])</code></p>
<p>参数：</p>
<ul>
<li><p>searchValue：要被查找的字符串值。</p>
<p>如果没有提供确切地提供字符串，<code>searchValue 会被强制设置为&quot;undefined&quot;</code>，然后在当前字符串中查找这个值。</p>
<p>举个例子：<code>&#39;undefined&#39;.indexOf()</code> 将会返回 0，因为 undefined 在位置 0 处被找到，但是 <code>&#39;undefi&#39;.indexOf()</code> 将会返回 -1 ，因为字符串 <code>&#39;undefined&#39;</code> 未被找到</p>
</li>
<li><p>fromIndex：可选</p>
<p>数字表示开始查找的位置。可以是任意整数，默认值为 0。</p>
<p>如果 fromIndex 的值小于 0，或者大于 <code>str.length</code>，那么查找分别从 0 和 str.length 开始。（译者 注：fromIndex 的值小于 0，等同于为空情况；fromIndex 的值大于或等于 str.length，那么结果会直接返回-1。）</p>
<p>举个例子：<code>&#39;hello world&#39;.indexOf(&#39;o&#39;, -5)</code> 返回4，因为它是从位置 0 处开始查找，然后 o 在位置 4 处被找到。另一方面，<code>&#39;hello world&#39;.indexOf(&#39;o&#39;, 11)</code>（或 fromIndex 填入任何大于 11 的值） 将会返回 -1，因为开始查找的位置 11 处，已经是这个字符串的结尾了。</p>
</li>
</ul>
<p>返回值：</p>
<p>查找的字符串 <code>searchValue</code> 的<strong>第一次</strong>出现的索引，如果没有找到，则返回 -1。</p>
<p>若被查找的字符串 <code>searchValue</code> 是一个空字符串，则返回 <code>fromIndex</code>。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样。</p>
<p>如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度 <code>str.length</code></p>
<p>特点：</p>
<ol>
<li>严格区分大小写</li>
<li>在使用 indexOf 检索数组时，用 <code>===</code> 去匹配，意味着会检查数据类型。</li>
</ol>
<h2 id="iframe-有什么优点、缺点"><a href="#iframe-有什么优点、缺点" class="headerlink" title="iframe 有什么优点、缺点"></a>iframe 有什么优点、缺点</h2><p>优点：</p>
<ol>
<li>iframe 能够原封不动的把嵌入的网页展现出来。</li>
<li>如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li>
<li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</li>
<li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。</li>
</ol>
<p>缺点：</p>
<ol>
<li>iframe 会阻塞主页面的 onload 事件；</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。</li>
<li>iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li>
<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。</li>
<li>很多的移动设备无法完全显示框架，设备兼容性差。</li>
<li>iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。</li>
</ol>
<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><p><strong>Web Components</strong> 总的来说是提供一整套完善的封装机制来把 Web 组件化这个东西标准化，每个框架实现的组件都统一标准地进行输入输出，这样可以更好推动组件的复用</p>
<p>包含四个部分</p>
<ol>
<li>Custom Elements</li>
<li>HTML Imports</li>
<li>HTML Templates</li>
<li>Shadow DOM</li>
</ol>
<p><strong>Custom Elements</strong></p>
<p>提供一种方式让开发者可以自定义 HTML 元素，包括特定的组成，样式和行为。支持 Web Components 标准的浏览器会提供一系列 API 给开发者用于创建自定义的元素，或者扩展现有元素。</p>
<p><strong>HTML Imports</strong></p>
<p>一种在 HTMLs 中引用以及复用其他的 HTML 文档的方式。这个 Import 很漂亮，可以简单理解为我们常见的模板中的include之类的作用</p>
<p><strong>HTML Templates</strong></p>
<p>模板</p>
<p><strong>Shadow DOM</strong></p>
<p>提供一种更好地组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响</p>
<h2 id="dva-的数据流流向是怎么样的"><a href="#dva-的数据流流向是怎么样的" class="headerlink" title="dva 的数据流流向是怎么样的"></a>dva 的数据流流向是怎么样的</h2><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 是单线程语言，所以执行肯定是按顺序执行。但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为 Lexical Environment 的 JavaScript 数据结构内的内存中。所以这些变量和函数能在它们真正被声明之前使用。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>概念</strong>：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p><strong>ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’，可通过新增命令 let 和 const 来体现。</p>
<h2 id="HashMap-和-ArrayMap-有什么区别？"><a href="#HashMap-和-ArrayMap-有什么区别？" class="headerlink" title="HashMap 和 ArrayMap 有什么区别？"></a>HashMap 和 ArrayMap 有什么区别？</h2><ol>
<li><p>查找效率。<br>HashMap 因为其根据 hashcode 的值直接算出 index，所以其查找效率是随着数组长度增大而增加的。<br>ArrayMap 使用的是二分法查找，所以当数组长度每增加一倍时，就需要多进行一次判断，效率下降。</p>
</li>
<li><p>扩容数量。<br>HashMap 初始值 16 个长度，每次扩容的时候，直接申请双倍的数组空间。<br>ArrayMap 每次扩容的时候，如果 size 长度大于 8 时申请 <code>size*1.5</code> 个长度，大于 4 小于 8 时申请 8 个，小于 4 时申请 4 个。这样比较 ArrayMap 其实是申请了更少的内存空间，但是扩容的频率会更高。因此，如果数据量比较大的时候，还是使用 HashMap 更合适，因为其扩容的次数要比 ArrayMap 少很多。</p>
</li>
<li><p>扩容效率。<br>HashMap 每次扩容的时候重新计算每个数组成员的位置，然后放到新的位置。<br>ArrayMap 则是直接使用 <code>System.arraycopy</code>，所以效率上肯定是 ArrayMap 更占优势。</p>
</li>
<li><p>内存消耗。<br>以 ArrayMap 采用了一种独特的方式，能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个 ArrayMap 的使用。<br>而 HashMap 没有这种设计。由于 ArrayMap 之缓存了长度是 4 和 8 的时候，所以如果频繁的使用到 Map，而且数据量都比较小的时候，ArrayMap 无疑是相当的是节省内存的。</p>
</li>
</ol>
<p>总结：综上所述，数据量比较小，并且需要频繁的使用 Map 存储数据的时候，推荐使用 ArrayMap。而数据量比较大的时候，则推荐使用 HashMap。</p>
<h2 id="HashMap-和-Object"><a href="#HashMap-和-Object" class="headerlink" title="HashMap 和 Object"></a>HashMap 和 Object</h2><p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>
<table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map 默认情况不包含任何键。只包含显式插入的键。</td>
<td>一个Object有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。<strong>注意:</strong> 虽然 ES5 开始可以用 <code>Object.create(null)</code> 来创建一个没有原型的对象，但是这种用法不太常见。</td>
</tr>
<tr>
<td>键的类型</td>
<td>一个 Map 的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型。</td>
<td>一个 Object 的键必须是一个 String 或是 Symbol。</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候，一个Map对象以插入的顺序返回键值。</td>
<td>一个 Object 的键是无序的注意：自ECMAScript 2015规范以来，对象_确实_保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过 size 属性获取</td>
<td>Object的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代。</td>
<td>迭代一个Object需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h2 id="javascript-中-arguments-相关的问题"><a href="#javascript-中-arguments-相关的问题" class="headerlink" title="javascript 中 arguments 相关的问题"></a>javascript 中 arguments 相关的问题</h2><p><strong>arguments</strong></p>
<p>在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js 会把所传的参数全部存到一个叫 arguments 的对象里面。它是一个<strong>类数组数据</strong></p>
<p><strong>由来</strong></p>
<p>Javascrip 中每个函数都会有一个 Arguments 对象实例 arguments，引用着函数的实参。它是寄生在 js 函数当中的，不能显式创建，arguments 对象只有函数开始时才可用</p>
<p><strong>作用</strong></p>
<p>有了 arguments 这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过 arguments 为函数加入参数</p>
<h2 id="instanceOf-原理，手动实现-function-isInstanceOf-child-Parent"><a href="#instanceOf-原理，手动实现-function-isInstanceOf-child-Parent" class="headerlink" title="instanceOf 原理，手动实现 function isInstanceOf (child, Parent)"></a>instanceOf 原理，手动实现 <code>function isInstanceOf (child, Parent)</code></h2><p>instanceof 主要作用就是判断一个实例是否属于某种类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-keyword">let</span> no = <span class="hljs-keyword">new</span> person();<br>no <span class="hljs-keyword">instanceof</span> person;  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>instanceOf 原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new_instance_of</span>(<span class="hljs-params">leftVaule, rightVaule</span>) </span>&#123; <br>    <span class="hljs-keyword">let</span> rightProto = rightVaule.prototype; <span class="hljs-comment">// 取右表达式的 prototype 值</span><br>    leftVaule = leftVaule.__proto__; <span class="hljs-comment">// 取左表达式的__proto__值</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (leftVaule === <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftVaule === rightProto) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>        &#125; <br>        leftVaule = leftVaule.__proto__ <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p>
<p>同时还要了解 js 的原型继承原理</p>
<p>我们知道每个 JavaScript 对象均有一个隐式的 proto 原型属性，而显式的原型属性是 prototype，只有 <code>Object.prototype.proto</code> 属性在未修改的情况下为 null 值</p>
<p>手动实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">L, R</span>) </span>&#123;<span class="hljs-comment">//L 表示左表达式，R 表示右表达式</span><br>    <span class="hljs-keyword">var</span> O = R.prototype;<br>    L = L.__proto__;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <br>        <span class="hljs-keyword">if</span> (L === <span class="hljs-literal">null</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        <span class="hljs-keyword">if</span> (O === L) <span class="hljs-comment">// 这里重点：当 O 严格等于 L 时，返回true </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>        L = L.__proto__; <br>    &#125; <br>&#125;<br><span class="hljs-comment">// 开始测试</span><br><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">var</span> b = &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">father</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>child.prototype = <span class="hljs-keyword">new</span> father();<br><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> child();<br><br><span class="hljs-built_in">console</span>.log(instance_of(a, <span class="hljs-built_in">Array</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(instance_of(b, <span class="hljs-built_in">Object</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(instance_of(b, <span class="hljs-built_in">Array</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(instance_of(a, <span class="hljs-built_in">Object</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(instance_of(c, Foo)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(instance_of(d, child)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(instance_of(d, father)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>


<h2 id="编码和字符集的区别"><a href="#编码和字符集的区别" class="headerlink" title="编码和字符集的区别"></a>编码和字符集的区别</h2><p><strong>参考答案：</strong></p>
<p>字符集是书写系统字母与符号的集合，而字符编码则是将字符映射为一特定的字节或字节序列，是一种规则。通常特定的字符集采用特定的编码方式（即一种字符集对应一种字符编码（例如：ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码，但Unicode不是，它采用现代的模型））</p>
<p><strong>扩展：</strong></p>
<p>字符：在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。即一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号等。</p>
<p>字符集：多个字符的集合。例如 GB2312 是中国国家标准的简体中文字符集，GB2312 收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。</p>
<p>字符编码：把字符集中的字符编码为（映射）指定集合中的某一对象（例如：比特模式、自然数序列、电脉冲），以便文本在计算机中存储和通过通信网络的传递。</p>
<h2 id="null-和-undefined-的区别，如何让一个属性变为-null"><a href="#null-和-undefined-的区别，如何让一个属性变为-null" class="headerlink" title="null 和 undefined 的区别，如何让一个属性变为 null"></a>null 和 undefined 的区别，如何让一个属性变为 null</h2><p><strong>参考答案：</strong></p>
<p>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p>
<p><strong>解析：</strong></p>
<p>undefined 的字面意思就是：未定义的值。这个值的语义是，希望 <strong>表示一个变量最原始的状态，而非人为操作的结果</strong>。这种原始状态会在以下 4 种场景中出现：</p>
<ol>
<li>声明了一个变量，但没有赋值</li>
<li>访问对象上不存在的属性</li>
<li>函数定义了形参，但没有传递实参</li>
<li>使用 void 对表达式求值</li>
</ol>
<p>因此，undefined 一般都来自某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined。</p>
<p>null 的字面意思是：空值。这个值的语义是，希望<strong>表示一个对象被人为的重置为空对象，而非一个变量最原始的状态</strong>。在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
<p>null 有属于自己的类型 Null，而不属于 Object 类型，typeof 之所以会判定为 Object 类型，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，<strong>二进制的前三位为 0 会被 typeof 判断为对象类型</strong>，而 null 的二进制位恰好都是 0，因此 null 被误判断为 Object 类型。</p>
<h2 id="数组-和-类数组的区别"><a href="#数组-和-类数组的区别" class="headerlink" title="数组 和 类数组的区别"></a>数组 和 类数组的区别</h2><ol>
<li><p>定义</p>
<ul>
<li>数组是一个特殊对象，与常规对象的区别：<ul>
<li>当由新元素添加到列表中时，自动更新 length 属性</li>
<li>设置 length 属性，可以截断数组</li>
<li>从 <code>Array.protoype</code> 中继承了方法</li>
<li>属性为 <code>Array</code></li>
</ul>
</li>
<li>类数组是一个拥有 length 属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。</li>
</ul>
</li>
<li><p>区别</p>
<p>本质：类数组是简单对象，它的原型关系与数组不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原型关系和原始值转换</span><br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    length: <span class="hljs-number">10</span>,<br>&#125;;<br><span class="hljs-built_in">console</span>.log(arrayLike <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(arrayLike.__proto__.constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(arrayLike.toString()); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-built_in">console</span>.log(arrayLike.valueOf()); <span class="hljs-comment">// &#123;length: 10&#125;</span><br><br><span class="hljs-keyword">let</span> array = [];<br><span class="hljs-built_in">console</span>.log(array <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(array.__proto__.constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(array.toString()); <span class="hljs-comment">// ''</span><br><span class="hljs-built_in">console</span>.log(array.valueOf()); <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>类数组转换为数组</p>
<ul>
<li>转换方法<ul>
<li>使用 <code>Array.from()</code></li>
<li>使用 <code>Array.prototype.slice.call()</code></li>
<li>使用 <code>Array.prototype.forEach()</code> 进行属性遍历并组成新的数组</li>
</ul>
</li>
<li>转换须知<ul>
<li>转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。</li>
</ul>
</li>
</ul>
<p>代码示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> al1 = &#123;<br>    length: <span class="hljs-number">4</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-number">4</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">5</span>,<br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(al1)) <span class="hljs-comment">// [0, 1, undefined, 3]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>②仅考虑 0或正整数 的索引</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 代码示例</span><br><span class="hljs-keyword">let</span> al2 = &#123;<br>    length: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">'-1'</span>: <span class="hljs-number">-1</span>,<br>    <span class="hljs-string">'0'</span>: <span class="hljs-number">0</span>,<br>    a: <span class="hljs-string">'a'</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(al2)); <span class="hljs-comment">// [0, 1, undefined, undefined]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>③使用slice转换产生稀疏数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 代码示例</span><br><span class="hljs-keyword">let</span> al2 = &#123;<br>    length: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">'-1'</span>: <span class="hljs-number">-1</span>,<br>    <span class="hljs-string">'0'</span>: <span class="hljs-number">0</span>,<br>    a: <span class="hljs-string">'a'</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.slice.call(al2)); <span class="hljs-comment">//[0, 1, empty × 2]</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用数组方法操作类数组注意地方</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike2 = &#123;<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-number">4</span>,<br>    length: <span class="hljs-number">2</span>,<br>    push: <span class="hljs-built_in">Array</span>.prototype.push<br>&#125;;<br><br><span class="hljs-comment">// push 操作的是索引值为 length 的位置</span><br>arrayLike2.push(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(arrayLike2); <span class="hljs-comment">// &#123;2: 1, 3: 4, length: 3, push: ƒ&#125;</span><br>arrayLike2.push(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(arrayLike2); <span class="hljs-comment">// &#123;2: 1, 3: 2, length: 4, push: ƒ&#125;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2><p><strong>Set</strong></p>
<ol>
<li>成员不能重复；</li>
<li>只有键值，没有键名，有点类似数组；</li>
<li>可以遍历，方法有 add、delete、has</li>
</ol>
<p><strong>WeakSet</strong></p>
<ol>
<li>成员都是对象（引用）；</li>
<li>成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；</li>
<li>不能遍历，方法有 add、delete、has；</li>
</ol>
<p><strong>Map</strong></p>
<ol>
<li>本质上是键值对的集合，类似集合；</li>
<li>可以遍历，方法很多，可以跟各种数据格式转换；</li>
</ol>
<p><strong>WeakMap</strong></p>
<ol>
<li>只接收对象为键名（null 除外），不接受其他类型的值作为键名；</li>
<li>键名指向的对象，不计入垃圾回收机制；</li>
<li>不能遍历，方法同 get、set、has、delete；</li>
</ol>
<h2 id="简单说说-js-中有哪几种内存泄露的情况"><a href="#简单说说-js-中有哪几种内存泄露的情况" class="headerlink" title="简单说说 js 中有哪几种内存泄露的情况"></a>简单说说 js 中有哪几种内存泄露的情况</h2><ol>
<li>意外的全局变量；</li>
<li>闭包；</li>
<li>未被清空的定时器；</li>
<li>未被销毁的事件监听；</li>
<li>DOM 引用；</li>
</ol>
<h2 id="json-和-xml-数据的区别"><a href="#json-和-xml-数据的区别" class="headerlink" title="json 和 xml 数据的区别"></a>json 和 xml 数据的区别</h2><ol>
<li>数据体积方面：xml 是重量级的，json 是轻量级的，传递的速度更快些。</li>
<li>数据传输方面：xml 在传输过程中比较占带宽，json 占带宽少，易于压缩。</li>
<li>数据交互方面：json 与 javascript 的交互更加方便，更容易解析处理，更好的进行数据交互。</li>
<li>数据描述方面：json 对数据的描述性比 xml 较差。</li>
<li>xml 和 json 都用在项目交互下，xml 多用于做配置文件，json 用于数据交互。</li>
</ol>
<h2 id="JavaScript-有几种方法判断变量的类型"><a href="#JavaScript-有几种方法判断变量的类型" class="headerlink" title="JavaScript 有几种方法判断变量的类型?"></a>JavaScript 有几种方法判断变量的类型?</h2><ol>
<li><p>使用 <code>typeof</code> 检测。当需要判断变量是否是 number，string，boolean，function，undefined 等类型时，可以使用 typeof 进行判断。</p>
</li>
<li><p>使用 <code>instanceof</code> 检测。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。</p>
</li>
<li><p>使用 <code>constructor</code> 检测。constructor 本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。</p>
</li>
</ol>
<h2 id="如何创建响应式布局？"><a href="#如何创建响应式布局？" class="headerlink" title="如何创建响应式布局？"></a>如何创建响应式布局？</h2><ol>
<li>可以通过引用 Bootstrap 实现</li>
<li>通过看 Bootstrap 源码文件，可知其本质就是通过 CSS 实现的</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-comment">/*浏览器窗口宽度大于768,背景色变为 green*/</span></span><br><span class="css">    <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">768px</span>) &#123;</span><br><span class="css">        <span class="hljs-selector-class">.pg-header</span>&#123;</span><br>            background-color: green;<br>        &#125;<br>    &#125;<br><br><span class="css">    <span class="hljs-comment">/*浏览器窗口宽度大于992,背景色变为 pink*/</span></span><br><span class="css">    <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">992px</span>) &#123;</span><br><span class="css">        <span class="hljs-selector-class">.pg-header</span>&#123;</span><br>            background-color: pink;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="什么是-ajax-请求？并使用-jQuery-和-XMLHttpRequest-对象实现一个-ajax-请求"><a href="#什么是-ajax-请求？并使用-jQuery-和-XMLHttpRequest-对象实现一个-ajax-请求" class="headerlink" title="什么是 ajax 请求？并使用 jQuery 和 XMLHttpRequest 对象实现一个 ajax 请求"></a>什么是 ajax 请求？并使用 jQuery 和 XMLHttpRequest 对象实现一个 ajax 请求</h3><ol>
<li><p>没用ajax：浏览器访问服务器请求，用户看得到（页面刷新也就等同于重新发请求，刷新看得到，也就等同于请求看得到）。等请求完，页面刷新，新内容出现，用户看到新内容。</p>
</li>
<li><p>用ajax：浏览器访问服务器请求，用户看不到，是悄悄进行。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>
</li>
</ol>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5703697.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5703697.html</a></p>
<h3 id="如何在前端实现轮训？"><a href="#如何在前端实现轮训？" class="headerlink" title="如何在前端实现轮训？"></a>如何在前端实现轮训？</h3><p>轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出 HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    xhr.open(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'/user'</span>);<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>         ...<br>    &#125;;<br>    xhr.send();<br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>


<h3 id="如何在前端实现长轮训"><a href="#如何在前端实现长轮训" class="headerlink" title="如何在前端实现长轮训"></a>如何在前端实现长轮训</h3><p>ajax 实现:在发送 ajax 后,服务器端会阻塞请求直到有数据传递或超时才返回。</p>
<p>客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'/user'</span>);<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        ajax();<br>    &#125;;<br>    xhr.send();<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="简述-jsonp-及实现原理"><a href="#简述-jsonp-及实现原理" class="headerlink" title="简述 jsonp 及实现原理"></a>简述 jsonp 及实现原理</h3><p>因为有同源策略，所以需要使用 scripy 标签</p>
<p>原理：</p>
<ol>
<li>先在客户端注册一个 callback, 然后把 callback 的名字传给服务器。</li>
<li>此时，服务器先生成 json 数据。</li>
<li>然后以 javascript 语法的方式，生成一个 function , function 名字就是传递上来的参数 jsonp。</li>
<li>最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。</li>
<li>客户端浏览器，解析 script 标签，并执行返回的 javascript 文档，此时数据作为参数传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）</li>
</ol>
<p>注意: </p>
<ul>
<li>JSON 是一种数据格式。</li>
<li>JSONP 是一种数据调用的方式。</li>
</ul>
<h3 id="什么是-cors"><a href="#什么是-cors" class="headerlink" title="什么是 cors"></a>什么是 cors</h3><p>跨域资源共享（Cross-Origin Resource Sharing）: 其本质是设置响应头，使得浏览器允许跨域请求。</p>
<p>其实浏览器的请求共分为两类：</p>
<ol>
<li><p>简单请求(一次请求)</p>
<ol>
<li>请求方式：HEAD、GET、POST</li>
<li>请求头只包括以下信息:<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type 对应的值是三个中的任意一个<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ol>
</li>
<li><p>非简单请求，又叫复杂请求(两次请求)<br>除简单请求之外的请求都是非简单请求。非简单请求类请求在发送真正的请求之前，会默认发送一个 <code>options</code> 请求，做’预检’，预检成功后才发送真正的请求<br>预检：如果复杂请求是 PUT 等请求，则服务端需要设置允许某请求，参数为 <code>Access-Control-Request-Method</code>，否则“预检”不通过<br>如果复杂请求设置了请求头，则服务端需要设置允许某请求头，参数为 <code>Access-Control-Request-Headers</code>，否则“预检”不通过</p>
</li>
</ol>
<h3 id="你曾经使用过哪些前端框架？"><a href="#你曾经使用过哪些前端框架？" class="headerlink" title="你曾经使用过哪些前端框架？"></a>你曾经使用过哪些前端框架？</h3><ul>
<li>jQuery  </li>
<li>BootStrap、H-ui、layui、Element</li>
<li>Vue(与vue齐名的前端框架React和Angular)</li>
</ul>
<h2 id="jQuery-this-和-this-的区别"><a href="#jQuery-this-和-this-的区别" class="headerlink" title="jQuery this 和 $(this) 的区别"></a>jQuery this 和 $(this) 的区别</h2><ul>
<li>this 是 javascript 自身的语法关键字，它指向一个 javascript 对象，所以可以使用所指向的目标 javascript 对象所拥有的方法, 但他自己不是一个普通的变量，所以你无法自己定义一个变量叫 this</li>
<li>所以为了使用 jQuery 对象的方法，你必须传入 jQuery 函数 $(this), 将 javascript 对象包装成为一个 jquery 对象。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF/" class="print-no-link">#前端</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>02-面试之前端 js</div>
      <div>https://flepeng.github.io/interview-20-开发语言类-21-frontend-02-面试之前端-js/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
