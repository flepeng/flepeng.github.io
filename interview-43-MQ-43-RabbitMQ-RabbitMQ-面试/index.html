

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="RabbitMQ 基础什么是 RabbitMQRabbitMQ是一款开源的，Erlang编写的，消息中间件。最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦可以用它来：解耦、异步、削峰。 RabbitMQ 基本概念 Broker：简单来说就是消息队列服务器实体 Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列 Queue：消息队列载体，每个消息都会被投入到一个或">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 面试">
<meta property="og:url" content="https://flepeng.github.io/interview-43-MQ-43-RabbitMQ-RabbitMQ-%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="RabbitMQ 基础什么是 RabbitMQRabbitMQ是一款开源的，Erlang编写的，消息中间件。最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦可以用它来：解耦、异步、削峰。 RabbitMQ 基本概念 Broker：简单来说就是消息队列服务器实体 Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列 Queue：消息队列载体，每个消息都会被投入到一个或">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://flepeng.github.io/img/java/course/105/1575274339325.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/course/105/image-20191205102917088.png">
<meta property="og:image" content="https://flepeng.github.io/img/java/course/105/image-20191205102457994.png">
<meta property="og:image" content="https://flepeng.github.io/img/rabbitmq/1690705503-9c4dc5cdda2e0c112b76cb201e1a14aa.png">
<meta property="og:image" content="https://flepeng.github.io/img/rabbitmq/1690705503-9c4dc5cdda2e0c112b76cb201e1a14aa.png">
<meta property="article:published_time" content="2020-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.490Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flepeng.github.io/img/java/course/105/1575274339325.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>RabbitMQ 面试 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="RabbitMQ 面试"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-08-08 00:00" pubdate>
          2020年8月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">RabbitMQ 面试</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="RabbitMQ-基础"><a href="#RabbitMQ-基础" class="headerlink" title="RabbitMQ 基础"></a>RabbitMQ 基础</h2><h3 id="什么是-RabbitMQ"><a href="#什么是-RabbitMQ" class="headerlink" title="什么是 RabbitMQ"></a>什么是 RabbitMQ</h3><p>RabbitMQ是一款开源的，Erlang编写的，消息中间件。最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦可以用它来：解耦、异步、削峰。</p>
<h3 id="RabbitMQ-基本概念"><a href="#RabbitMQ-基本概念" class="headerlink" title="RabbitMQ 基本概念"></a>RabbitMQ 基本概念</h3><ul>
<li><code>Broker</code>：简单来说就是消息队列服务器实体</li>
<li><code>Exchange</code>：消息交换机，它指定消息按什么规则，路由到哪个队列</li>
<li><code>Queue</code>：消息队列载体，每个消息都会被投入到一个或多个队列</li>
<li><code>Binding</code>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li>
<li><code>Routing Key</code>：路由关键字，exchange根据这个关键字进行消息投递</li>
<li><code>VHost</code>： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li>
<li><code>Producer</code>： 消息生产者，就是投递消息的程序</li>
<li><code>Consumer</code>： 消息消费者，就是接受消息的程序</li>
<li><code>Channel</code>： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li>
</ul>
<p>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</p>
<h3 id="RabbitMQ-概念里的-channel、exchange-和-queue-这些东东是逻辑概念，还是对应着进程实体"><a href="#RabbitMQ-概念里的-channel、exchange-和-queue-这些东东是逻辑概念，还是对应着进程实体" class="headerlink" title="RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体"></a>RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体</h3><ul>
<li>queue 具有自己的 erlang 进程；</li>
<li>exchange 内部实现为保存 binding 关系的查找表；</li>
<li>channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。</li>
</ul>
<p>由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。</p>
<p>一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel。</p>
<p>channel 号为 0 的 channel 用于处理所有对于当前 connection 全局有效的帧，而 1-65535 号 channel 用于处理和特定 channel 相关的帧。AMQP 协议给出的 channel 复用模型如下其中每一个 channel 运行在一个独立的线程上，多线程共享同一个 socket。</p>
<h3 id="RabbitMQ的exchange-type-fanout、direct、topic-分别代表什么"><a href="#RabbitMQ的exchange-type-fanout、direct、topic-分别代表什么" class="headerlink" title="RabbitMQ的exchange type fanout、direct、topic 分别代表什么"></a>RabbitMQ的exchange type fanout、direct、topic 分别代表什么</h3><p>amqp 协议中的核心思想就是生产者和消费者隔离，生产者从不直接将消息发送给队列。所以生产者不知道一个消息会被发送到哪个队列中，只是将消息发送到一个交换机。先由交换机接收，然后交换机按照特定的策略转发到Queue进行存储。</p>
<p>Exchange 就是一个交换机，转发各个消息分发到相应的队列中。常用的交换器主要有以下三种：</p>
<ul>
<li><code>type=fanout</code>：类似发布者订阅者模式，会为每一个订阅者创建一个队列，而发布者发布消息时，会将消息放置在所有相关队列中</li>
<li><code>type=direct</code>：队列绑定关键字，生产者将数据和关键字发送到 exchange，exchange 根据关键字判定应该将数据发送至指定队列。</li>
<li><code>type=topic</code>： 队列绑定几个模糊的关键字，之后发送者将数据和路由值发送到exchange，exchange将传入”路由值“和 ”关键字“进行匹配，匹配成功，则将数据发送到指定队列。</li>
</ul>
<table>
<thead>
<tr>
<th>发送者路由值</th>
<th>队列中</th>
</tr>
</thead>
<tbody><tr>
<td>aa.lp.python</td>
<td>aa.*  – 不匹配    (*表示匹配一个)</td>
</tr>
<tr>
<td>aa.lp.python</td>
<td>aa.#  – 匹配      (#表示匹配0个或多个)</td>
</tr>
</tbody></table>
<h3 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h3><ol>
<li><p>simple模式（即最简单的收发模式）<br><img src="/img/java/course/105/1575274339325.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>生产者产生消息，将消息放入队列。</li>
<li>消费者监听消息队列，如果队列中有消息，就消费。<br>消息被拿走后，自动从队列中删除(隐患消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失，这里可以设置成手动的ack，但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。</li>
</ol>
</li>
<li><p>work工作模式(资源的竞争)<br><img src="/img/java/course/105/image-20191205102917088.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>消息产生者将消息放入队列消费者可以有多个。消费者1，消费者2同时监听同一个队列，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。</li>
</ol>
</li>
<li><p>publish&#x2F;subscribe发布订阅(共享资源)<br><img src="/img/java/course/105/image-20191205102457994.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>每个消费者监听自己的队列；</li>
<li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</li>
</ol>
</li>
<li><p>routing路由模式<br><img src="/img/rabbitmq/1690705503-9c4dc5cdda2e0c112b76cb201e1a14aa.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>消息生产者将消息发送给交换机，消息携带路由字符(对象的方法)。交换机根据路由字符串，把消息发送到对应的消息队列。</li>
</ol>
</li>
<li><p>topic 主题模式(路由模式的一种)image-20191205104428234<br><img src="/img/rabbitmq/1690705503-9c4dc5cdda2e0c112b76cb201e1a14aa.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>星号井号代表通配符，星号代表多个单词,井号代表一个单词。</li>
<li>路由功能添加模糊匹配。</li>
<li>消息产生者产生消息，把消息交给交换机，交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费。</li>
</ol>
</li>
</ol>
<h2 id="RabbitMQ-消息的顺序性、可靠性（消息丢失）、重复消费"><a href="#RabbitMQ-消息的顺序性、可靠性（消息丢失）、重复消费" class="headerlink" title="RabbitMQ 消息的顺序性、可靠性（消息丢失）、重复消费"></a>RabbitMQ 消息的顺序性、可靠性（消息丢失）、重复消费</h2><h3 id="RabbitMQ-消息基于什么传输"><a href="#RabbitMQ-消息基于什么传输" class="headerlink" title="RabbitMQ 消息基于什么传输"></a>RabbitMQ 消息基于什么传输</h3><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p>
<h3 id="RabbitMQ-如何控制消息消费的顺序"><a href="#RabbitMQ-如何控制消息消费的顺序" class="headerlink" title="RabbitMQ 如何控制消息消费的顺序"></a>RabbitMQ 如何控制消息消费的顺序</h3><p>默认每个消息队列里的数据是按照顺序被消费者拿走。</p>
<p>如果一个队列有多个消费之，亦可以按照奇偶去消费。例如：消费者1 去队列中获取奇数序列的任务，消费者2 去队列中获取偶数序列的任务。</p>
<p><code>channel.basic_qos(prefetch_count=1)</code>表示谁来谁取，不再按照奇偶数排列（同时也保证了公平的消费分发）。</p>
<h3 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h3><p>消息不可靠的情况可能是消息丢失，劫持等原因；丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</p>
<ol>
<li><p>生产者丢失消息：<br> 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；</p>
<ul>
<li>transaction 机制：发送消息前，开启事务（<code>channel.txSelect()</code>）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</li>
<li>confirm 模式（发送方确认模式）：用的很多。<br>一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到目的队列之后，或者消息被写入磁盘后（可持久化的消息），rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；<br>如果 RabbitMQ 没能处理该消息或发生内部错误从而导致消息丢失，则会发送一个 Nack（notacknowledged，未确认） 消息给你，你可以进行重试操作。<br>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li>
</ul>
</li>
<li><p>消息队列丢数据：消息持久化。<br> 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和 confirm机制 配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。<br> 这样，如果消息持久化磁盘之前，rabbitMQ 阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br> 那么如何持久化呢？其实也很容易，就下面两步</p>
<ol>
<li>将 queue 的持久化标识 durable 设置为 true,则代表是一个持久的队列</li>
<li>发送消息的时候将 <code>deliveryMode=2</code>，这样设置以后即使 rabbitMQ 挂了，重启后也能恢复数据</li>
</ol>
</li>
<li><p>消费者丢失消息：</p>
<p>消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p>
<p><strong>接收方确认机制</strong></p>
<p>RabbitMQ 提供了ack，即工作进程在收到消息并处理后，发送 ack 给 RabbitMQ，告知 RabbitMQ 这时候可以把该消息从队列中删除了（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p>
<p>ack默认是开启的，工作进程显示指定了 <code>no_ack=True</code>。</p>
<p>如果工作进程挂掉了，RabbitMQ 没有收到ack，那么会把该消息重新分发给其他工作进程。</p>
<p>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</p>
<p><strong>下面罗列几种特殊情况</strong>：</p>
<ol>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>
</ol>
</li>
</ol>
<h3 id="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</h3><p><strong>先说为什么会重复消费</strong>：</p>
<p>正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p>
<p>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；</p>
<p>比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</p>
<p>假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<h3 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？</h3><p><strong>消息积压处理办法</strong>：临时紧急扩容 consumer，确保其恢复消费速度。</p>
<ol>
<li>将现有 cnosumer 都停掉，新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ol>
<p><strong>MQ中消息失效办法</strong>：</p>
<p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。</p>
<p>我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p>
<p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<p>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？</p>
<p>没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RabbitMQ-如何对消息做持久化"><a href="#RabbitMQ-如何对消息做持久化" class="headerlink" title="RabbitMQ 如何对消息做持久化"></a>RabbitMQ 如何对消息做持久化</h3><ol>
<li><p>创建队列和发送消息时将设置 <code>durable=Ture</code>，如果在接收到消息还没有存储时，消息也有可能丢失，就必须配置 publisher 为 confirm 模式<br><code>channel.queue_declare(queue=&#39;task_queue&#39;, durable=True)</code></p>
</li>
<li><p>消息消费完成之后返回一个ack，进程收到消息并处理完任务后，发给 rabbitmq 一个 ack 表示任务已经完成，可以删除该任务。</p>
</li>
<li><p>镜像队列：将 queue 镜像到 cluster 中其他的节点之上。在该实现下，如果集群中的一个节点失效了，queue 能自动地切换到镜像中的另一个节点以保证服务的可用性。</p>
</li>
</ol>
<h3 id="为什么不应该对所有的-message-都使用持久化机制"><a href="#为什么不应该对所有的-message-都使用持久化机制" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制"></a>为什么不应该对所有的 message 都使用持久化机制</h3><ol>
<li><p>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。</p>
</li>
<li><p>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，</p>
<ul>
<li>若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed</li>
<li>若 message 设置了 persistent 属性， queue 也设置了 durable 属性，那么当该 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</li>
</ul>
</li>
<li><p>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条&#x2F;秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。<br>另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈</p>
</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="如何保证高可用的？"><a href="#如何保证高可用的？" class="headerlink" title="如何保证高可用的？"></a>如何保证高可用的？</h3><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<ol>
<li><p>单机模式：就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p>
</li>
<li><p>普通集群模式：在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。<br>你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。<br>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
</li>
<li><p>镜像集群模式：这才是所谓的 RabbitMQ 的高可用模式。在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上。<br>每次写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。<br>RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。<br>这样的好处在于，你任何一个机器宕机了，其它机器（节点）还包含了这个 queue的完整数据，别的 consumer 都可以到其它节点上去消费数据。<br>坏处在于，第一，这个性能开销比较大，消息需要同步到其他机器上，导致网络带宽压力和消耗很重！而且占空间。</p>
</li>
</ol>
<h3 id="若-cluster-中拥有某个-queue-的-owner-node-失效了，且该-queue-被声明具有-durable-属性，是否能够成功从其他-node-上重新声明该-queue-？"><a href="#若-cluster-中拥有某个-queue-的-owner-node-失效了，且该-queue-被声明具有-durable-属性，是否能够成功从其他-node-上重新声明该-queue-？" class="headerlink" title="若 cluster 中拥有某个 queue 的 owner node 失效了，且该 queue 被声明具有 durable 属性，是否能够成功从其他 node 上重新声明该 queue ？"></a>若 cluster 中拥有某个 queue 的 owner node 失效了，且该 queue 被声明具有 durable 属性，是否能够成功从其他 node 上重新声明该 queue ？</h3><p>不能，在这种情况下，将得到 404 NOT_FOUND 错误。只能等 queue 所属的 node恢复后才能使用该 queue 。但若该 queue 本身不具有 durable 属性，则可在其他 node 上重新声明。</p>
<h3 id="cluster-中-node-的失效会对-consumer-产生什么影响？若是在-cluster-中创建了-mirrored-queue-，这时-node-失效会对-consumer-产生什么影响？"><a href="#cluster-中-node-的失效会对-consumer-产生什么影响？若是在-cluster-中创建了-mirrored-queue-，这时-node-失效会对-consumer-产生什么影响？" class="headerlink" title="cluster 中 node 的失效会对 consumer 产生什么影响？若是在 cluster 中创建了 mirrored queue ，这时 node 失效会对 consumer 产生什么影响？"></a>cluster 中 node 的失效会对 consumer 产生什么影响？若是在 cluster 中创建了 mirrored queue ，这时 node 失效会对 consumer 产生什么影响？</h3><p>若是 consumer 所连接的那个 node 失效（无论该 node 是否为 consumer 所订阅 queue 的 owner node），则 consumer 会在发现 TCP 连接断开时，按标准行为执行重连逻辑，并根据“Assume Nothing”原则重建相应的 fabric 即可。</p>
<p>若是失效的 node 为 consumer 订阅 queue 的 owner node，则 consumer 只能通过 Consumer Cancellation Notification 机制来检测与该 queue 订阅关系的终止，否则会出现傻等却没有任何消息来到的问题。</p>
<h3 id="能够在地理上分开的不同数据中心使用-RabbitMQ-cluster-么？"><a href="#能够在地理上分开的不同数据中心使用-RabbitMQ-cluster-么？" class="headerlink" title="能够在地理上分开的不同数据中心使用 RabbitMQ cluster 么？"></a>能够在地理上分开的不同数据中心使用 RabbitMQ cluster 么？</h3><p>不能。</p>
<ul>
<li>第一，你无法控制所创建的 queue 实际分布在 cluster 里的哪个 node 上（一般使用 HAProxy + cluster 模型时都是这样），这可能会导致各种跨地域访问时的常见问题；</li>
<li>第二，Erlang 的 OTP 通信框架对延迟的容忍度有限，这可能会触发各种超时，导致业务疲于处理；</li>
<li>第三，在广域网上的连接失效问题将导致经典的“脑裂”问题，而RabbitMQ 目前无法处理（该问题主要是说 Mnesia）。</li>
</ul>
<ol start="136">
<li>RabbitMQ 有哪些重要的角色？<br>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演”快递”的角色，本身不生产消息，只是扮演”快递”的角色。</li>
<li>RabbitMQ 有哪些重要的组件？<br>ConnectionFactory（连接管理器）：应用程序与 Rabbit 之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
<li>RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的<br>RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</li>
<li>RabbitMQ 的消息是怎么发送的？<br>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一<br>个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的<br>客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在”真实” tcp 上的虚拟连接，<br>amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通<br>过这个信道完成的。</li>
<li>RabbitMQ 怎么保证消息的稳定性？<br>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。</li>
<li>RabbitMQ 怎么避免消息丢失？<br>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li>
<li>要保证消息持久化成功的条件有哪些？<br>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</li>
<li>RabbitMQ 持久化有什么缺点？<br>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量<br>使用 ssd 硬盘来缓解吞吐量的问题。</li>
<li>RabbitMQ 有几种广播类型？<br>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取<br>轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li>
<li>RabbitMQ 怎么实现延迟消息队列？<br>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
<li>RabbitMQ 集群有什么用？<br>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。</li>
<li>RabbitMQ 节点的类型有哪些？<br>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
<li>RabbitMQ 集群搭建需要注意哪些问题？<br>各节点之间使用”–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于”秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。</li>
<li>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？<br>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而<br>增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，<br>最多是保持和单节点相同的性能甚至是更糟。</li>
<li>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li>
<li>RabbitMQ 对集群节点停止顺序有要求吗？<br>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好<br>相反的话，可能会造成消息的丢失。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
        <a href="/tags/RabbitMQ/" class="print-no-link">#RabbitMQ</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RabbitMQ 面试</div>
      <div>https://flepeng.github.io/interview-43-MQ-43-RabbitMQ-RabbitMQ-面试/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
