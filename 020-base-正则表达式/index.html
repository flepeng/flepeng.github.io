

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="正则在线测试工具  http:&#x2F;&#x2F;tool.chinaz.com&#x2F;regex&#x2F; https:&#x2F;&#x2F;tool.oschina.net&#x2F;regex&#x2F; https:&#x2F;&#x2F;regex101.com&#x2F;   正则表达式模式在线图示网站：https:&#x2F;&#x2F;regexper.com&#x2F; 正则表达式详细表：https:&#x2F;&#x2F;web.suda.edu.cn&#x2F;hejun&#x2F;chapter8&#x2F;regular_expression_">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="https://flepeng.github.io/020-base-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="正则在线测试工具  http:&#x2F;&#x2F;tool.chinaz.com&#x2F;regex&#x2F; https:&#x2F;&#x2F;tool.oschina.net&#x2F;regex&#x2F; https:&#x2F;&#x2F;regex101.com&#x2F;   正则表达式模式在线图示网站：https:&#x2F;&#x2F;regexper.com&#x2F; 正则表达式详细表：https:&#x2F;&#x2F;web.suda.edu.cn&#x2F;hejun&#x2F;chapter8&#x2F;regular_expression_">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.276Z">
<meta property="article:author" content="Feng Lepeng">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>正则表达式 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="正则表达式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-08 00:00" pubdate>
          2023年8月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          47 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">正则表达式</h1>
            
            
              <div class="markdown-body">
                
                <ul>
<li>正则在线测试工具 <ul>
<li><a href="http://tool.chinaz.com/regex/" target="_blank" rel="noopener">http://tool.chinaz.com/regex/</a></li>
<li><a href="https://tool.oschina.net/regex/" target="_blank" rel="noopener">https://tool.oschina.net/regex/</a></li>
<li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a></li>
</ul>
</li>
<li>正则表达式模式在线图示网站：<a href="https://regexper.com/" target="_blank" rel="noopener">https://regexper.com/</a></li>
<li>正则表达式详细表：<a href="https://web.suda.edu.cn/hejun/chapter8/regular_expression_table.html" target="_blank" rel="noopener">https://web.suda.edu.cn/hejun/chapter8/regular_expression_table.html</a></li>
</ul>
<h1 id="1、元字符"><a href="#1、元字符" class="headerlink" title="1、元字符"></a>1、元字符</h1><p>万物皆有源，正则也是如此，元字符是构造正则表达式的一种基本元素。  </p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配数字</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串的结束</td>
</tr>
</tbody></table>
<p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，比如：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"># 1.  匹配有abc开头的字符串：<br>1<span class="hljs-symbol">\b</span>abc或者^abc<br><br><br># 2.  匹配8位数字的QQ号码：<br>1^<span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span>$<br><br><br># 3.  匹配1开头11位数字的手机号码：<br>1^1<span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span>$<br></code></pre></td></tr></table></figure>


<h2 id="1-1、反义字符"><a href="#1-1、反义字符" class="headerlink" title="1.1、反义字符"></a>1.1、反义字符</h2><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>\W</code></td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td><code>[^x]</code></td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h2 id="1-2、字符组"><a href="#1-2、字符组" class="headerlink" title="1.2、字符组"></a>1.2、字符组</h2><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[0123456789]</code></td>
<td>8</td>
<td>True</td>
<td>在一个字符组里枚举合法的所有字符，字符组里的任意一个字符<br>和”待匹配字符”相同都视为可以匹配</td>
</tr>
<tr>
<td><code>[0123456789]</code></td>
<td>a</td>
<td>False</td>
<td>由于字符组中没有”a”字符，所以不能匹配</td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>7</td>
<td>True</td>
<td>也可以用-表示范围,<code>[0-9]</code>和 <code>[0123456789]</code> 是一个意思</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>s</td>
<td>True</td>
<td>同样的如果要匹配所有的小写字母，直接用<code> [a-z]</code>就可以表示</td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td>B</td>
<td>True</td>
<td><code>[A-Z]</code>就表示所有的大写字母</td>
</tr>
<tr>
<td><code>[0-9a-fA-F]</code></td>
<td>e</td>
<td>True</td>
<td>可以匹配数字，大小写形式的a～f，用来验证十六进制字符</td>
</tr>
<tr>
<td><code>[\u4e00-\u9fa5]</code></td>
<td>汉字</td>
<td>True</td>
<td>可以匹配所有的汉字</td>
</tr>
</tbody></table>
<h1 id="2、重复限定符-数量限定符"><a href="#2、重复限定符-数量限定符" class="headerlink" title="2、重复限定符(数量限定符)"></a>2、重复限定符(数量限定符)</h1><p>限定字符多用于重复匹配次数</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复零次或一次</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>重复n次</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># <span class="hljs-number">1.</span>  匹配<span class="hljs-number">8</span>位数字的QQ号码：<br><span class="hljs-number">1</span>^\d&#123;<span class="hljs-number">8</span>&#125;$<br><br><br># <span class="hljs-number">2.</span>  匹配<span class="hljs-number">1</span>开头<span class="hljs-number">11</span>位数字的手机号码：<br><span class="hljs-number">1</span>^<span class="hljs-number">1</span>\d&#123;<span class="hljs-number">10</span>&#125;$<br><br><br># <span class="hljs-number">3.</span>  匹配银行卡号是<span class="hljs-number">14</span>~<span class="hljs-number">18</span>位的数字：<br><span class="hljs-number">1</span>^\d&#123;<span class="hljs-number">14</span>,<span class="hljs-number">18</span>&#125;$<br><br><br># <span class="hljs-number">4.</span>  匹配以a开头的，<span class="hljs-number">0</span>个或多个b结尾的字符串<br><span class="hljs-number">1</span>^ab*$<br></code></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">(<span class="hljs-string">?i</span>)：匹配时不区分大小写。表示匹配时不区分大小写。<br>(<span class="hljs-string">?s</span>)：Singleline(单行模式)。表示更改.的含义，使它与每一个字符匹配（包括换行 符\n）。<br>(<span class="hljs-string">?m</span>)：Multiline(多行模式)。表示更改^和$的 含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的 精确含意是<span class="hljs-symbol">:</span>匹配\n之前的位置以及字符串结束前的位置.) <br>(<span class="hljs-string">?x</span>)：表示如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。 <br>(<span class="hljs-string">?e</span>)：表示本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。 <br>(<span class="hljs-string">?A</span>)：表示如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说<span class="hljs-string">"/a/A"</span>匹配<span class="hljs-string">"abcd"</span>。 <br>(<span class="hljs-string">?E</span>)：与<span class="hljs-string">"m"</span>相反，表示如果使用这个修饰符，那么<span class="hljs-string">"$"</span>将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。 <br>(<span class="hljs-string">?U</span>)：表示和问号的作用差不多，用于设置<span class="hljs-string">"贪婪模式"</span>。<br></code></pre></td></tr></table></figure>


<h1 id="3、分组"><a href="#3、分组" class="headerlink" title="3、分组 ()"></a>3、分组 <code>()</code></h1><p>从上面的例子（4）中看到，<code>*</code> 限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 ab 同时被 <code>*</code> 限定那怎么办呢？</p>
<blockquote>
<p>正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。</p>
</blockquote>
<p>因此当我们要匹配多个ab时，我们可以这样  </p>
<p>如：匹配字符串中包含0到多个ab开头：<code>1^(ab)*</code> </p>
<p>常用分组语法</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>捕获</td>
<td><code>(exp) </code></td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>捕获</td>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td>捕获</td>
<td><code>(?:exp)</code></td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>零宽断言</td>
<td><code>(?=exp)</code></td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td>零宽断言</td>
<td><code>(?&lt;=exp)</code></td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td>零宽断言</td>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td>零宽断言</td>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td><code>(?#comment)</code></td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody></table>
<h1 id="4、转义"><a href="#4、转义" class="headerlink" title="4、转义 \"></a>4、转义 <code>\</code></h1><p>我们看到正则表达式用小括号来做分组，那么问题来了：</p>
<blockquote>
<p>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？</p>
</blockquote>
<p>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是 <code>\</code> 即可。  </p>
<p>如：要匹配以(ab)开头：<code>1^(\(ab\))*</code> </p>
<h1 id="5、条件或"><a href="#5、条件或" class="headerlink" title="5、条件或 \"></a>5、条件或 <code>\</code></h1><p>回到手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130&#x2F;131&#x2F;132&#x2F;155&#x2F;156&#x2F;185&#x2F;186&#x2F;145&#x2F;176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？</p>
<blockquote>
<p>正则用符号 <code>|</code> 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。</p>
</blockquote>
<p>那么我们就可以用或条件来处理这个问题<code>1^(130|131|132|155|156|185|186|145|176)\d{8}$</code> </p>
<h1 id="6、区间"><a href="#6、区间" class="headerlink" title="6、区间"></a>6、区间</h1><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？  </p>
<p>实际是有的</p>
<blockquote>
<p>正则提供一个元字符中括号 <code>[]</code> 来表示区间条件。</p>
<ol>
<li>限定 0到9：<code>[0-9]</code></li>
<li>限定 A-Z ：<code>[A-Z]</code></li>
<li>限定某些数字：<code>[165]</code></li>
</ol>
</blockquote>
<p>那上面的正则我们还改成这样：<code>1^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$</code> </p>
<h1 id="7、零宽断言"><a href="#7、零宽断言" class="headerlink" title="7、零宽断言"></a>7、零宽断言</h1><p>无论是零宽还是断言，听起来都古古怪怪的，那先解释一下这两个词。</p>
<ol>
<li>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”，正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</li>
<li>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</li>
</ol>
<p>意思是讲明白了，那他有什么用呢？ 我们来举个栗子：  </p>
<p>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p>
<p><code>&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;</code> </p>
<p>其中只有‘641’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？</p>
<p>下面先讲一下几种类型的断言：</p>
<ol>
<li><p>正向先行断言（正前瞻）：</p>
<ul>
<li>语法：<code>（?=pattern）</code></li>
<li>作用：匹配 pattern 表达式的前面内容，不返回本身。</li>
</ul>
<p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到 <code>&lt;/span&gt;</code> 前面的数字内容。按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:<code>(?=&lt;/span&gt;)</code> 就可以匹配到前面的内容了。  匹配什么内容呢？如果要所有内容那就是：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">String <span class="hljs-keyword">reg</span>=<span class="hljs-string">".+(?=&lt;/span&gt;)"</span>;  <br>String <span class="hljs-keyword">test</span> = <span class="hljs-string">"&lt;span class=\"</span><span class="hljs-keyword">read</span>-<span class="hljs-keyword">count</span>\<span class="hljs-string">"&gt;阅读数：641&lt;/span&gt;"</span>;  <br>Pattern pattern = Pattern.compile(<span class="hljs-keyword">reg</span>);  <br>Matcher mc = pattern.matcher(<span class="hljs-keyword">test</span>);  <br><span class="hljs-keyword">while</span>(mc.find())&#123;  <br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"匹配结果："</span>)  <br>    System.<span class="hljs-keyword">out</span>.println(mc.<span class="hljs-built_in">group</span>());  <br>&#125;  <br><br><span class="hljs-comment">//匹配结果：&lt;span class="read-count"&gt;阅读数：641`</span><br></code></pre></td></tr></table></figure>

<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 <code>\d</code>，那可以改成：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">String <span class="hljs-keyword">reg</span>=<span class="hljs-string">"\d+(?=&lt;/span&gt;)"</span>;  <br>String <span class="hljs-keyword">test</span> = <span class="hljs-string">"&lt;span class=\"</span><span class="hljs-keyword">read</span>-<span class="hljs-keyword">count</span>\<span class="hljs-string">"&gt;阅读数：641&lt;/span&gt;"</span>;  <br>Pattern pattern = Pattern.compile(<span class="hljs-keyword">reg</span>);  <br>Matcher mc = pattern.matcher(<span class="hljs-keyword">test</span>);  <br><span class="hljs-keyword">while</span>(mc.find())&#123;  <br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"匹配结果："</span>)  <br>    System.<span class="hljs-keyword">out</span>.println(mc.<span class="hljs-built_in">group</span>());  <br>&#125;  <br><br><span class="hljs-comment">//匹配结果：641`</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>正向后行断言（正后顾）:</p>
<ul>
<li>语法：<code>（?&lt;=pattern）</code></li>
<li>作用：匹配pattern表达式的后面的内容，不返回本身。</li>
</ul>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。上面的栗子，我们也可以用后行断言来处理.</p>
<p><code>reg=&quot;(?&lt;=&lt;span class=\&quot;read-count\&quot;&gt;阅读数：)\d+&quot;;</code></p>
</li>
<li><p>负向先行断言（负前瞻）</p>
<ul>
<li>语法：<code>(?!pattern)</code></li>
<li>作用：匹配非pattern表达式的前面内容，不返回本身。</li>
</ul>
<p>有正向也有负向，负向在这里其实就是非的意思。  </p>
<p>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”，现在要找到不是’的花朵’前面的祖国  </p>
<p>用正则就可以这样写：<code>祖国(?!的花朵)</code> </p>
</li>
<li><p>负向后行断言（负后顾）</p>
<ul>
<li>语法：<code>(?&lt;!pattern)</code></li>
<li>作用：匹配非 pattern 表达式的后面内容，不返回本身。</li>
</ul>
</li>
</ol>
<h1 id="8、捕获和非捕获"><a href="#8、捕获和非捕获" class="headerlink" title="8、捕获和非捕获"></a>8、捕获和非捕获</h1><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p>
<blockquote>
<p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p>
</blockquote>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<ol>
<li><p>数字编号捕获组：  </p>
<ul>
<li><p>语法：(exp)  </p>
</li>
<li><p>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。  </p>
</li>
<li><p>示例：比如固定电话的：020-85653333，他的正则表达式为：<code>(0\d{2})-(\d{8})</code>，按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<p>我们用Java来验证一下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String test = <span class="hljs-string">"020-85653333"</span>;  <br>String reg=<span class="hljs-string">"(0\d&#123;2&#125;)-(\d&#123;8&#125;)"</span>;  <br>Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(reg);  <br>Matcher mc= pattern.matcher(test);  <br><span class="hljs-keyword">if</span>(mc.find<span class="hljs-literal">()</span>)&#123;  <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"分组的个数有："</span>+mc.group<span class="hljs-constructor">Count()</span>);  <br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=mc.group<span class="hljs-constructor">Count()</span>;i++)&#123;  <br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"个分组为："</span>+mc.group(i));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>分组的个数有：<span class="hljs-number">2</span>  <br><span class="hljs-number">2</span>第<span class="hljs-number">0</span>个分组为：<span class="hljs-number">020</span><span class="hljs-number">-85653333</span>  <br><span class="hljs-number">3</span>第<span class="hljs-number">1</span>个分组为：<span class="hljs-number">020</span>  <br><span class="hljs-number">4</span>第<span class="hljs-number">2</span>个分组为：<span class="hljs-number">85653333</span><br></code></pre></td></tr></table></figure>

<p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
</li>
</ul>
</li>
<li><p>命名编号捕获组：  </p>
<ul>
<li><p>语法：(?<name>exp)  </p>
</li>
<li><p>解释：分组的命名由表达式中的name指定，比如区号也可以这样写:<code>(?&lt;quhao&gt;\0\d{2})-(?&lt;haoma&gt;\d{8})</code><br>按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>quhao</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>haoma</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<p>用代码来验证一下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String test = <span class="hljs-string">"020-85653333"</span>;  <br>String reg=<span class="hljs-string">"(?&lt;quhao&gt;0\d&#123;2&#125;)-(?&lt;haoma&gt;\d&#123;8&#125;)"</span>;  <br>Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(reg);  <br>Matcher mc= pattern.matcher(test);  <br><span class="hljs-keyword">if</span>(mc.find<span class="hljs-literal">()</span>)&#123;  <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"分组的个数有："</span>+mc.group<span class="hljs-constructor">Count()</span>);  <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mc.group(<span class="hljs-string">"quhao"</span>));  <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mc.group(<span class="hljs-string">"haoma"</span>));  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">分组的个数有：<span class="hljs-number">2</span>  <br><span class="hljs-number">2</span>分组名称为:quhao,匹配内容为：<span class="hljs-number">020</span>  <br><span class="hljs-number">3</span>分组名称为:haoma,匹配内容为：<span class="hljs-number">85653333</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>非捕获组：  </p>
<ul>
<li><p>语法：<code>(?:exp)</code>  </p>
</li>
<li><p>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p>
<p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：<code>(?:\0\d{2})-(\d{8})</code> </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody></table>
<p>验证一下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String test = <span class="hljs-string">"020-85653333"</span>;  <br>String reg=<span class="hljs-string">"(?:0\d&#123;2&#125;)-(\d&#123;8&#125;)"</span>;  <br>Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(reg);  <br>Matcher mc= pattern.matcher(test);  <br><span class="hljs-keyword">if</span>(mc.find<span class="hljs-literal">()</span>)&#123;  <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"分组的个数有："</span>+mc.group<span class="hljs-constructor">Count()</span>);  <br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=mc.group<span class="hljs-constructor">Count()</span>;i++)&#123;  <br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"个分组为："</span>+mc.group(i));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">分组的个数有：<span class="hljs-number">1</span>  <br>第<span class="hljs-number">0</span>个分组为：<span class="hljs-number">020</span><span class="hljs-number">-85653333</span>  <br>第<span class="hljs-number">1</span>个分组为：<span class="hljs-number">85653333</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="9、反向引用"><a href="#9、反向引用" class="headerlink" title="9、反向引用"></a>9、反向引用</h1><p>上面讲到捕获，我们知道：**<em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用</em>**。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<ol>
<li>数字编号组反向引用：<code>\k</code> 或 <code>\number</code></li>
<li>命名编号组反向引用：<code>\k</code>或者 <code>\&#39;name&#39;</code></li>
</ol>
<p>其实只是看完捕获不懂不会用是很正常的！因为捕获组通常是和反向引用一起使用的</p>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。</p>
<p>注意两个字眼：“内容” 和 “使用”，这里所说的“内容”，是匹配结果，而不是子表达式本身。因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p>
<p>举栗子：比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母，先用程序思维理一下思路：</p>
<ul>
<li>1）匹配到一个字母</li>
<li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li>
<li>3）如果一样，则匹配成功，否则失败</li>
</ul>
<p>这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？  </p>
<p>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件  </p>
<p>好了，有思路就要实践  </p>
<p>首先匹配一个字母：<code>\w</code>  </p>
<p>我们需要做成分组才能捕获，因此写成这样：<code>(\w)</code></p>
<p>那这个表达式就有一个捕获组：<code>（\w）</code> </p>
<p>然后我们要用这个捕获组作为条件，那就可以：<code>(\w)\1</code>  </p>
<p>可能有人不明白了，<code>\1</code> 是什么意思呢？  </p>
<p>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong>  </p>
<p><strong><em>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的</em></strong>  </p>
<p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 <code>\k&lt;1&gt;</code> 或者 <code>\1</code>  </p>
<p>当然，通常都是是后者。  </p>
<p>我们来测试一下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">String test = <span class="hljs-string">"aabbbbgbddesddfiid"</span>;  <br>Pattern pattern = Pattern.<span class="hljs-keyword">compile</span>(<span class="hljs-string">"(\w)\1"</span>);  <br>Matcher mc= pattern.matcher(test);  <br><span class="hljs-keyword">while</span>(mc.<span class="hljs-keyword">find</span>())&#123;  <br>    System.out.<span class="hljs-keyword">println</span>(mc.<span class="hljs-keyword">group</span>());  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>aa  <br><span class="hljs-number">2</span>bb  <br><span class="hljs-number">3</span>bb  <br><span class="hljs-number">4</span>dd  <br><span class="hljs-number">5</span>dd  <br><span class="hljs-number">6</span>ii<br>``` <br><br>嗯，这就是我们想要的了。  在举个替换的例子，假如想要把字符串中abc换成a<br></code></pre></td></tr></table></figure>
<p>String test &#x3D; “abcbbabcbcgbddesddfiid”;<br>String reg&#x3D;”(a)(b)c”;<br>System.out.println(test.replaceAll(reg, “$1”));;</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>输出结果：`<span class="hljs-number">1</span>abbabcgbddesddfiid` <br><br><br># <span class="hljs-number">10</span>、贪婪和非贪婪<br><br>## <span class="hljs-number">10.1</span>、贪婪<br><br>&gt; 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。  <br>&gt; 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。<br><br>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：`<span class="hljs-number">1</span>\d&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;` <br><br>用来匹配<span class="hljs-number">3</span>到<span class="hljs-number">6</span>位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有<span class="hljs-number">6</span>个个数字可以匹配，那它就是全部匹配到。  <br>如<br></code></pre></td></tr></table></figure>
<p>String reg&#x3D;”\d{3,6}”;<br>String test&#x3D;”61762828 176 2991 871”;<br>System.out.println(“文本：”+test);<br>System.out.println(“贪婪模式：”+reg);<br>Pattern p1 &#x3D;Pattern.compile(reg);<br>Matcher m1 &#x3D; p1.matcher(test);<br>while(m1.find()){<br>    System.out.println(“匹配结果：”+m1.group(0));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>输出结果：<br></code></pre></td></tr></table></figure>
<p>文本：61762828 176 2991 44 871<br>贪婪模式：\d{3,6}<br>匹配结果：617628<br>匹配结果：176<br>匹配结果：2991<br>匹配结果：871</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>由结果可见：本来字符串中的“<span class="hljs-number">61762828</span>”这一段，其实只需要出现<span class="hljs-number">3</span>个（<span class="hljs-number">617</span>）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是<span class="hljs-number">6</span>个。  <br><br>一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？<br><br>&gt; 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。<br></code></pre></td></tr></table></figure>
<p>String reg&#x3D;”(\d{1,2})(\d{3,4})”;<br>String test&#x3D;”61762828 176 2991 87321”;<br>System.out.println(“文本：”+test);<br>System.out.println(“贪婪模式：”+reg);<br>Pattern p1 &#x3D;Pattern.compile(reg);<br>Matcher m1 &#x3D; p1.matcher(test);<br>while(m1.find()){<br>    System.out.println(“匹配结果：”+m1.group(0));<br>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>输出结果：<br></code></pre></td></tr></table></figure>
<p>文本：61762828 176 2991 87321<br>贪婪模式：(\d{1,2})(\d{3,4})<br>匹配结果：617628<br>匹配结果：2991<br>匹配结果：87321</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>1.  “617628” 是前面的\\d&#123;1,2&#125;匹配出了61，后面的匹配出了7628<br>2.  <span class="hljs-string">"2991"</span> 是前面的\\d&#123;1,2&#125;匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)<br>3.  <span class="hljs-string">"87321"</span>是前面的\\d&#123;1,2&#125;匹配出了87，后面的匹配出了321<br><br><br><span class="hljs-comment">## 10.2、懒惰（非贪婪）</span><br><br>&gt; 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。  <br>&gt; 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。<br><br>懒惰量词是在贪婪量词后面加个“？”<br><br>|<span class="hljs-string"> 代码     </span>|<span class="hljs-string"> 说明                            </span>|<br>|<span class="hljs-string"> -------- </span>|<span class="hljs-string"> ------------------------------- </span>|<br>|<span class="hljs-string"> `*?`     </span>|<span class="hljs-string"> 重复任意次，但尽可能少重复      </span>|<br>|<span class="hljs-string"> `+?`     </span>|<span class="hljs-string"> 重复1次或更多次，但尽可能少重复 </span>|<br>|<span class="hljs-string"> `??`     </span>|<span class="hljs-string"> 重复0次或1次，但尽可能少重复    </span>|<br>|<span class="hljs-string"> `&#123;n,m&#125;?` </span>|<span class="hljs-string"> 重复n到m次，但尽可能少重复      </span>|<br>|<span class="hljs-string"> `&#123;n,&#125;?`  </span>|<span class="hljs-string"> 重复n次以上，但尽可能少重复     </span>|<br></code></pre></td></tr></table></figure>
<p>String reg&#x3D;”(\d{1,2}?)(\d{3,4})”;<br>String test&#x3D;”61762828 176 2991 87321”;<br>System.out.println(“文本：”+test);<br>System.out.println(“贪婪模式：”+reg);<br>Pattern p1 &#x3D;Pattern.compile(reg);<br>Matcher m1 &#x3D; p1.matcher(test);<br>while(m1.find()){<br>    System.out.println(“匹配结果：”+m1.group(0));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>输出结果：<br></code></pre></td></tr></table></figure>
<p>文本：61762828 176 2991 87321<br>贪婪模式：(\d{1,2}?)(\d{3,4})<br>匹配结果：61762<br>匹配结果：2991<br>匹配结果：87321</p>
<p>&#96;&#96;&#96;</p>
<p>解答：</p>
<blockquote>
<p>“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762<br>“2991” 是左边的懒惰匹配出2，右边的贪婪匹配出991<br>“87321” 左边的懒惰匹配出8，右边的贪婪匹配出7321</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p><code>.*</code></p>
<p><code>.</code> 表示匹配除换行符 <code>\n</code> 之外的任何单字符，<code>*</code> 表示零次或多次。所以 <code>.*</code> 在一起就表示任意字符出现零次或多次。没有<code>?</code> 表示贪婪模式。比如 <code>a.*b</code>，它将会匹配最长的以 <code>a</code> 开始，以 <code>b</code> 结束的字符串。如果用它来搜索 <code>aabab</code> 的话，它会匹配整个字符串 <code>aabab</code>。这被称为贪婪匹配。  </p>
</li>
<li><p><code>.*?</code></p>
<p> <code>?</code> 跟在 <code>*</code> 或者 <code>+</code> 后边用时，表示懒惰模式。也称非贪婪模式。就是匹配尽可能少的字符。就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br> <code>a.*?b</code> 匹配最短的，以 <code>a</code> 开始，以 <code>b</code> 结束的字符串。如果把它应用于 <code>aabab</code> 的话，它会匹配 <code>aab</code>（第一到第三个字符）和 <code>ab</code>（第四到第五个字符）。  </p>
</li>
<li><p><code>.+?</code></p>
<p> 同上，<code>?</code> 跟在 <code>*</code> 或者 <code>+</code> 后边用时，表示懒惰模式。也称非贪婪模式。就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br> <code>a.+?b</code> 匹配最短的，以 <code>a</code> 开始，以 <code>b</code> 结束的字符串，但 <code>a</code> 和 <code>b</code> 中间至少要有一个字符。如果把它应用于 <code>ababccaab</code> 的话，它会匹配 <code>abab</code>（第一到第四个字符）和 <code>aab</code>（第七到第九个字符）。注意此时匹配结果不是 <code>ab</code>,<code>ab</code> 和 <code>aab</code>。因为 <code>a</code> 和 <code>b</code> 中间至少要有一个字符。</p>
</li>
</ol>
<p>总结</p>
<ul>
<li><code>.+?</code> 表示匹配任意字符一个或则多个</li>
<li><code>.*?</code> 表示匹配任意字符 0 个或多个</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://juejin.cn/post/6844903677119954958" target="_blank" rel="noopener">https://juejin.cn/post/6844903677119954958</a></li>
<li><a href="https://juejin.cn/post/6844903680349585422" target="_blank" rel="noopener">https://juejin.cn/post/6844903680349585422</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>正则表达式</div>
      <div>https://flepeng.github.io/020-base-正则表达式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/020-base-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BD%AC%E8%87%AAgithub/" title="正则表达式(转自github)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">正则表达式(转自github)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/020-base-%E6%B1%87%E7%BC%96%E5%99%A8%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/" title="汇编器、编译器和解释器">
                        <span class="hidden-mobile">汇编器、编译器和解释器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
