

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2488174175014870" crossorigin="anonymous"></script><!-- google 广告 -->
  <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lepeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="语法Vue 中常用的一些指令 v-model：用于表单输入，实现表单控件和数据的双向绑定。   v-on：简写为@，基础事件绑定。 v-bind：简写为:，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。   v-if：取值为 true&#x2F;false，控制元素是否需要被渲染   v-else：和 v-if 指令搭配使用，没有对应的值。当 v-if 的值 false，v-else 才会被渲染出">
<meta property="og:type" content="article">
<meta property="og:title" content="02-面试之前端 Vue 基础">
<meta property="og:url" content="https://flepeng.github.io/interview-20-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E7%B1%BB-21-frontend-03-Vue-02-%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%89%8D%E7%AB%AF-Vue-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Lepeng">
<meta property="og:description" content="语法Vue 中常用的一些指令 v-model：用于表单输入，实现表单控件和数据的双向绑定。   v-on：简写为@，基础事件绑定。 v-bind：简写为:，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。   v-if：取值为 true&#x2F;false，控制元素是否需要被渲染   v-else：和 v-if 指令搭配使用，没有对应的值。当 v-if 的值 false，v-else 才会被渲染出">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T10:25:30.486Z">
<meta property="article:author" content="Feng Lepeng">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>02-面试之前端 Vue 基础 - Lepeng</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"flepeng.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f3d259b9efd9ce8655c180fd01bf0045","google":{"measurement_id":"G-LFTE4C7W3W"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f3d259b9efd9ce8655c180fd01bf0045";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LFTE4C7W3W", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-LFTE4C7W3W');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lepeng 的 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="02-面试之前端 Vue 基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-08 00:00" pubdate>
          2023年8月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          42 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">02-面试之前端 Vue 基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="Vue-中常用的一些指令"><a href="#Vue-中常用的一些指令" class="headerlink" title="Vue 中常用的一些指令"></a>Vue 中常用的一些指令</h2><ol>
<li><code>v-model</code>：用于表单输入，实现表单控件和数据的双向绑定。  </li>
<li><code>v-on</code>：简写为<code>@</code>，基础事件绑定。</li>
<li><code>v-bind</code>：简写为<code>:</code>，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。  </li>
<li><code>v-if</code>：取值为 <code>true/false</code>，控制元素是否需要被渲染  </li>
<li><code>v-else</code>：和 <code>v-if</code> 指令搭配使用，没有对应的值。当 <code>v-if</code> 的值 <code>false</code>，<code>v-else</code> 才会被渲染出来。  </li>
<li><code>v-show</code>：指令的取值为 <code>true/false</code>，分别对应着显示&#x2F;隐藏。  </li>
<li><code>v-for</code>：遍历 data 中存放的数组数据，实现列表的渲染。  </li>
<li><code>v-once</code>：使用 <code>v-once</code> 指令，你能执行一次性地插值，当数据改变时，插值处的内容不会更新</li>
</ol>
<h2 id="v-show-与-v-if-有什么区别-★★★★★"><a href="#v-show-与-v-if-有什么区别-★★★★★" class="headerlink" title="v-show 与 v-if 有什么区别 ★★★★★"></a><code>v-show</code> 与 <code>v-if</code> 有什么区别 ★★★★★</h2><p><code>v-show</code> 和 <code>v-if</code> 都是用来显示隐藏元素，<code>v-if</code> 还有一个 <code>v-else</code> 配合使用，两者达到的效果都一样，但是 <code>v-if</code> 更消耗性能的，因为 <code>v-if</code> 在显示隐藏过程中有 DOM 的添加和删除，<code>v-show</code> 就简单多了，只是操作 css。</p>
<ul>
<li><code>v-if</code>： 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li>
<li><code>v-show</code>：就简单得多。不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 <code>display</code> 属性进行切换。</li>
</ul>
<p>所以，<code>v-if</code> 适用于在运行时很少改变条件，不需要频繁切换条件的场景；<code>v-show</code> 则适用于需要非常频繁切换条件的场景。</p>
<h2 id="为什么避免-v-if-和-v-for-一起使用"><a href="#为什么避免-v-if-和-v-for-一起使用" class="headerlink" title="为什么避免 v-if 和 v-for 一起使用"></a>为什么避免 <code>v-if</code> 和 <code>v-for</code> 一起使用</h2><ul>
<li>vue2.x 版本中，当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</li>
<li>vue3.x 版本中，当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code>  具有比 <code>v-for</code> 更高的优先级。</li>
</ul>
<p>官网明确指出：避免 <code>v-if</code> 和 <code>v-for</code> 一起使用，永远不要在一个元素上同时使用 <code>v-if</code> 和 <code>v-for</code>。可以先对数据在计算数据中进行过滤，然后再进行遍历渲染；操作和实现起来都没有什么问题，页面也会正常展示。但是会带来不必要的性能消耗；</p>
<h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><ul>
<li><code>computed</code>: 是计算属性，依赖其它属性值，并且 <code>computed</code> 的值有缓存，只有它依赖的属性值发生改变，下一次获取 <code>computed</code> 的值时才会重新计算</li>
<li><code>watch</code>: 更多的是「观察」的作用，监听某一个值，当被监听的值发生变化时，执行相关操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 <code>computed</code>，因为可以利用 <code>computed</code> 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 <code>watch</code>，使用 <code>watch</code> 选项允许我们执行异步操作(访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h2 id="computed-与-method-的区别"><a href="#computed-与-method-的区别" class="headerlink" title="computed 与 method 的区别"></a>computed 与 method 的区别</h2><p>相同点：</p>
<ul>
<li>如果作为模板的数据显示，二者能实现响应的功能，唯一不同的是 methods 定义的方法需要执行</li>
</ul>
<p>不同点：</p>
<ol>
<li>computed 会基于响应数据缓存，methods 不会缓存</li>
<li>diff 之前先看 data 里的数据是否发生变化，如果没有变化 computed 的方法不会执行，但 methods 里的方法会执行  </li>
<li>computed 是属性调用，methods 是函数调用</li>
</ol>
<h2 id="delete-与-vue-delete-区别"><a href="#delete-与-vue-delete-区别" class="headerlink" title="delete 与 vue.delete 区别?"></a>delete 与 vue.delete 区别?</h2><p>delete 会删除数组的值，但是它依然会在内存中占位置  </p>
<p>而 vue.delete 会删除数组在内存中的占位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> arr1[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">delete</span>(arr2,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(arr1);   <span class="hljs-comment">// [1, empty, 3]</span><br><span class="hljs-built_in">console</span>.log(arr2)    <span class="hljs-comment">// [1,2]</span><br></code></pre></td></tr></table></figure>


<h2 id="Class-与-Style-如何动态绑定？"><a href="#Class-与-Style-如何动态绑定？" class="headerlink" title="Class 与 Style 如何动态绑定？"></a>Class 与 Style 如何动态绑定？</h2><p>Class 可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li><p>对象语法：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&lt;div</span> <span class="hljs-string">v-bind:class="&#123;</span> <span class="hljs-attr">active:</span> <span class="hljs-string">isActive,</span> <span class="hljs-attr">'text-danger':</span> <span class="hljs-string">hasError</span> <span class="hljs-string">&#125;"&gt;&lt;/div&gt;</span><br><span class="hljs-attr">data:</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">isActive:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><br>    <span class="hljs-attr">hasError:</span> <span class="hljs-literal">false</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>数组语法：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">    &lt;div v-bind:<span class="hljs-keyword">class</span>="[<span class="hljs-symbol">isActive</span> ? <span class="hljs-symbol">activeClass</span> : '', <span class="hljs-symbol">errorClass</span>]"&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br>    <span class="hljs-symbol">data: </span>&#123;<br>        activeClass: <span class="hljs-string">'active'</span>,<br>        errorClass: <span class="hljs-string">'text-danger'</span><br>    &#125;<br>    ``` <br><br>Style 也可以通过对象语法和数组语法进行动态绑定：<br><br>*   对象语法：<br></code></pre></td></tr></table></figure>
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
    activeColor: 'red',
    fontSize: 30
}
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">*   </span>数组语法：<br></code></pre></td></tr></table></figure>
<div v-bind:style="[styleColor, styleSize]"></div>
data: {
    styleColor: {
        color: 'red'
    },
    styleSize:{
        fontSize:'23px'
    }
}
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>## 组件中 data 为什么是一个函数，然后 return 一个对象，而 new Vue 实例里 data 可以直接是一个对象？<br></code></pre></td></tr></table></figure></li>
</ul>
<p>&#x2F;&#x2F; data<br>data() {<br>    return {<br>        message: “子组件”,<br>        childName:this.name<br>    }<br>}</p>
<p>&#x2F;&#x2F; new Vue<br>new Vue({<br>    el: ‘#app’,<br>    router,<br>    template: ‘<App/>‘,<br>    components: {App}<br>})</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><br>因为组件是用来复用的，且 <span class="hljs-type">JS</span> 里对象是引用关系，如果组件中 <span class="hljs-class"><span class="hljs-keyword">data</span> 是一个对象，那么这样作用域没有隔离，子组件中的 <span class="hljs-keyword">data</span> 属性值会相互影响，如果组件中 <span class="hljs-keyword">data</span> 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 <span class="hljs-keyword">data</span> 属性值不会互相影响；</span><br><br>而 new <span class="hljs-type">Vue</span> 的实例，是不会被复用的，因此不存在引用对象的问题。<br><br><br><span class="hljs-meta">##  既然函数是引用类型，为什么 Vue 的 data 还是可以用函数</span><br><br><span class="hljs-type">JavaScript</span> 只有函数构成作用域(注意理解作用域，对象的 `&#123;&#125;` 以及 `<span class="hljs-keyword">if</span>()&#123;&#125;` 都不构成作用域)，<span class="hljs-class"><span class="hljs-keyword">data</span> 是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</span><br><br><br><span class="hljs-meta">## Vue 中的插槽</span><br></code></pre></td></tr></table></figure>
<p>&lt;slot:自定义 name&#x3D;data中的属性对象&gt; </slot></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><br><span class="hljs-type">Vue</span> 中的插槽指的是子组件提供给父组件使用的一个占位符。<br><br>用标签表示，父组件可以在这个占位符中填充任何模板代码，比如 html、组件等，填充的内容会替换掉子组件的标签（替换占位符）<br><br><br><span class="hljs-meta">## Vue 中 data 的属性可以和 methods 中方法同名吗，为什么？</span><br><br>可以同名，methods 的方法名会被 <span class="hljs-class"><span class="hljs-keyword">data</span> 的属性覆盖；调试台也会出现报错信息，但是不影响执行；</span><br><br>原因：源码定义的 initState 函数内部执行的顺序：`props&gt;methods&gt;<span class="hljs-class"><span class="hljs-keyword">data</span>&gt;computed&gt;watch`</span><br></code></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; initState 部分源码<br>export function initState (vm: Component) {<br>    vm._watchers &#x3D; []<br>    const opts &#x3D; vm.$options<br>    if (opts.props) initProps(vm, opts.props)<br>    if (opts.methods) initMethods(vm, opts.methods)<br>    if (opts.data) {<br>        initData(vm)<br>    } else {<br>        observe(vm._data &#x3D; {}, true &#x2F;* asRootData *&#x2F;)<br>    }<br>    if (opts.computed) initComputed(vm, opts.computed)<br>    if (opts.watch &amp;&amp; opts.watch !&#x3D;&#x3D; nativeWatch) {<br>        initWatch(vm, opts.watch)<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>##  Vue 中 `$nextTick` 作用与原理<br><br>作用：是为了可以获取更新后的 DOM。<br><br>由于 Vue DOM 更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。<br><br>为了确保得到更新后的 DOM，所以设置了 `Vue.nextTick()`，就是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br><br>原理： 在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用<br><br>*   Promise<br>*   MutationObserver<br>*   setImmediate<br>*   如果以上都不行则采用 setTimeout<br><br>定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。<br><br><br># 虚拟 DOM<br><br>## 虚拟 DOM 的优缺点<br><br>**优点：**<br><br>*   **保证性能下限：** 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；<br>*   **无需手动操作 DOM：** 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；<br>*   **跨平台：** 虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。<br><br>**缺点:**<br><br>*   **无法进行极致优化：** 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。<br><br><br>## 虚拟 DOM 实现原理？<br><br>虚拟 DOM 的实现原理主要包括以下 3 部分：<br><br>*   用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；<br>*   diff 算法：比较两棵虚拟 DOM 树的差异；<br>*   pach 算法：将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。<br><br>如果对以上 3 个部分还不是很了解的同学，可以查看另一篇详解虚拟 DOM 的文章《[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-14 "https://juejin.cn/post/6844903895467032589#heading-14")》<br><br><br>## Vue 中的 key 有什么作用<br><br>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。<br><br>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。<br><br>具体有无 key 的 diff 过程，可以查看另一篇详解虚拟 DOM 的文章《[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-14 "https://juejin.cn/post/6844903895467032589#heading-14")》<br><br>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速<br><br>**更准确**：因为带 key 就不是就地复用了，在 sameNode 函数 `a.key === b.key` 对比中可以避免就地复用的情况。所以会更加准确。<br><br>**更快速**：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：<br></code></pre></td></tr></table></figure>
<p>function createKeyToOldIdx (children, beginIdx, endIdx) {<br>    let i, key<br>    const map &#x3D; {}<br>    for (i &#x3D; beginIdx; i &lt;&#x3D; endIdx; ++i) {<br>        key &#x3D; children[i].key<br>        if (isDef(key)) map[key] &#x3D; i<br>    }<br>    return map<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>## Vue 列表为什么加 key<br><br>Vue 中列表循环需加 `key="唯一标识"` 唯一标识且最好是静态的，因为 Vue 组件高度复用增加 Key 可以标识组件的唯一性，为了更好地区别各个组件 key 的作用主要是为了高效的更新虚拟 DOM<br><br>**解析：**<br><br>Vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心是基于两个简单的假设  <br><br>首先讲一下 diff 算法的处理方法，对操作前后的 dom 树同一层的节点进行对比，一层一层对比。<br><br>![](/img/interview/frontend/01.png)<br><br>当某一层有很多相同的节点时，也就是列表节点时，Diff 算法的更新过程默认情况下也是遵循以上原则。<br><br>比如以下这个情况：<br><br>![](/img/interview/frontend/02.png)<br><br>可以在 B 和 C 之间加一个 F，Diff 算法默认执行起来是这样的：<br><br>![](/img/interview/frontend/03.png)<br><br>即把 C 更新成 F，D 更新成 C，E 更新成 D，最后再插入 E，是不是很没有效率？<br><br>所以我们需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置去插入新的节点。<br><br>![](/img/interview/frontend/04.png)<br><br><br># 其他<br><br>## 为什么 Vue 采用异步渲染<br><br>Vue 是组件级更新，当前组件里的数据变了，它就会去更新这个组件。当数据更改一次组件就要重新渲染一次，性能不高，为了防止数据一更新就更新组件，所以做了个异步更新渲染。（核心的方法就是 nextTick）<br><br>源码实现原理：  <br><br>当数据变化后会调用 notify 方法，将 watcher 遍历，调用 update 方法通知 watcher 进行更新，这时候 watcher 并不会立即去执行，在 update 中会调用 queueWatcher 方法将 watcher 放到了一个队列里，在 queueWatcher 会根据 watcher 的进行去重，多个属性依赖一个 watcher，如果队列中没有该 watcher 就会将该 watcher 添加到队列中，然后通过 nextTick 异步执行 flushSchedulerQueue 方法刷新 watcher 队列。<br><br>flushSchedulerQueue 中开始会触发一个 before 的方法，其实就是 beforeUpdate，然后 watcher.run() 才开始真正执行 watcher，执行完页面就渲染完成啦，更新完成后会调用 updated 钩子。<br><br><br>## Vue 为什么在 HTML 中监听事件<br><br>你可能注意到这种事件监听的方式违背了关注点分离(separation of concern)这个长期以来的优良传统。但不必担心，因为所有的 Vue 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 或 `@` 有几个好处：<br><br>*   扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。<br>*   因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。  <br>*   当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。<br><br><br>## axios 是什么，其特点和常用语法<br><br>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库， react/Vue 官方都推荐使用 axios 发 ajax 请求。<br><br>特点: 基于 promise 的异步 ajax 请求库，支持 promise 所有的 API 浏览器端/node 端都可以使用，浏览器中创建 XMLHttpRequests  <br><br>*   支持请求／响应拦截器  <br>*   支持请求取消  <br>*   可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类型的数据  <br>*   批量发送多个请求  <br>*   安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。  <br><br>常用语法：<br></code></pre></td></tr></table></figure>
<p>axios(config): 通用&#x2F;最本质的发任意类型请求的方式<br>axios(url[, config]): 可以只指定 url 发 get 请求<br>axios.request(config): 等同于 axios(config)<br>axios.get(url[, config]): 发 get 请求<br>axios.delete(url[, config]): 发 delete 请求<br>axios.post(url[, data, config]): 发 post 请求<br>axios.put(url[, data, config]): 发 put 请求<br>axios.defaults.xxx: 请求的默认全局配置<br>axios.interceptors.request.use(): 添加请求拦截器<br>axios.interceptors.response.use(): 添加响应拦截器<br>axios.create([config]): 创建一个新的 axios(它没有下面的功能)<br>axios.Cancel(): 用于创建取消请求的错误对象<br>axios.CancelToken(): 用于创建取消请求的 token 对象<br>axios.isCancel(): 是否是一个取消请求的错误<br>axios.all(promises): 用于批量执行多个异步请求<br>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>### axios 中的路由的拦截器的作用？<br><br>顾名思义，拦截器主要是拦截，放到 Vue 里面指对 Vue 发出的 http 请求和响应进行拦截，并可以对拦截的请求或响应做一些特殊的处理。<br><br>[拦截器详细介绍](https://github.com/pagekit/Vue-resource/blob/master/docs/http.md)<br><br>拦截器能做的<br><br>*   添加统一的 request 的参数  <br>    比如 header 中加入 `X-Requested-With`，比如客户端需要实现 sign 和 token 的验证机制，比如你可以写 `$http.get('/files', params)`，拦截器帮你拼接成 `http://www.xxxx.com/1/files` 这样的请求地址 <br>*   处理统一的 responseError<br>    *   比如重连机制，拿到 `error.code` 错误码重连，比如 token 过期，重新拿到 token 再次 send request<br>    *   比如统一报错信息，给所有返回的 404 来个提示也会很酷<br><br>简单示例<br></code></pre></td></tr></table></figure>
<p>import axios from ‘axios’</p>
<p>&#x2F;&#x2F; 配置默认的host,假如你的API host是：<a href="http://api.htmlx.club/" target="_blank" rel="noopener">http://api.htmlx.club</a><br>axios.defaults.baseURL &#x3D; ‘<a href="http://api.htmlx.club/" target="_blank" rel="noopener">http://api.htmlx.club</a>‘    </p>
<p>&#x2F;&#x2F; 添加请求拦截器<br>axios.interceptors.request.use(function (config) {<br>  &#x2F;&#x2F; 在发送请求之前做些什么<br>  return config<br>}, function (error) {<br>  &#x2F;&#x2F; 对请求错误做些什么<br>  return Promise.reject(error)<br>});</p>
<p>&#x2F;&#x2F; 添加响应拦截器<br>axios.interceptors.response.use(function (response) {<br>  &#x2F;&#x2F; 对响应数据做点什么<br>  return response<br>}, function (error) {<br>  &#x2F;&#x2F; 对响应错误做点什么<br>  return Promise.reject(error)<br>});</p>
<pre><code class="hljs">

### Vue axios 拦截器和 router 导航守卫的区别

**导航守卫**：导航守卫只能在前端路由发生变化时作出判断，此时不一定会发起 ajax 请求，比如

*   检查请求头中是否带有 token，但是不能判断 token 是否失效
*   判断该路由的访问，该用户是否需有权限登录该页面

**axios 拦截器**：拦截的是 ajax 的请求


## Vue 项目前端开发环境请求服务器接口跨域问题

*   对于 vue-cli 2.x 版本在 config 文件夹配置服务器代理；

*   对于 vue-cli 3.x 版本前端配置服务器代理在 `vue.config.js` 中设置服务器代理；
    *   target: 对应的属性值为你准备向后端服务器发送请求的主机+端口，含义为：相当于把前端发送请求的主机+端口自动替换成挂载的主机和端口，这样前后端的主机端口都一一就不会存在跨域问题；
    *   ws: 表示WebSocket协议；
    *   changeOrigin: true;表示是否改变原域名；这个一定要选择为 true;
    
    这样发送请求的时候就不会出现跨域问题了。


## 既然 Vue 通过数据劫持可以精准探测数据在具体 dom 上的变化,为什么还需要虚拟 DOM diff 呢

**前置知识:** 依赖收集、虚拟 DOM、响应式系统

现代前端框架有两种方式侦测变化，一种是 **pull** ，一种是 **push**

*   **pull:** 其代表为 React，我们可以回忆一下 React 是如何侦测到变化的，我们通常会用 setStateAPI 显式更新，然后 React 会进行一层层的 Virtual Dom Diff 操作找出差异，然后 Patch 到 DOM 上，React 从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的 Diff 操作查找「哪发生变化了」，另外一个代表就是 Angular 的脏检查操作。

*   **push:** Vue 的响应式系统则是 push 的代表，当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知。因此 Vue 是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉 Vue 的响应式系统就知道，通常一个绑定一个数据就需要一个 Watcher，但我们的绑定细粒度过高就会产生大量的 Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 Vue 的设计是选择中等细粒度的方案，在组件级别进行 push 侦测的方式，也就是那套响应式系统，通常我们会第一时间侦测到发生变化的组件，然后在组件内部进行 Virtual Dom Diff 获取更加具体的差异，而 Virtual Dom Diff 则是 pull 操作，Vue 是 push+pull 结合的方式进行变化侦测的。
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
        <a href="/tags/Vue/" class="print-no-link">#Vue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>02-面试之前端 Vue 基础</div>
      <div>https://flepeng.github.io/interview-20-开发语言类-21-frontend-03-Vue-02-面试之前端-Vue-基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lepeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"flepeng/hexo-blog-comment","repo-id":"R_kgDOL0qaig","category":"Announcements","category-id":"DIC_kwDOL0qais4CfBIv","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
